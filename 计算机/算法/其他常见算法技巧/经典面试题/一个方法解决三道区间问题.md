---
title: 一个方法解决三道区间问题
source: https://labuladong.online/zh/algo/practice-in-action/interval-problem-summary/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文讲解区间问题合集，包括删除被覆盖区间、合并区间、区间列表的交集等，解决力扣/LeetCode 上的相关题目，同时给出 Java/Python/Go/JavaScript/C++ 代码实现。
tags:
  - clippings
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [1288\. Remove Covered Intervals](https://leetcode.com/problems/remove-covered-intervals/) | [1288\. 删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/) |  |
| [56\. Merge Intervals](https://leetcode.com/problems/merge-intervals/) | [56\. 合并区间](https://leetcode.cn/problems/merge-intervals/) |  |
| [986\. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/) | [986\. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/) |  |

经常有读者问区间相关的问题，今天写一篇文章，秒杀三道区间相关的问题。

所谓区间问题，就是线段问题，让你合并所有线段、找出线段的交集等等。主要有两个技巧：

**1、排序** 。常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。当然，如果你非要按照终点排序，无非对称操作，本质都是一样的。

**2、画图** 。就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理。

废话不多说，下面我们来做题。

## 区间覆盖问题

这是力扣第 1288 题「 [删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/) 」，看下题目：

**1288\. 删除被覆盖区间** | [力扣](https://leetcode.cn/problems/remove-covered-intervals/) | [LeetCode](https://leetcode.com/problems/remove-covered-intervals/)

给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。

只有当 `c <= a`  且  `b <= d` 时，我们才认为区间 `[a,b)` 被区间 `[c,d)` 覆盖。

在完成所有删除操作后，请你返回列表中剩余区间的数目。

**示例：**

```
输入：intervals = [[1,4],[3,6],[2,8]]
输出：2
解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。
```

**提示：**

- `1 <= intervals.length <= 1000`
- `0 <= intervals[i][0] < intervals[i][1] <= 10^5`
- 对于所有的 `i != j` ： `intervals[i] != intervals[j]`

题目来源： [力扣 1288. 删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/) 。

题目问我们，去除被覆盖区间之后，还剩下多少区间， **那么我们可以先算一算，被覆盖区间有多少个，然后和总数相减就是剩余区间数** 。

对于这种区间问题，如果没啥头绪，首先排个序看看，比如我们按照区间的起点进行升序排序：

![](https://labuladong.online/images/algo/mergeInterval/1.jpg)

排序之后，两个相邻区间可能有如下三种相对位置：

![](https://labuladong.online/images/algo/interval-problems/1.jpeg)

对于这三种情况，我们应该这样处理：

对于情况一，找到了覆盖区间。

对于情况二，两个区间可以合并，成一个大区间。

对于情况三，两个区间完全不相交。

依据几种情况，我们可以写出如下代码：

算法可视化

以上就是本题的解法代码，起点升序排列，终点降序排列的目的是防止如下情况：

![](https://labuladong.online/images/algo/interval-problems/2.jpeg)

对于这两个起点相同的区间，我们需要保证长的那个区间在上面（按照终点降序），这样才会被判定为覆盖，否则会被错误地判定为相交，少算一个覆盖区间。

## 区间合并问题

力扣第 56 题「 [区间合并](https://leetcode.cn/problems/merge-intervals/) 」就是一道相关问题，题目很好理解：

**56\. 合并区间** | [力扣](https://leetcode.cn/problems/merge-intervals/) | [LeetCode](https://leetcode.com/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**

- `1 <= intervals.length <= 10<sup>4</sup>`
- `intervals[i].length == 2`
- `0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10<sup>4</sup>`

题目来源： [力扣 56. 合并区间](https://leetcode.cn/problems/merge-intervals/) 。

我们解决区间问题的一般思路是先排序，然后观察规律。

一个区间可以表示为 `[start, end]` ，前文 [区间调度问题](https://labuladong.online/zh/algo/frequency-interview/interval-scheduling/) 需要按 `end` 排序，以便满足贪心选择性质。

而对于区间合并问题，其实按 `end` 和 `start` 排序都可以，不过为了清晰起见，我们选择按 `start` 排序：

![](https://labuladong.online/images/algo/mergeInterval/1.jpg)

**显然，对于几个相交区间合并后的结果区间 `x` ， `x.start` 一定是这些相交区间中 `start` 最小的， `x.end` 一定是这些相交区间中 `end` 最大的** ：

![](https://labuladong.online/images/algo/mergeInterval/2.jpg)

由于已经排了序， `x.start` 很好确定，求 `x.end` 也很容易，可以类比在数组中找最大值的过程：

然后就可以写出完整代码：

![](https://labuladong.online/images/algo/mergeInterval/3.gif)

算法可视化

## 区间交集问题

力扣第 986 题「 [区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/) 」就是这个问题：

**986\. 区间列表的交集** | [力扣](https://leetcode.cn/problems/interval-list-intersections/) | [LeetCode](https://leetcode.com/problems/interval-list-intersections/)

给定两个由一些 **闭区间** 组成的列表， `firstList` 和 `secondList` ，其中 `firstList[i] = [start<sub>i</sub>, end<sub>i</sub>]` 而 `secondList[j] = [start<sub>j</sub>, end<sub>j</sub>]` 。每个区间列表都是成对 **不相交** 的，并且 **已经排序** 。

返回这 **两个区间列表的交集** 。

形式上， **闭区间** `[a, b]` （其中 `a <= b` ）表示实数  `x`  的集合，而  `a <= x <= b` 。

两个闭区间的 **交集** 是一组实数，要么为空集，要么为闭区间。例如， `[1, 3]` 和 `[2, 4]` 的交集为 `[2, 3]` 。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2019/01/30/interval1.png)
```
输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

**示例 2：**

```
输入：firstList = [[1,3],[5,9]], secondList = []
输出：[]
```

**示例 3：**

```
输入：firstList = [], secondList = [[4,8],[10,12]]
输出：[]
```

**示例 4：**

```
输入：firstList = [[1,7]], secondList = [[3,10]]
输出：[[3,7]]
```

**提示：**

- `0 <= firstList.length, secondList.length <= 1000`
- `firstList.length + secondList.length >= 1`
- `0 <= start<sub>i</sub> < end<sub>i</sub> <= 10<sup>9</sup>`
- `end<sub>i</sub> < start<sub>i+1</sub>`
- `0 <= start<sub>j</sub> < end<sub>j</sub> <= 10<sup>9</sup> `
- `end<sub>j</sub> < start<sub>j+1</sub>`

题目来源： [力扣 986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/) 。

题目很好理解，就是让你找交集，注意区间都是闭区间。

解决区间问题的思路一般是先排序，以便操作，不过题目说已经排好序了，那么可以用两个索引指针在 `A` 和 `B` 中游走，把交集找出来，代码大概是这样的：

不难，我们先老老实实分析一下各种情况。

首先， **对于两个区间** ，我们用 `[a1, a2]` 和 `[b1, b2]` 表示在 `A` 和 `B` 中的两个区间，那么什么情况下这两个区间 **没有交集** 呢：

![](https://labuladong.online/images/algo/intersection/1.jpg)

只有这两种情况，写成代码的条件判断就是这样：

那么，什么情况下，两个区间存在交集呢？根据命题的否定，上面逻辑的否命题就是存在交集的条件：

接下来，两个区间存在交集的情况有哪些呢？穷举出来：

![](https://labuladong.online/images/algo/intersection/2.jpg)

这很简单吧，就这四种情况而已。那么接下来思考，这几种情况下，交集是否有什么共同点呢？

![](https://labuladong.online/images/algo/intersection/3.jpg)

我们惊奇地发现，交集区间是有规律的！如果交集区间是 `[c1, c2]` ，那么 `c1 = max(a1, b1)` ， `c2 = min(a2 ,b2)` ！这一点就是寻找交集的核心，我们把代码更进一步：

最后一步，我们的指针 `i` 和 `j` 肯定要前进（递增）的，什么时候应该前进呢？

![](https://labuladong.online/images/algo/intersection/4.gif)

结合动画示例就很好理解了，是否前进，只取决于 `a2` 和 `b2` 的大小关系：

以此思路写出代码：

算法可视化

总结一下，区间类问题看起来都比较复杂，情况很多难以处理，但实际上通过观察各种不同情况之间的共性可以发现规律，用简洁的代码就能处理。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表