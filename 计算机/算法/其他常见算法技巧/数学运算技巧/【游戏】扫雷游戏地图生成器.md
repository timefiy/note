---
title: 【游戏】扫雷游戏地图生成器
source: https://labuladong.online/zh/algo/game/minesweeper/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本页面介绍了扫雷游戏的基本玩法，并使用算法生成扫雷游戏地图。
tags:
  - clippings
---
扫雷游戏是一款经典的单机游戏，玩家需要在一个方块阵列中，根据已知信息判断未知的方块是否是地雷，并标记出地雷的位置。

在本次游戏挑战中，题目将给你输入 `width, height, mineCount` 三个参数，请你实现一个算法，生成扫雷游戏的初始地图，即一个 `width` 行 `height` 列的二维数组，其中随机分布着 `mineCount` 个地雷。

要求：你的算法必须是 **均匀随机** 的，即每个方块是地雷的概率必须相等（ $P(x) = \frac{mineCount}{width \times height}$ ）。

扫雷游戏演示

请你尝试实现这个算法，点击「提交」按钮后即可用你的算法生成一个扫雷游戏地图，愉快的玩耍吧！

## 进阶

第一个问题，你的随机算法的时间复杂度是多少，空间复杂度是多少？你能不能把算法的空间复杂度控制在 $O(mineCount)$ ？

第二个问题，怎么证明你的随机算法是 **均匀随机** 的？怎么证明每个格子被选中的概率都是相等的？

## 讲解

这个扫雷小游戏主要是考察 **洗牌算法、水塘抽样算法和蒙特卡洛验证方法** ，详细讲解见 [游戏中的随机算法](https://labuladong.online/zh/algo/frequency-interview/random-algorithm/) ，这里仅仅列出解法思路和代码。

主要有两种随机算法可以用来生成扫雷地图：

第一种随机生成扫雷地图的算法是使用洗牌算法。你先把 `mineCount` 个雷初始化到地图的任意位置，然后随机打乱整个地图的所有坐标，这样就相当于把 `mineCount` 个雷随机分布到了地图上。

洗牌算法生成地图的解法代码如下：

```
// 游戏面板仅支持提交 JavaScript 代码

// 其他语言代码的作用是帮助大家理解算法逻辑

#include <vector>

#include <random>

#include <algorithm>

std::vector<std::vector<int>> generate(int width, int height, int mineCount) {

    // 创建结果列表

    std::vector<std::vector<int>> allPositions;

    for (int y = 0; y < height; y++) {

        for (int x = 0; x < width; x++) {

            allPositions.push_back({x, y});

        }

    }

    

    // 使用Fisher-Yates洗牌算法打乱数组

    std::random_device rd;

    std::mt19937 gen(rd());

    for (int i = allPositions.size() - 1; i > 0; i--) {

        // 生成随机索引j (0 <= j <= i)

        std::uniform_int_distribution<> dis(0, i);

        int j = dis(gen);

        // 交换元素i和元素j

        std::swap(allPositions[i], allPositions[j]);

    }

    

    // 取前mineCount个元素作为地雷位置

    std::vector<std::vector<int>> minePositions(allPositions.begin(), allPositions.begin() + mineCount);

    

    return minePositions;

}
```

但是这种解法需要把整个地图（二维数组）创建出来，才能进行随机打乱，所以空间复杂度是 $O(width 	imes height)$ 。

考虑 `width` 和 `height` 非常非常大的情况，我们可能无法真的创建一个 $width 	imes height$ 的二维数组来随机打乱，所以需要使用水塘抽样算法生成雷的坐标。

水塘抽样算法是一种用于在未知大小的数据流中随机选择样本的算法，用这个算法来生成扫雷地图，只需要 $O(mineCount)$ 的空间复杂度来存储雷的坐标，不需要创建 $width 	imes height$ 的二维数组。

水塘抽样算法生成地图的解法代码如下：

```
// 游戏面板仅支持提交 JavaScript 代码

// 其他语言代码的作用是帮助大家理解算法逻辑

#include <vector>

#include <random>

std::vector<std::vector<int>> generate(int width, int height, int mineCount) {

    // 使用水塘抽样算法选择地雷位置

    std::vector<std::vector<int>> minePositions;

    int totalCells = width * height;

    

    std::random_device rd;

    std::mt19937 gen(rd());

    

    // 遍历所有可能的位置

    for (int i = 0; i < totalCells; i++) {

        // 将一维索引转换为二维坐标

        int x = i % width;

        int y = i / width;

        

        if (i < mineCount) {

            // 前mineCount个位置直接加入数组

            minePositions.push_back({x, y});

        } else {

            // 对于后续位置，以 mineCount/i 的概率替换已选中的某个位置

            std::uniform_int_distribution<> dis(0, i);

            int randomIndex = dis(gen);

            if (randomIndex < mineCount) {

                minePositions[randomIndex] = {x, y};

            }

        }

    }

    

    return minePositions;

}
```

如何判断上面的两种随机算法是均匀随机的呢？可以用蒙特卡洛方法来验证。

网站也配套了一个蒙特卡洛方法的模拟器，你可以输入随机算法，模拟器会可视化随机算法的效果，直观感受随机算法的均匀性：

蒙特卡洛方法模拟器

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表