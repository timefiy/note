---
title: 数学技巧相关习题
source: https://labuladong.online/zh/algo/problem-set/math-tricks/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有数学相关算法的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
Tip

数学相关技巧不会考得太难，只要用心寻找规律，注意细节，正确编码，一般不难解决。

### 8\. 字符串转换整数 (atoi)

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数。

函数 `myAtoi(string s)` 的算法如下：

1. **空格：** 读入字符串并丢弃无用的前导空格（ `" "` ）
2. **符号：** 检查下一个字符（假设还未到字符末尾）为 `'-'` 还是 `'+'` 。如果两者都不存在，则假定结果为正。
3. **转换：** 通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。
4. **舍入：** 如果整数数超过 32 位有符号整数范围 `[−2<sup>31</sup>,  2<sup>31&nbsp;</sup>− 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−2<sup>31</sup>` 的整数应该被舍入为 `−2<sup>31</sup>` ，大于 `2<sup>31&nbsp;</sup>− 1` 的整数应该被舍入为 `2<sup>31&nbsp;</sup>− 1` 。

返回整数作为最终结果。

**示例 1：**

**输入：** s = "42"

**输出：** 42

**解释：** 加粗的字符串为已经读入的字符，插入符号是当前读取的字符。

```
带下划线线的字符是所读的内容，插入符号是当前读入位置。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
```

**示例 2：**

**输入：** s = " -042"

**输出：** \-42

**解释：**

```
第 1 步："   -042"（读入前导空格，但忽视掉）
            ^
第 2 步："   -042"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -042"（读入 "042"，在结果中忽略前导零）
               ^
```

**示例 3：**

**输入：** s = " 1337c0d3 "

**输出：** 1337

**解释：**

```
第 1 步："1337c0d3"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："1337c0d3"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："1337c0d3"（读入 "1337"；由于下一个字符不是一个数字，所以读入停止）
             ^
```

**示例 4：**

**输入：** s = "0-1"

**输出：** 0

**解释：**

```
第 1 步："0-1" (当前没有读入字符，因为没有前导空格)
         ^
第 2 步："0-1" (当前没有读入字符，因为这里不存在 '-' 或者 '+')
         ^
第 3 步："0-1" (读入 "0"；由于下一个字符不是一个数字，所以读入停止)
          ^
```

**示例 5：**

**输入：** s = "words and 987"

**输出：** 0

**解释：**

读取在第一个非数字字符“w”处停止。

**提示：**

- `0 <= s.length <= 200`
- `s` 由英文字母（大写和小写）、数字（ `0-9` ）、 `' '` 、 `'+'` 、 `'-'` 和 `'.'` 组成

题目来源： [力扣 8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/) 。

#### 基本思路

这道题说实话没有什么难度，无非就是处理数字、符号、空格和 int 溢出的细节问题，具体看代码吧，把每一步的注释写清楚就不容易在细节上出错了。

#### 解法代码

#### 算法可视化

算法可视化

### 9\. 回文数

**9\. 回文数** | [力扣](https://leetcode.cn/problems/palindrome-number/) | [LeetCode](https://leetcode.com/problems/palindrome-number/)

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数 是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如， `121` 是回文，而 `123` 不是。

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

**提示：**

- `-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1`

**进阶：** 你能不将整数转为字符串来解决这个问题吗？

题目来源： [力扣 9. 回文数](https://leetcode.cn/problems/palindrome-number/) 。

#### 基本思路

如果让你判断回文串应该很简单，我在 [数组双指针技巧汇总](https://labuladong.online/zh/algo/essential-technique/array-two-pointers-summary/) 中讲过。

操作数字没办法像操作字符串那么简单粗暴，但只要你要知道我在 [Rabin Karp 算法详解](https://labuladong.online/zh/algo/practice-in-action/rabinkarp/) 中讲到的从最高位开始生成数字的技巧，就能轻松解决这个问题：

你 **从后往前** 把 `x` 的每一位拿出来，用这个技巧生成一个数字 `y` ，如果 `y` 和 `x` 相等，则说明 `x` 是回文数字。

如何 **从后往前** 拿出一个数字的每一位？和 10 求余数就行了呗。看代码吧。

#### 解法代码

#### 算法可视化

算法可视化

### 50\. Pow(x, n)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数  `n` 次幂函数（即， `x<sup>n</sup>` ）。

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例 2：**

```
输入：x = 2.10000, n = 3
输出：9.26100
```

**示例 3：**

```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

**提示：**

- `-100.0 < x < 100.0`
- `-2<sup>31</sup> <= n <= 2<sup>31</sup>-1`
- `n` 是一个整数
- 要么 `x` 不为零，要么 `n > 0` 。
- `-10<sup>4</sup> <= x<sup>n</sup> <= 10<sup>4</sup>`

题目来源： [力扣 50. Pow(x, n)](https://leetcode.cn/problems/powx-n/) 。

#### 基本思路

幂运算是经典的数学运算技巧了，建议你看下前文 [必知必会数学技巧](https://labuladong.online/zh/algo/essential-technique/math-techniques-summary/) 就能很容易理解解法代码里的思想了。这道题唯一有点恶心的就是 `k` 的取值范围特别大，不能直接加符号，否则会造成整型溢出，具体解法看代码吧。

#### 解法代码

#### 算法可视化

算法可视化

### 67\. 二进制求和

**67\. 二进制求和** | [力扣](https://leetcode.cn/problems/add-binary/) | [LeetCode](https://leetcode.com/problems/add-binary/)

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

**示例 1：**

```
输入:a = "11", b = "1"
输出："100"
```

**示例 2：**

```
输入：a = "1010", b = "1011"
输出："10101"
```

**提示：**

- `1 <= a.length, b.length <= 10<sup>4</sup>`
- `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成
- 字符串如果不是 `"0"` ，就不含前导零

题目来源： [力扣 67. 二进制求和](https://leetcode.cn/problems/add-binary/) 。

#### 基本思路

这道题的关键就是让你用代码模拟加法的运算过程。 **加法的模拟可以理解为是一个通用模式，需要你用一个 `carry` 变量记录并正确进位** ，建议你先去做一下 [2\. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/) 再回来看这道题就手到擒来了。

#### 解法代码

#### 算法可视化

算法可视化

### 400\. 第 N 位数字

**400\. 第 N 位数字** | [力扣](https://leetcode.cn/problems/nth-digit/) | [LeetCode](https://leetcode.com/problems/nth-digit/)

给你一个整数 `n` ，请你在无限的整数序列 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]` 中找出并返回第 `n` 位上的数字。

**示例 1：**

```
输入：n = 3
输出：3
```

**示例 2：**

```
输入：n = 11
输出：0
解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。
```

**提示：**

- `1 <= n <= 2<sup>31</sup> - 1`

题目来源： [力扣 400. 第 N 位数字](https://leetcode.cn/problems/nth-digit/) 。

#### 基本思路

从我的个人刷题经验来看，遇到这类题目最咱首先想到的最简单有效的方式应该是找规律。

一位数有几个？ `1~9` 共 9 \* 1 = 9 个。共几位？共 1 \* 9 = 9 位。

二位数有几个？ `10~99` 共 9 \* 10 = 90 个。共几位？共 2 \* 90 = 180 位。

三位数有几个？ `100~999` 共 9 \* 100 = 900 个。共几位？共 3 \* 900 = 2700 位。

以此类推，我们可以通过这个规律推断第 `n` 位的数字到底是什么。所以这道题的难点在于如何把上述规律写成算法代码，具体看我的实现吧。

#### 解法代码

#### 算法可视化

算法可视化

Tip

数学规律也可以叠加递归的编程技巧，下面是几道例题。

### 372\. 超级次方

**372\. 超级次方** | [力扣](https://leetcode.cn/problems/super-pow/) | [LeetCode](https://leetcode.com/problems/super-pow/)

你的任务是计算 `a<sup>b</sup>`  对  `1337` 取模， `a` 是一个正整数， `b` 是一个非常大的正整数且会以数组形式给出。

**示例 1：**

```
输入：a = 2, b = [3]
输出：8
```

**示例 2：**

```
输入：a = 2, b = [1,0]
输出：1024
```

**示例 3：**

```
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
```

**示例 4：**

```
输入：a = 2147483647, b = [2,0,0]
输出：1198
```

**提示：**

- `1 <= a <= 2<sup>31</sup> - 1`
- `1 <= b.length <= 2000`
- `0 <= b[i] <= 9`
- `b` 不含前导 0

题目来源： [力扣 372. 超级次方](https://leetcode.cn/problems/super-pow/) 。

#### 基本思路

利用指数的性质，显然：

![](https://labuladong.online/images/algo/superPower/formula1.png)

我们的老读者肯定已经敏感地意识到了，这就是递归的标志，因为问题的规模缩小了：

把上述逻辑翻译成代码即可。

由于结果很大，题目要求求模，那么关于求模运算，这里有必要强调一个推论：

**`(a * b) % k = (a % k)(b % k) % k`**

**也就是说，对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模** 。证明见详细题解。

#### 解法代码

#### 算法可视化

算法可视化

### 306\. 累加数

**306\. 累加数** | [力扣](https://leetcode.cn/problems/additive-number/) | [LeetCode](https://leetcode.com/problems/additive-number/)

**累加数** 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 **累加序列** 必须 **至少** 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。

给你一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是 **累加数** 。如果是，返回 `true` ；否则，返回 `false` 。

**说明：** 累加序列里的数，除数字 0 之外， **不会** 以 0 开头，所以不会出现 `1, 2, 03` 或者  `1, 02, 3` 的情况。

**示例 1：**

```
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

**示例 2：**

```
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

**提示：**

- `1 <= num.length <= 35`
- `num` 仅由数字（ `0` - `9` ）组成

**进阶：** 你计划如何处理由过大的整数输入导致的溢出?

题目来源： [力扣 306. 累加数](https://leetcode.cn/problems/additive-number/) 。

#### 基本思路

这道题不算难，要先观察，由于这个「累加」关系是传导的，所以只要我们确定了第一个和第二个数字，后面的数字其实就确定了。

比如说，如果我们确定了第一个数字是 1，第二个数字是 2，那么后面的数字就一定是 3, 5, 8, 13,...

基于这个特性，我们用一个嵌套 for 循环就可以穷举出前两个数字的所有可能了，然后实现一个 `isValid` 函数来验证后面的数字是否满足累加数的性质即可。

你把这搞明白后，可以去做一下 [842\. 将数组拆分成斐波那契序列](https://leetcode.cn/problems/split-array-into-fibonacci-sequence/description/) ，进一步要求我们计算出切分的结果。

#### 解法代码

#### 算法可视化

算法可视化

### 842\. 将数组拆分成斐波那契序列

**842\. 将数组拆分成斐波那契序列** | [力扣](https://leetcode.cn/problems/split-array-into-fibonacci-sequence/) | [LeetCode](https://leetcode.com/problems/split-array-into-fibonacci-sequence/)

给定一个数字字符串 `num` ，比如 `"123456579"` ，我们可以将它分成「斐波那契式」的序列 `[123, 456, 579]` 。

形式上， **斐波那契式** 序列是一个非负整数列表 `f` ，且满足：

- `0 <= f[i] < 2<sup>31</sup>`  ，（也就是说，每个整数都符合 **32 位** 有符号整数类型）
- `f.length >= 3`
- 对于所有的 `0 <= i < f.length - 2` ，都有 `f[i] + f[i + 1] = f[i + 2]`

另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 `0` 本身。

返回从 `num` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]` 。

**示例 1：**

```
输入：num = "1101111"
输出：[11,0,11,11]
解释：输出 [110,1,111] 也可以。
```

**示例 2：**

```
输入: num = "112358130"
输出: []
解释: 无法拆分。
```

**示例 3：**

```
输入："0123"
输出：[]
解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。
```

**提示：**

- `1 <= num.length <= 200`
- `num` 中只含有数字

题目来源： [力扣 842. 将数组拆分成斐波那契序列](https://leetcode.cn/problems/split-array-into-fibonacci-sequence/) 。

#### 基本思路

做这道题，你必须先理解我在 [306\. 累加数](https://leetcode.cn/problems/additive-number/description/) 写的思路。

搞明白之后，这道题其实就是 306 的进阶，其实还是求累加数，只不过这次要问你具体切分出来的累加数是什么。

那么我就基于 306 的 `isValid` 函数做这道题了，直接返回累加数的分割结果，null 代表无法切分。

请你对比查看我这两题的解法代码是怎么改的，思路不难，但关键在于一些细节的处理。

比如本题题目说了，每个元素的取值范围是 \[0, 2^31 - 1\]，所以我们要在代码中加上这个判断，需要同时用字符串长度和 long 类型的值来判断。

我给出的代码为了尽可能和 306 题对应，所以效率上还有优化的点。比如说，既然最后要把 `first, second` 转化成数字，那么我们其实可以不用 `strAdd` 来计算字符加法，直接转化成数字进行加法会更简单，且效率上也会更高。

这些优化就留给你吧，你可以自己改改代码，看看能不能更快。

#### 解法代码

#### 算法可视化

算法可视化

### 357\. 统计各位数字都不同的数字个数

**357\. 统计各位数字都不同的数字个数** | [力扣](https://leetcode.cn/problems/count-numbers-with-unique-digits/) | [LeetCode](https://leetcode.com/problems/count-numbers-with-unique-digits/)

给你一个整数 `n` ，统计并返回各位数字都不同的数字 `x` 的个数，其中 `0 <= x < 10<sup>n</sup>` 。

**示例 1：**

```
输入：n = 2
输出：91
解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x < 100 范围内的所有数字。
```

**示例 2：**

```
输入：n = 0
输出：1
```

**提示：**

- `0 <= n <= 8`

题目来源： [力扣 357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/) 。

#### 基本思路

我靠，这道题还卡了我挺久的，分享一下我的思考过程，前面的思路都不对，最后反而用最简单的方法很快解决了。相信大家（尤其是初学者）也会遇到我的这种情况，我觉得这是正常的，不必着急上火，不妨把思考尝试的过程也当成学习进步的一部分。

第一个尝试，我觉得这种题一般都用排除法，他问不包含重复的数字个数，我就要去算包含重复数字的个数，然后用总数去减。

我之所以这样想，是因为我想到「包含重复数字」这个性质是会传递的。比方说 `112` 这个数字包含重复数字，那么我往这个数字中任意位置插入新数字，新数字必然也是包含重复的。有了这个性质，我认为大概率可以找到一个递归公式，从小规模的问题推导到大规模的问题。

但事实证明，这样搞的话反而把问题复杂化了，因为越往深想，里面的细节问题越多，类似于包含重复元素的排列组合，要考虑到存在重复元素时组合不能重复。

我的第二个尝试，就是正着想，从一个不包含重复的 `n` 位数字，其实也可以推导出不包含重复的 `n + 1` 位数字。

比方说， `12` 可以衍生出 `312, 412, ..., 132, 142, ..., 123, 124...` 等不重复的元素个数。但这样也有重复的问题，比如说 `12` 可以衍生出 `312` ，但 `32` 也可以衍生出 `312` ，这样就重复了。

**绕来绕去，最后我发现根本不用想这么复杂，它就是一个简单的排列组合问题** 。

比方说，现在让我计算不包含重复数字的两位数，那么第一位有 1-9 共 9 种选择，第二位有 0-9 共 10 种选择但不能和第一位相同，所以有 9 种选择，总共就是 `9 * 9 = 81` 种。

再加上不包含重复的一位数，总共就是 `81 + 10 = 91` 种，这就是最终答案。

类似的，如果计算不包含重复数字的三位数，那么第一位有 1-9 共 9 种选择，第二位可以是 0-9 但要排除第一位，共有 9 种选择，第三位可以是 0-9 但要排除前两位，共有 8 种选择，总共就是 `9 * 9 * 8 = 648` 种。

再加上不包含重复的两位数，总共就是 `648 + 91 = 739` 种，这就是最终答案。

明白上述逻辑，直接翻译成代码就行了。因为代码比较简单，这道题我也不做可视化面板了，直接看代码吧。

#### 解法代码

#### 算法可视化

算法可视化

### 279\. 完全平方数

**279\. 完全平方数** | [力扣](https://leetcode.cn/problems/perfect-squares/) | [LeetCode](https://leetcode.com/problems/perfect-squares/)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如， `1` 、 `4` 、 `9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

- `1 <= n <= 10<sup>4</sup>`

题目来源： [力扣 279. 完全平方数](https://leetcode.cn/problems/perfect-squares/) 。

#### 基本思路

这道题有一些比较有技巧性的数学方法，我这里不探讨数学，就用通用的动态规划思路解决：

题目问和为 `n` 的平方数的最小数量，那么我可以根据和为 `n-1x1, n-2x2, n-3x3...` 的平方数的最小数量推导出来。

如果这个思路你绕不过来，我再给你变化下就更容易理解了，这个问题完全可以变化成 [动态规划详解](https://labuladong.online/zh/algo/essential-technique/dynamic-programming-framework/) 中讲的 [322\. 零钱兑换](https://leetcode.cn/problems/coin-change/description/) 问题：

给你一个目标金额 `n` ，和一个若干硬币的面额 `coins = 1,4,9,16...`，问你最少需要几枚硬币凑出这个金额（因为包含面值为 1 的硬币，所以不存在凑不出来的情况）。

这样变个说法理解题目，是不是就豁然开朗了？具体解法看代码吧，复杂度是 `O(N*sqrt(N))` ，也是不错的。

#### 解法代码

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表

暂无评论，来发表第一条评论吧