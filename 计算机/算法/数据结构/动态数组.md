# 动态数组

## 概述

动态数组是静态数组的**高级封装版本**，是我们在实际软件开发和算法实现中最常用的数据结构之一。

### 核心理念

**重要提醒**：不要误以为动态数组能够解决静态数组在中间增删元素效率低的问题。数组的随机访问超能力源于**连续内存空间**的特性，而正是这个特性导致了数据搬移和扩缩容的必然性，这是数组结构的本质特征，无法避免。

**动态数组的本质**：
- 底层依然是静态数组
- 自动处理内存的扩缩容管理
- 封装了丰富的增删查改API
- 让开发者使用起来更加便捷

### 主要优势

1. **自动内存管理**：无需手动计算和分配内存空间
2. **丰富的API**：提供插入、删除、查找等高级操作
3. **动态扩容**：根据数据量自动调整容量
4. **跨平台一致性**：各种编程语言都有类似的实现

## 各语言实现对比

### C++ - vector

```cpp
#include <vector>
#include <algorithm>

// 创建动态数组
vector<int> arr;

// 基本操作
for (int i = 0; i < 10; i++) {
    arr.push_back(i);           // 末尾追加，O(1)
}

arr.insert(arr.begin() + 2, 666);  // 中间插入，O(N)
arr.insert(arr.begin(), -1);       // 头部插入，O(N)

arr.pop_back();                     // 删除末尾，O(1)
arr.erase(arr.begin() + 2);         // 删除中间，O(N)

int val = arr[0];                   // 随机访问，O(1)
arr[0] = 100;                       // 修改元素，O(1)

// 查找元素索引，O(N)
auto it = find(arr.begin(), arr.end(), 666);
int index = (it != arr.end()) ? it - arr.begin() : -1;
```

### Java - ArrayList

```java
import java.util.ArrayList;

// 创建动态数组
ArrayList<Integer> arr = new ArrayList<>();

// 基本操作
for (int i = 0; i < 10; i++) {
    arr.add(i);                 // 末尾追加，O(1)
}

arr.add(2, 666);                // 中间插入，O(N)
arr.add(0, -1);                 // 头部插入，O(N)

arr.remove(arr.size() - 1);     // 删除末尾，O(1)
arr.remove(2);                  // 删除中间，O(N)

int val = arr.get(0);           // 随机访问，O(1)
arr.set(0, 100);                // 修改元素，O(1)

int index = arr.indexOf(666);   // 查找元素索引，O(N)
```

### Python - list

```python
# 创建动态数组
arr = []

# 基本操作
for i in range(10):
    arr.append(i)               # 末尾追加，O(1)

arr.insert(2, 666)              # 中间插入，O(N)
arr.insert(0, -1)               # 头部插入，O(N)

arr.pop()                       # 删除末尾，O(1)
arr.pop(2)                      # 删除中间，O(N)

val = arr[0]                    # 随机访问，O(1)
arr[0] = 100                    # 修改元素，O(1)

try:
    index = arr.index(666)      # 查找元素索引，O(N)
except ValueError:
    index = -1
```

### Go - slice

```go
// 创建动态数组
var arr []int

// 基本操作
for i := 0; i < 10; i++ {
    arr = append(arr, i)        // 末尾追加，O(1)
}

// 中间插入，O(N)
arr = append(arr[:2], append([]int{666}, arr[2:]...)...)

// 头部插入，O(N)
arr = append([]int{-1}, arr...)

// 删除末尾，O(1)
arr = arr[:len(arr)-1]

// 删除中间，O(N)
arr = append(arr[:2], arr[3:]...)

// 随机访问和修改，O(1)
val := arr[0]
arr[0] = 100

// 查找元素索引，O(N)
index := -1
for i, v := range arr {
    if v == 666 {
        index = i
        break
    }
}
```

### JavaScript - Array

```javascript
// 创建动态数组
let arr = [];

// 基本操作
for (let i = 0; i < 10; i++) {
    arr.push(i);                // 末尾追加，O(1)
}

arr.splice(2, 0, 666);          // 中间插入，O(N)
arr.unshift(-1);                // 头部插入，O(N)

arr.pop();                      // 删除末尾，O(1)
arr.splice(2, 1);               // 删除中间，O(N)

let val = arr[0];               // 随机访问，O(1)
arr[0] = 100;                   // 修改元素，O(1)

let index = arr.indexOf(666);   // 查找元素索引，O(N)
```

## 时间复杂度分析

动态数组的时间复杂度与静态数组基本一致：

| 操作类型 | 时间复杂度 | 说明 |
|----------|------------|------|
| **末尾追加** | **O(1)** | 均摊复杂度，偶尔扩容为O(N) |
| **中间插入** | **O(N)** | 需要移动后续元素 |
| **头部插入** | **O(N)** | 需要移动所有元素 |
| **末尾删除** | **O(1)** | 直接标记删除 |
| **中间删除** | **O(N)** | 需要移动后续元素 |
| **随机访问** | **O(1)** | 通过索引直接计算地址 |
| **修改元素** | **O(1)** | 通过索引直接修改 |
| **查找元素** | **O(N)** | 需要遍历数组 |

## 扩容机制

大多数动态数组实现都采用**倍增扩容**策略：
- 当容量不足时，创建一个**2倍大小**的新数组
- 将原数据复制到新数组中
- 释放原数组内存
- 这样可以保证插入操作的**均摊时间复杂度**为O(1)

## 应用场景

动态数组是最基础和通用的数据结构：

1. **算法竞赛**：几乎所有题目都会用到
2. **软件开发**：存储和操作变长数据集合
3. **其他数据结构的基础**：栈、队列、哈希表等都依赖动态数组实现

## 下一步学习

接下来我们将：
1. **手写实现**：基于静态数组实现完整的动态数组类
2. **深入原理**：理解扩容、缩容的具体实现细节
3. **性能优化**：学习各种优化技巧和最佳实践

掌握动态数组后，就为学习更复杂的数据结构打下了坚实基础。


