---
title: 动态数组代码实现
source: https://labuladong.online/zh/algo/data-structure-basic/array-implement/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-06
description: 本文将给出一个简化版的动态数组代码实现，包含增删查改、自动扩缩容等基本功能，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [数组（顺序存储）基础](https://labuladong.online/zh/algo/data-structure-basic/array-basic/)

## 几个关键点

下面我会直接给出一个简单的动态数组代码实现，包含了基本的增删查改功能。这里先给出几个关键点，等会你看代码的时候可以着重注意一下。

### 关键点一、自动扩缩容

在上一章 [数组基础](https://labuladong.online/zh/algo/data-structure-basic/array-basic/) 中只提到了数组添加元素时可能需要扩容，并没有提到缩容。

在实际使用动态数组时，缩容也是重要的优化手段。比方说一个动态数组开辟了能够存储 1000 个元素的连续内存空间，但是实际只存了 10 个元素，那就有 990 个空间是空闲的。为了避免资源浪费，我们其实可以适当缩小存储空间，这就是缩容。

我们这里就实现一个简单的扩缩容的策略：

- 当数组元素个数达到底层静态数组的容量上限时，扩容为原来的 2 倍；
- 当数组元素个数缩减到底层静态数组的容量的 1/4 时，缩容为原来的 1/2。

### 关键点二、索引越界的检查

下面的代码实现中，有两个检查越界的方法，分别是 `checkElementIndex` 和 `checkPositionIndex` ，你可以看到它俩的区别仅仅在于 `index < size` 和 `index <= size` 。

为什么 `checkPositionIndex` 可以允许 `index == size` 呢，因为这个 `checkPositionIndex` 是专门用来处理在数组中插入元素的情况。

比方说有这样一个 `nums` 数组，对于每个元素来说，合法的索引一定是 `index < size` ：

```
nums = [5, 6, 7, 8]

index   0  1  2  3
```

但如果是要在数组中插入新元素，那么新元素可能的插入位置并不是元素的索引，而是索引之间的空隙：

```
nums = [ | 5 | 6 | 7 | 8 | ]

index    0   1   2   3   4
```

这些空隙都是合法的插入位置，所以说 `index == size` 也是合法的。这就是 `checkPositionIndex` 和 `checkElementIndex` 的区别。

### 关键点三、删除元素谨防内存泄漏

单从算法的角度，其实并不需要关心被删掉的元素应该如何处理，但是具体到代码实现，我们需要注意可能出现的内存泄漏。

在我给出的代码实现中，删除元素时，我都会把被删除的元素置为 `null` ，以 Java 为例：

```
// 删

public E removeLast() {

    E deletedVal = data[size - 1];

    // 删除最后一个元素

    // 必须给最后一个元素置为 null，否则会内存泄漏

    data[size - 1] = null;

    size--;

    return deletedVal;

}
```

Java 的垃圾回收机制是基于 [图算法](https://labuladong.online/zh/algo/data-structure-basic/graph-basic/) 的可达性分析，如果一个对象再也无法被访问到，那么这个对象占用的内存才会被释放；否则，垃圾回收器会认为这个对象还在使用中，就不会释放这个对象占用的内存。

如果你不执行 `data[size - 1] = null` 这行代码，那么 `data[size - 1]` 这个引用就会一直存在，你可以通过 `data[size - 1]` 访问这个对象，所以这个对象被认为是可达的，它的内存就一直不会被释放，进而造成内存泄漏。

其他带垃圾回收功能的语言应该也是类似的，你可以具体了解一下你使用的编程语言的垃圾回收机制，这是写出无 bug 代码的基本要求。

### 其他细节优化

下面的代码当然不会是一个很完善的实现，会有不少可以进一步优化的点。比方说，我是用 for 循环复制数组数据的，实际上这种方式复制的效率比较差，大部分编程语言会提供更高效的数组复制方法，比如 Java 的 `System.arraycopy` 。

不过它再怎么优化，本质上也是要搬移数据，时间复杂度都是 $O(n)$ 。本文的重点在于让你理解数组增删查改 API 的基本实现思路以及时间复杂度，如果对这些细节感兴趣，可以找到编程语言标准库的源码深入研究。

如何验证你的实现？

你可以借助力扣第 707 题「 [设计链表](https://leetcode.cn/problems/design-linked-list/) 」来验证自己的实现是否正确。虽然这道题是关于链表的，但是它其实也不知道你底层到底是不是用链表实现的。咱主要是借用它的测试用例，来验证你的增删查改功能是否正确。

## 动态数组代码实现

```
#include <iostream>

#include <stdexcept>

#include <vector>

template<typename E>

class MyArrayList {

private:

    // 真正存储数据的底层数组

    E* data;

    // 记录当前元素个数

    int size;

    // 最大元素容量

    int cap;

    // 默认初始容量

    static const int INIT_CAP = 1;

public:

    MyArrayList() {

        this->data = new E[INIT_CAP];

        this->size = 0;

        this->cap = INIT_CAP;

    }

    MyArrayList(int initCapacity) {

        this->data = new E[initCapacity];

        this->size = 0;

        this->cap = initCapacity;

    }

    // 增

    void addLast(E e) {

        // 看 data 数组容量够不够

        if (size == cap) {

            resize(2 * cap);

        }

        // 在尾部插入元素

        data[size] = e;

        size++;

    }

    void add(int index, E e) {

        // 检查索引越界

        checkPositionIndex(index);

        // 看 data 数组容量够不够

        if (size == cap) {

            resize(2 * cap);

        }

        // 搬移数据 data[index..] -> data[index+1..]

        // 给新元素腾出位置

        for (int i = size - 1; i >= index; i--) {

            data[i + 1] = data[i];

        }

        // 插入新元素

        data[index] = e;

        size++;

    }

    void addFirst(E e) {

        add(0, e);

    }

    // 删

    E removeLast() {

        if (size == 0) {

            throw std::out_of_range("NoSuchElementException");

        }

        // 可以缩容，节约空间

        if (size == cap / 4) {

            resize(cap / 2);

        }

        E deletedVal = data[size - 1];

        // 删除最后一个元素

        // 必须给最后一个元素置为 null，否则会内存泄漏

        data[size - 1] = E();

        size--;

        return deletedVal;

    }

    E remove(int index) {

        // 检查索引越界

        checkElementIndex(index);

        // 可以缩容，节约空间

        if (size == cap / 4) {

            resize(cap / 2);

        }

        E deletedVal = data[index];

        // 搬移数据 data[index+1..] -> data[index..]

        for (int i = index + 1; i < size; i++) {

            data[i - 1] = data[i];

        }

        data[size - 1] = E();

        size--;

        return deletedVal;

    }

    E removeFirst() {

        return remove(0);

    }

    // 查

    E get(int index) {

        // 检查索引越界

        checkElementIndex(index);

        return data[index];

    }

    // 改

    E set(int index, E element) {

        // 检查索引越界

        checkElementIndex(index);

        // 修改数据

        E oldVal = data[index];

        data[index] = element;

        return oldVal;

    }

    // 工具方法

    int getSize() {

        return size;

    }

    bool isEmpty() {

        return size == 0;

    }

    // 将 data 的容量改为 newCap

    void resize(int newCap) {

        E* temp = new E[newCap];

        for (int i = 0; i < size; i++) {

            temp[i] = data[i];

        }

        // 释放原数组内存

        delete[] data;

        data = temp;

        cap = newCap;

    }

    bool isElementIndex(int index) {

        return index >= 0 && index < size;

    }

    bool isPositionIndex(int index) {

        return index >= 0 && index <= size;

    }

    // 检查 index 索引位置是否可以存在元素

    void checkElementIndex(int index) {

        if (!isElementIndex(index)) {

            throw std::out_of_range("Index out of bounds");

        }

    }

    // 检查 index 索引位置是否可以添加元素

    void checkPositionIndex(int index) {

        if (!isPositionIndex(index)) {

            throw std::out_of_range("Index out of bounds");

        }

    }

    void display() {

        std::cout << "size = " << size << " cap = " << cap << std::endl;

        for (int i = 0; i < size; i++) {

            std::cout << data[i] << " ";

        }

        std::cout << std::endl;

    }

    ~MyArrayList() {

        delete[] data;

    }

};

int main() {

    // 初始容量设置为 3

    MyArrayList<int> arr(3);

    // 添加 5 个元素

    for (int i = 1; i <= 5; i++) {

        arr.addLast(i);

    }

    arr.remove(3);

    arr.add(1, 9);

    arr.addFirst(100);

    int val = arr.removeLast();

    // 100 1 9 2 3

    for (int i = 0; i < arr.getSize(); i++) {

        std::cout << arr.get(i) << std::endl;

    }

    return 0;

}
```

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表