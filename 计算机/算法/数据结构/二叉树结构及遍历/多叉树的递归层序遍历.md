---
title: "多叉树的递归/层序遍历"
source: "https://labuladong.online/zh/algo/data-structure-basic/n-ary-tree-traverse-basic/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-06
description: "本文介绍多叉树的定义和遍历方式，多叉树的遍历就是二叉树遍历的延伸，有递归遍历（DFS）和层序遍历（BFS）两种，其中层序遍历也有 3 种写法。"
tags:
  - "clippings"
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [589\. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/) | [589\. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/) |  |
| [590\. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/) | [590\. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/) |  |
| [429\. N-ary Tree Level Order Traversal](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) | [429\. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/) |  |

前置知识

阅读本文前，你需要先学习：

- [二叉树的递归/层序遍历](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-traverse-basic/)

一句话总结

多叉树结构就是 [二叉树结构](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-basic/) 的延伸，二叉树是特殊的多叉树。

多叉树的遍历就是 [二叉树遍历](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-traverse-basic/) 的延伸。

森林是指多个多叉树的集合，单独一棵多叉树是一个特殊的森林。

二叉树的节点长这样，每个节点有两个子节点：

```
class TreeNode {

public:

    int val;

    TreeNode* left;

    TreeNode* right;

    TreeNode(int v) : val(v), left(nullptr), right(nullptr) {}

};
```

多叉树的节点长这样，每个节点有任意个子节点：

```
class Node {

public:

    int val;

    vector<Node*> children;

};
```

就这点区别，其他没了。

## 森林

这里介绍一下「森林」这个名词，后面讲到 [Union Find 并查集算法](https://labuladong.online/zh/algo/data-structure-basic/union-find-basic/) 时，会用到这个概念。

顾名思义， **森林就是多个多叉树的集合（单独一棵多叉树也是一个特殊的森林）** ，用代码表示就是多个多叉树的根节点列表，类似这样：

```
List<Node> forest;
```

只需对每个根节点分别进行 DFS/BFS 遍历，即可遍历森林的所有节点。

在并查集算法中，我们会同时持有多棵多叉树的根节点，那么这些根节点的集合就是一个森林。

接下来说下多叉树的遍历，和二叉树一样，也就递归遍历（DFS）和层序遍历（BFS）两种。

## 递归遍历（DFS）

对比二叉树的遍历框架看多叉树的遍历框架吧：

```
// 二叉树的遍历框架

void traverse(TreeNode* root) {

    if (root == nullptr) {

        return;

    }

    // 前序位置

    traverse(root->left);

    // 中序位置

    traverse(root->right);

    // 后序位置

}

// N 叉树的遍历框架

void traverse(Node* root) {

    if (root == nullptr) {

        return;

    }

    // 前序位置

    for (Node* child : root->children) {

        traverse(child);

    }

    // 后序位置

}
```

唯一的区别是，多叉树没有了中序位置，因为可能有多个节点嘛，所谓的中序位置也就没什么意义了。

可以看看下面这个可视化面板，多次点击其中 `if (root === null)` 这行代码，遍历顺序和二叉树是类似的：

多叉树的 DFS 遍历

## 层序遍历（BFS）

多叉树的层序遍历和 [二叉树的层序遍历](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-traverse-basic/) 一样，都是用队列来实现，无非就是把二叉树的左右子节点换成了多叉树的所有子节点。所以多叉树的层序遍历也有三种写法，下面一一列举。

### 写法一

第一种层序遍历写法，无法记录节点深度：

```
void levelOrderTraverse(Node* root) {

    if (root == nullptr) {

        return;

    }

    std::queue<Node*> q;

    q.push(root);

    while (!q.empty()) {

        Node* cur = q.front();

        q.pop();

        // 访问 cur 节点

        std::cout << cur->val << std::endl;

        // 把 cur 的所有子节点加入队列

        for (Node* child : cur->children) {

            q.push(child);

        }

    }

}
```

你可以多次点击可视化面板中的 `console.log` 这行代码，看到层序遍历的执行过程：

算法可视化

### 写法二

第二种层序遍历写法，能够记录节点深度：

```
#include <iostream>

#include <queue>

#include <vector>

void levelOrderTraverse(Node* root) {

    if (root == nullptr) {

        return;

    }

    std::queue<Node*> q;

    q.push(root);

    // 记录当前遍历到的层数（根节点视为第 1 层）

    int depth = 1;

    while (!q.empty()) {

        int sz = q.size();

        for (int i = 0; i < sz; i++) {

            Node* cur = q.front();

            q.pop();

            // 访问 cur 节点，同时知道它所在的层数

            std::cout << "depth = " << depth << ", val = " << cur->val << std::endl;

            for (Node* child : cur->children) {

                q.push(child);

            }

        }

        depth++;

    }

}
```

你可以多次点击可视化面板中的 `console.log` 这行代码，看到层序遍历的执行过程：

算法可视化

### 写法三

第三种能够适配不同权重边的写法：

```
// 多叉树的层序遍历

// 每个节点自行维护 State 类，记录深度等信息

class State {

public:

    Node* node;

    int depth;

    State(Node* node, int depth) : node(node), depth(depth) {}

};

void levelOrderTraverse(Node* root) {

    if (root == nullptr) {

        return;

    }

    std::queue<State> q;

    // 记录当前遍历到的层数（根节点视为第 1 层）

    q.push(State(root, 1));

    while (!q.empty()) {

        State state = q.front();

        q.pop();

        Node* cur = state.node;

        int depth = state.depth;

        // 访问 cur 节点，同时知道它所在的层数

        std::cout << "depth = " << depth << ", val = " << cur->val << std::endl;

        for (Node* child : cur->children) {

            q.push(State(child, depth + 1));

        }

    }

}
```

你可以多次点击可视化面板中的 `console.log` 这行代码，看到层序遍历的执行过程：

算法可视化

没啥好说的，有不明白的可以对照前文 [二叉树遍历](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-traverse-basic/) 的层序遍历代码和可视化面板。

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表