---
title: 线性探查法的两种代码实现
source: https://labuladong.online/zh/algo/data-structure-basic/linear-probing-code/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-06
description: 线性探查法/开放寻址法是解决哈希冲突的一种方法，本文对线性探查法进行算法可视化，展示增删查改的过程，并提供完整的 Java/C++/Python/Golang/JavaScript 代码实现。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [线性探查法的两个难点](https://labuladong.online/zh/algo/data-structure-basic/linear-probing-key-point/)

前文 [哈希表核心原理](https://labuladong.online/zh/algo/data-structure-basic/hashmap-basic/) 中我介绍了哈希表的核心原理和几个关键概念， [拉链法原理和实现](https://labuladong.online/zh/algo/data-structure-basic/hashtable-chaining/) 中介绍了拉链法的实现， [线性探查法的两个难点](https://labuladong.online/zh/algo/data-structure-basic/linear-probing-key-point/) 介绍了线性探查法实现哈希表的难点所在，并给出了两种方法解决删除元素时的空洞问题，本文会同时给出这两种方法的参考代码实现。

本文会先结合可视化面板给出简化的实现，方便大家理解增删查改的过程，最后给完整实现。

简化实现中，具体简化的地方如下：

1、我们实现的哈希表只支持 `key` 类型为 `int` ， `value` 类型为 `int` 的情况，如果 `key` 不存在，就返回 `-1` 。

2、我们实现的 `hash` 函数就是简单地取模，即 `hash(key) = key % table.length` 。这样也方便模拟出哈希冲突的情况，比如当 `table.length = 10` 时， `hash(1)` 和 `hash(11)` 的值都是 1。

3、底层的 `table` 数组的大小在创建哈希表时就固定，假设 `table` 数组不会被装满，不考虑负载因子和动态扩缩容的问题。

这些简化能够帮助我们聚焦增删查改的核心逻辑，并且可以借助 [可视化面板](https://labuladong.online/zh/algo/intro/visualize/) 辅助大家学习理解。

## 简化版代码

### 搬移数据的线性探查法

这种方法在 `remove` 操作时，会将删除的元素后面的元素重新插入哈希表，以此保持元素的连续性。

这里直接给出简化版的代码实现，你可以先看看，后面将通过可视化面板展示增删查改的过程：

```
#include <iostream>

#include <vector>

using namespace std;

// 用线性探查法解决哈希冲突的简化实现（rehash 版）

class Node {

    public:

        int key;

        int val;

        Node(int key, int val) {

            this->key = key;

            this->val = val;

        }

};

class ExampleLinearProbingHashMap1 {

    private:

        // 哈希表的底层数组，每个索引存储一个键值对

        vector<Node*> table;

    public:

        ExampleLinearProbingHashMap1(int cap) {

            this->table.resize(cap);

        }

        ~ExampleLinearProbingHashMap1() {

            for (Node* node : table) {

                if (node != NULL) {

                    delete node;

                }

            }

        }

        // 增/改

        void put(int key, int value) {

            int index = findKeyIndex(key);

            table[index] = new Node(key, value);

        }

        // 查，找不到就返回 -1

        int get(int key) {

            int index = findKeyIndex(key);

            return table[index] == NULL ? -1 : table[index]->val;

        }

        // 删

        void remove(int key) {

            int index = findKeyIndex(key);

            if (table[index] == NULL) {

                return;

            }

            table[index] = NULL;

            // 保持元素连续性，搬移数据（这个过程称为 rehash）

            index = (index + 1) % table.size();

            while (table[index] != NULL) {

                Node* entry = table[index];

                table[index] = NULL;

                // 这个操作是关键，利用 put 方法，将键值对重新插入

                // 这样就能把它们移动到正确的 table 索引位置

                put(entry->key, entry->val);

                index = (index + 1) % table.size();

            }

        }

        // 线性探测法查找 key 在 table 中的索引

        // 如果找不到，返回的就是下一个为 null 的索引，可用于插入

        int findKeyIndex(int key) {

            int index = hash(key);

            while (table[index] != NULL) {

                if (table[index]->key == key) {

                    return index;

                }

                // 注意环形数组特性

                index = (index + 1) % table.size();

            }

            return index;

        }

        int hash(int key) {

            return key % table.size();

        }

};

int main() {

    ExampleLinearProbingHashMap1 map(10);

    map.put(1, 1);

    map.put(2, 2);

    map.put(10, 10);

    map.put(20, 20);

    map.put(30, 30);

    map.put(3, 3);

    cout << map.get(1) << endl;

    cout << map.get(2) << endl;

    cout << map.get(20) << endl;

    map.put(1, 100);

    cout << map.get(1) << endl;

    map.remove(20);

    cout << map.get(20) << endl;

    cout << map.get(30) << endl;

    return 0;

}
```

线性探查法简版哈希表（rehash 版）

### 特殊占位符的线性探查法

这种方法通过一个 `DELETED` 特殊值作为占位符，标记被删除的元素。

这个方法与上面的方法最大的区别在于 `findKeyIndex` 方法的实现，同时需要对 `DELETED` 特殊处理。直接看代码吧，后面会通过可视化面板展示增删查改的过程：

```
#include <iostream>

#include <vector>

// 用线性探查法解决哈希冲突的简化实现（特殊占位符版）

// Special placeholder for deleted elements. 

// 用于标记被删元素的占位符

struct KVNode {

    int key;

    int val;

};

class ExampleLinearProbingHashMap2 {

private:

    // 真正存储键值对的数组

    std::vector<KVNode*> table;

    // 里面的值可以随意存储，因为只会使用 == 判断指针相等，不用比较里面的值

    KVNode* DELETED = new KVNode{-2, -2};

    

    // 哈希函数，将键映射到 table 的索引

    int hash(int key) {

        return key % table.size();

    }

    // 线性探测法查找 key 在 table 中的索引，如果找不到，返回 -1

    int findKeyIndex(int key) {

        // 因为删除元素时只是标记为 DELETED，并不是真的删除，所以 table 可能会被填满，导致死循环

        // step 用来记录查找的步数，防止死循环

        for (int i = hash(key), step = 0; table[i] != nullptr; i = (i+1) % table.size()) {

            if (++step > table.size()) return -1;

            // 遇到占位符直接跳过

            if (table[i] == DELETED) continue;

            if (table[i]->key == key) return i;

        }

        return -1;

    }

public:

    // 构造函数，初始化哈希表容量

    explicit ExampleLinearProbingHashMap2(int initCapacity) {

        table.resize(initCapacity, nullptr);

    }

    // 增/改

    void put(int key, int val) {

        int index = findKeyIndex(key);

        // key 已存在，修改对应的 val，如果 key 不存在，新建节点并插入表中

        if (index != -1 && table[index] != nullptr) {

            table[index]->val = val;

            return;

        }

        KVNode* node = new KVNode{key, val};

        index = hash(key);

        while (table[index] != nullptr && table[index] != DELETED) {

            index = (index+1) % table.size();

        }

        table[index] = node;

    }

    // 删

    void remove(int key) {

        int index = findKeyIndex(key);

        // key 不存在，不需要 remove

        if (index == -1) return;

        // 直接用占位符表示删除

        table[index] = DELETED;

    }

    // 查，返回 key 对应的 val，如果 key 不存在，则返回 -1

    int get(int key) {

        int index = findKeyIndex(key);

        return (index != -1) ? table[index]->val : -1;

    }

};

int main() {

    ExampleLinearProbingHashMap2 map(10);

    map.put(1, 1);

    map.put(2, 2);

    map.put(10, 10);

    map.put(20, 20);

    map.put(30, 30);

    map.put(3, 3);

    std::cout << map.get(1) << std::endl;  // Output: 1

    std::cout << map.get(2) << std::endl;  // Output: 2

    std::cout << map.get(20) << std::endl; // Output: 20

    map.put(1, 100);

    std::cout << map.get(1) << std::endl;  // Output: 100

    map.remove(20);

    std::cout << map.get(20) << std::endl; // Output: -1

    std::cout << map.get(30) << std::endl; // Output: 30

    return 0;

}
```

线性探查法简版哈希表（占位符版）

## 完整版代码

有了上面的铺垫，我们现在来看比较完善的 Java 代码实现，主要新增了以下几个功能：

1、使用了泛型，可以存储任意类型的 `key` 和 `value` 。

2、底层的 `table` 数组会根据负载因子动态扩缩容。

3、使用了 [哈希表基础](https://labuladong.online/zh/algo/data-structure-basic/hashmap-basic/) 中提到的 `hash` 函数，利用 `key` 的 `hashCode()` 方法和 `table.length` 来计算哈希值。

4、实现了 `keys()` 方法，可以返回哈希表中所有的 `key` 。

下面我会分别给出 rehash 版本和特殊值标记版本的实现，具体细节可以参考代码注释。

### rehash 版本

```
#include <iostream>

#include <vector>

#include <list>

#include <stdexcept>

template<typename K, typename V>

class MyLinearProbingHashMap1 {

private:

    struct KVNode {

        K key;

        V val;

        KVNode(K key, V val) : key(key), val(val) {

        }

    };

    std::vector<KVNode *> table;

    int size_;

    static const int INIT_CAP = 4;

public:

    MyLinearProbingHashMap1() : MyLinearProbingHashMap1(INIT_CAP) {

    }

    MyLinearProbingHashMap1(int initCapacity) : size_(0) {

        table.resize(initCapacity, nullptr);

    }

    // **** 增/改 ****

    void put(K key, V val) {

        // 我们把负载因子默认设为 0.75，超过则扩容

        if (size_ >= table.size() * 0.75) {

            resize(table.size() * 2);

        }

        int index = getKeyIndex(key);

        // key 已存在，修改对应的 val

        if (table[index] != nullptr) {

            table[index]->val = val;

            return;

        }

        // key 不存在，在空位插入

        table[index] = new KVNode(key, val);

        size_++;

    }

    // **** 删 ****

    // 删除 key 和对应的 val

    void remove(K key) {

        // 缩容，当负载因子小于 0.125 时，缩容

        if (size_ <= table.size() / 8) {

            resize(table.size() / 4);

        }

        int index = getKeyIndex(key);

        if (table[index] == nullptr) {

            // key 不存在，不需要 remove

            return;

        }

        // 开始 remove

        delete table[index];

        table[index] = nullptr;

        size_--;

        // 保持元素连续性，进行 rehash

        index = (index + 1) % table.size();

        while (table[index] != nullptr) {

            KVNode *entry = table[index];

            table[index] = nullptr;

            size_--;

            put(entry->key, entry->val);

            delete entry;

            index = (index + 1) % table.size();

        }

    }

    // **** 查 ****

    // 返回 key 对应的 val，如果 key 不存在，则返回 null

    V get(K key) {

        int index = getKeyIndex(key);

        if (table[index] == nullptr) {

            return V(); // 返回默认值

        }

        return table[index]->val;

    }

    // 返回所有 key（顺序不固定）

    std::list<K> keys() {

        std::list<K> keys;

        for (KVNode *entry: table) {

            if (entry != nullptr) {

                keys.push_back(entry->key);

            }

        }

        return keys;

    }

    // **** 其他工具函数 ****

    int size() const {

        return size_;

    }

private:

    // 哈希函数，将键映射到 table 的索引

    int hash(K key) {

        return (std::hash<K>()(key) & 0x7fffffff) % table.size();

    }

    // 对 key 进行线性探查，返回一个索引

    int getKeyIndex(K key) {

        int index;

        for (index = hash(key); table[index] != nullptr; index = (index + 1) % table.size()) {

            if (table[index]->key == key) {

                return index;

            }

        }

        return index;

    }

    void resize(int newCap) {

        MyLinearProbingHashMap1<K, V> newMap(newCap);

        for (KVNode *entry: table) {

            if (entry != nullptr) {

                newMap.put(entry->key, entry->val);

            }

        }

        table = std::move(newMap.table);

    }

};

int main() {

    MyLinearProbingHashMap1<int, int> map;

    map.put(1, 1);

    map.put(2, 2);

    map.put(10, 10);

    map.put(20, 20);

    map.put(30, 30);

    map.put(3, 3);

    std::cout << map.get(1) << std::endl; // 1

    std::cout << map.get(2) << std::endl; // 2

    std::cout << map.get(20) << std::endl; // 20

    map.put(1, 100);

    std::cout << map.get(1) << std::endl; // 100

    map.remove(20);

    std::cout << map.get(20) << std::endl; // 0 (null)

    std::cout << map.get(30) << std::endl; // 30

    return 0;

}
```

### 特殊值标记版本

```
#include <iostream>

#include <vector>

#include <list>

#include <stdexcept>

template<typename K, typename V>

class MyLinearProbingHashMap2 {

    // 键值对节点

    struct KVNode {

        K key;

        V val;

        KVNode(K key, V val) : key(key), val(val) {

        }

    };

    // 被删除的 KVNode 的占位符

    KVNode *DUMMY = new KVNode(K(), V());

    // 真正存储键值对的 table 数组

    std::vector<KVNode *> table;

    // HashMap 中的键值对个数

    int size;

    // 默认的初始化容量

    static const int INIT_CAP = 4;

public:

    MyLinearProbingHashMap2() : MyLinearProbingHashMap2(INIT_CAP) {

    }

    MyLinearProbingHashMap2(int cap) : size(0), table(cap, nullptr) {

    }

    // **** 增/改 ****

    // 添加 key -> val 键值对

    // 如果键 key 已存在，则将值修改为 val

    void put(K key, V val) {

        if (key == K()) {

            throw std::invalid_argument("key is null");

        }

        // 负载因子默认设为 0.75，超过则扩容

        if (size >= table.size() * 0.75) {

            resize(table.size() * 2);

        }

        int index = getKeyIndex(key);

        if (index != -1) {

            // key 已存在，修改对应的 val

            table[index]->val = val;

            return;

        }

        // key 不存在

        KVNode *x = new KVNode(key, val);

        // 在 table 中找一个空位或者占位符，插入

        index = hash(key);

        while (table[index] != nullptr && table[index] != DUMMY) {

            index = (index + 1) % table.size();

        }

        table[index] = x;

        size++;

    }

    // **** 删 ****

    // 删除 key 和对应的 val，并返回 val

    // 若 key 不存在，则返回 null

    void remove(K key) {

        if (key == K()) {

            throw std::invalid_argument("key is null");

        }

        // 缩容

        if (size < table.size() / 8) {

            resize(table.size() / 2);

        }

        int index = getKeyIndex(key);

        if (index == -1) {

            // key 不存在，不需要 remove

            return;

        }

        // 开始 remove

        // 直接用占位符表示删除

        table[index] = DUMMY;

        size--;

    }

    // **** 查 ****

    // 返回 key 对应的 val

    // 如果 key 不存在，则返回 null

    V get(K key) {

        if (key == K()) {

            throw std::invalid_argument("key is null");

        }

        int index = getKeyIndex(key);

        if (index == -1) {

            return V();

        }

        return table[index]->val;

    }

    bool containsKey(K key) {

        return getKeyIndex(key) != -1;

    }

    std::list<K> keys() {

        std::list<K> keys;

        for (auto entry: table) {

            if (entry != nullptr && entry != DUMMY) {

                keys.push_back(entry->key);

            }

        }

        return keys;

    }

    int getSize() {

        return size;

    }

private:

    // 对 key 进行线性探查，返回一个索引

    // 根据 keys[i] 是否为 null 判断是否找到对应的 key

    int getKeyIndex(K key) {

        int step = 0;

        for (int i = hash(key); table[i] != nullptr; i = (i + 1) % table.size()) {

            step++;

            // 防止死循环

            if (step > table.size()) {

                // 这里可以触发一次 resize，把标记为删除的占位符清理掉

                resize(table.size());

                return -1;

            }

            KVNode *entry = table[i];

            // 遇到占位符直接跳过

            if (entry == DUMMY) {

                continue;

            }

            if (entry->key == key) {

                return i;

            }

        }

        return -1;

    }

    // 哈希函数，将键映射到 table 的索引

    // [0, table.length - 1]

    int hash(K key) {

        return (std::hash<K>{}(key) & 0x7fffffff) % table.size();

    }

    void resize(int cap) {

        MyLinearProbingHashMap2<K, V> newMap(cap);

        for (auto entry: table) {

            if (entry != nullptr && entry != DUMMY) {

                newMap.put(entry->key, entry->val);

            }

        }

        this->table = newMap.table;

    }

};

int main() {

    MyLinearProbingHashMap2<int, int> map;

    map.put(1, 1);

    map.put(2, 2);

    map.put(10, 10);

    map.put(20, 20);

    map.put(30, 30);

    map.put(3, 3);

    std::cout << map.get(1) << std::endl; // 1

    std::cout << map.get(2) << std::endl; // 2

    std::cout << map.get(20) << std::endl; // 20

    map.put(1, 100);

    std::cout << map.get(1) << std::endl; // 100

    map.remove(20);

    

    std::cout << map.containsKey(20) << std::endl; // 0 (false)

    std::cout << map.get(20) << std::endl; // 0 (null)

    std::cout << map.get(30) << std::endl; // 30

}
```

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表