---
title: "Union Find 并查集原理"
source: "https://labuladong.online/zh/algo/data-structure-basic/union-find-basic/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-06
description: "本文介绍静态数组、动态数组这类顺序存储结构。本文会探讨：什么数组的索引从 0 开始？为什么数组能实现随机访问？为何数组的插入和删除操作效率低？"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [二叉树基础及常见类型](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-basic/)
- [图结构基础及通用代码实现](https://labuladong.online/zh/algo/data-structure-basic/graph-basic/)

一句话总结

并查集（Union Find）结构是 [二叉树结构](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-basic/) 的衍生，用于高效解决 **无向图的连通性问题** ，可以在 $O(1)$ 时间内合并两个连通分量，在 $O(1)$ 时间内查询两个节点是否连通，在 $O(1)$ 时间内查询连通分量的数量。

并查集算法有几种优化方法，可视化面板都做了支持。下面展示一个未经优化的并查集实现，最终多叉树几乎退化成单链表，导致算法效率降低。对于这个问题的优化思路和可视化展示，在下文中会详细介绍。

算法可视化

本文将介绍什么是图的动态连通性问题，以及为什么并查集（Union Find）算法能够高效解决动态连通性问题。

本文会结合 [可视化面板](https://labuladong.online/zh/algo/intro/visualize/) 直观展示 Union Find 算法的核心原理，以及几种优化思路的效果。

考虑到这是基础章节，本文不涉及算法代码的实现细节。具体的代码实现和算法题的运用放在后面的 [Union Find 算法实现及应用](https://labuladong.online/zh/algo/data-structure/union-find/) 和 [并查集经典习题](https://labuladong.online/zh/algo/problem-set/union-find/) 章节中，建议初学者按照目录顺序循序渐进地学习。

## 动态连通性及术语

图论算法中专业术语比较多，我就用一个简单的例子来介绍几个专业术语。

比如下面这个例子，其中有 10 个节点，分别用 0~9 标记，虽然其中没有边，但它依然是一个图结构：

![](https://labuladong.online/images/algo/unionfind/1.jpg)

我们可以说这个图结构中，有 10 个「 **连通分量** 」，每个节点自身都是一个连通分量，因为它们自成一派，没有和其他节点相连。

现在将其中的一些节点进行「 **连接操作** 」，比如连接节点 `0,1` 和 `1,2` ：

![](https://labuladong.online/images/algo/unionfind/2.jpg)

此时，图结构中的节点 `0,1,2` 之间就连通了，它们三个节点共同构成了一个连通分量，我们可以说这三个节点是「 **连通** 」的。

同时，这个图结构中的连通分量的数量从 10 减少到了 8，因为连接操作将 `0,1,2` 三个连通分量合并成了一个。

连通关系的性质

1、自反性：节点 `p` 和 `p` 自身是连通的。

2、对称性：如果节点 `p` 和 `q` 连通，那么 `q` 和 `p` 也连通。

3、传递性：如果节点 `p` 和 `q` 连通， `q` 和 `r` 连通，那么 `p` 和 `r` 也连通。

判断这种「等价关系」非常实用，比如说编译器判断同一个内存对象的不同变量引用，比如社交网络中的朋友圈计算等等。

那么动态连通性问题就是说，给你输入一个图结构，然后进行若干次「连接操作」，同时可能会查询任意两个节点是否「连通」，或者查询当前图中有多少个「连通分量」。

我们的目标是设计一种数据结构，在尽可能小的时间复杂度下完成连接操作和查询操作。

## 为什么需要并查集算法

并查集（Union Find）结构提供如下 API：

```
class UF {

    // 初始化并查集，包含 n 个节点，时间复杂度 O(n)

    public UF(int n);

    // 连接节点 p 和节点 q，时间复杂度 O(1)

    public void union(int p, int q);

    // 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内），时间复杂度 O(1)

    public boolean connected(int p, int q);

    // 查询当前的连通分量数量，时间复杂度 O(1)

    public int count();

}
```

其中 `union` 方法用于连接两个节点， `connected` 方法用于查询两个节点是否连通， `count` 方法用于查询当前图中的连通分量数量。它们都可以在 $O(1)$ 时间内完成。

$O(1)$ 的时间复杂度是最牛逼的， **假设你没学过并查集算法，你应该如何实现上述几个方法呢** ？

也不是完全没办法，比如 [图结构基础及通用代码实现](https://labuladong.online/zh/algo/data-structure-basic/graph-basic/) 中已经介绍了图结构邻接表/邻接矩阵的代码实现，这个 `union` 方法其实就是在图中添加一条无向边，时间复杂度可以做到 $O(1)$ 。

这个 `connected` 方法怎么实现呢？你是不是想说，去查一下邻接表/邻接矩阵，看看这两个节点是否相连就行了？

不对，别忘了上面讲的「连通」的性质，其中有有一条是「传递性」：如果节点 `p` 和 `q` 连通， `q` 和 `r` 连通，那么 `p` 和 `r` 也连通。

你单纯去查邻接表/邻接矩阵，只能判断两个节点是否 **直接相连** ，而无法处理这种传递的连通关系。

所以，要想实现 `connected(a, b)` ，我们只能使用 [图结构的 DFS/BFS 遍历算法](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) ，从 `a` 节点开始遍历所有可达的节点，看看 `b` 节点是否在其中，才能判断 `a,b` 两个节点是否连通。

这样的话， `connected` 方法的最坏时间复杂度就是图遍历的复杂度 $O(V+E)$ ，其中 $V$ 是节点数量， $E$ 是边数量。

接下来， `count` 方法如何实现呢？

还得依赖 [图结构的 DFS/BFS 遍历算法](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) ，但是更麻烦。

你得用 BFS/DFS 遍历整幅图，将所有节点分类到不同的连通分量中，最后统计连通分量的数量。这个过程的时间复杂度是 $O(V+E)$ 。

**所以说并查集算法非常巧妙，它不仅可以在 $O(1)$ 时间内完成上述操作，而且它根本不需要真的用邻接表/邻接矩阵构造图结构，只需要一个数组就可以了** 。

下面具体介绍。

## 并查集的核心原理

并查集本质上还是树结构的延伸。

你想想，对于一棵树，其中的所有节点，是不是都只有同一个根节点？

**如果我们想办法把同一个连通分量的节点都放到同一棵树中，把这棵树的根节点作为这个连通分量的代表，那么我们就可以高效实现上面的操作了** 。

并查集底层其实是一片森林（若干棵多叉树），每棵树代表一个连通分量：

- `connected(p, q)` ：只需要判断 `p` 和 `q` 所在的多叉树的根节点，若相同，则 `p` 和 `q` 在同一棵树中，即连通，否则不连通。
- `count()` ：只需要统计一下总共有多少棵树，即可得到连通分量的数量。
- `union(p, q)` ：只需要将 `p` 节点所在的这棵树的根节点，接入到 `q` 节点所在的这棵树的根节点下面，即可完成连接操作。注意这里并不是 `p, q` 两个节点的合并，而是两棵树根节点的合并。因为 `p, q` 一旦连通，那么他们所属的连通分量就合并成了同一个更大的连通分量。

综上，并查集中每个节点其实不在乎自己的子节点是谁，只在乎自己的根节点是谁，所以一个并查集节点类似于下面这样：

```
class UFNode {

    // 节点 id 编号

    int id;

    // 指向父节点的指针

    // 根节点的 parent 指针为空

    UFNode parent;

}
```

这样，对于任意一个节点，我们都可以顺着 `parent` 指针一路找到它的根节点。 `union, connected, count` 方法的实现思路如下：

```
// 连接节点 p 和节点 q

void union(UFNode p, UFNode q) {

    // 找到节点 p 和节点 q 的根节点

    // 将 p 所在的整棵树接到 q 所在的整棵树下面

    find(p).parent = find(q);

}

// 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内）

boolean connected(UFNode p, UFNode q) {

    return find(p).id == find(q).id;

}

// 查询节点 node 的根节点，时间复杂度取决于树的高度

UFNode find(UFNode node) {

    while (node.parent != null) {

        node = node.parent;

    }

    return node;

}
```

`union` 和 `connected` 方法的时间复杂度都依赖 `find` 方法，而 `find` 方法的时间复杂度取决于树的高度。

**所以并查集算法最终的目标，就是要尽可能降低树的高度，如果能保持树高为常数，那么上述方法的复杂度就都是 $O(1)$ 了** 。

## 可视化并查集的实现及优化

下面用可视化面板展示一下并查集的效果，以及逐步的优化效果。

按照上面的介绍，并查集的逻辑结构是一个森林（若干棵多叉树），可视化面板为了方便展示，给这个森林创建了一个虚拟节点上，其中虚拟节点是透明的， **每棵多叉树的根节点显示为红色，普通节点显示为绿色** 。这样就可以用一棵多叉树的形式展示森林结构，同时又能方便地看到每个连通分量的根节点。

### 未优化的并查集效果

首先用 `UF.createNaive` 创建一个未经优化的并查集实现， `union(p, q)` 就是直接把 `p` 所在的树接到 `q` 所在的树下面：

算法可视化

但是这个未优化的 UF 算法实现可能有效率问题，因为它直接把 `p` 所在的树接到 `q` 所在的树下面，完全不考虑合并后的树的深度，那么对于特定顺序的 union 操作，可能让森林退化成链表，下面是一个例子：

算法可视化

这种情况下，树的高度会线性增长，多叉树退化成单链表， `find` 方法的时间复杂度会退化成 $O(N)$ ， `union, connected` 方法的时间复杂度也会退化成 $O(N)$ 。

### 权重数组的优化效果

**在仔细观察即可发现，使得树高线性增长的原因是，每次 `union` 操作都是将节点个数较多的树接到了节点个数较少的树下面** ，这就很容易让树高增加，很不明智。

所以为了解决这个问题，一种优化思路是引入一个权重数组，记录以每个节点的为根的树的节点个数，然后在 `union` 方法中，总是将节点个数较少的树接到节点个数较多的树下面，这样可以保证树尽可能平衡，树高也就不会线性增长。

下面使用 `UF.createWeighted` 创建一个使用权重数组优化的 UF 算法实现：

算法可视化

可以看到，同样的测试代码，这种优化的 UF 算法实现，就不会出现树高过度增长的情况。

这个算法可以保证最终树高在 $O(\log N)$ 级别，所以 `union, connected, find` 方法的时间复杂度都是 $O(\log N)$ 。

### 路径压缩的优化效果

下面展示一下路径压缩优化方法，它可以让树高始终保持在常数级别，这样 `union, connected, find` 方法的时间复杂度都是 $O(1)$ 。

使用 `UF.createPathCompression` 创建一个使用路径压缩优化的 UF 算法实现，请你逐行点击每行代码，观察右侧的树结构：

算法可视化

在 `union` 算法执行时，你会看到树的高度并不平衡，那是因为我的测试数据比较特殊， `union` 操作并没有受到树高的影响，所以没有触发完整的路径压缩。

最后执行 `connected` 方法时，由于节点 `0, 1` 在树的底部，所以对整条树枝触发了路径压缩，直接将树的高度压缩到了 2。

这就是路径压缩的效果，一旦触发，无论树枝的高度是多少，都会被直接压缩为 2，路径压缩的 [均摊复杂度](https://labuladong.online/zh/algo/essential-technique/complexity-analysis/) 是 $O(1)$ ，这样就可以保证 `union, connected, find` 方法的时间复杂度都是常数级别 $O(1)$ 。

以上就是并查集的核心原理及直观展示，具体的代码实现安排在后面的 [Union Find 算法实现及应用](https://labuladong.online/zh/algo/data-structure/union-find/) 章节中，建议按照目录顺序循序渐进地学习。

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表