---
title: 图结构最短路径算法概览
source: https://labuladong.online/zh/algo/data-structure-basic/graph-shortest-path/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-06
description: 本文介绍图结构最短路径的算法，包括 Dijkstra 算法、Bellman-Ford 算法、Floyd 算法等，介绍区别和使用场景。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [图结构基础及通用代码实现](https://labuladong.online/zh/algo/data-structure-basic/graph-basic/)
- [图结构的 DFS/BFS 遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/)

一句话总结

Dijkstra 算法和 A\* 算法是 [图的 BFS 遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) 的拓展，可以处理不包含负权重的单源最短路径问题。

SPFA 算法（基于队列的 Bellman-Ford 算法）是 [图的 BFS 遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) 的拓展，可以处理包含负权重的单源最短路径问题。

Floyd 算法是 [动态规划](https://labuladong.online/zh/algo/essential-technique/dynamic-programming-framework/) 的应用，可以处理多源最短路径问题。

<svg xmlns="http://www.w3.org/2000/svg" class="w-full font-sans markmap-svg markmap mm-922vvt-2" style="height: 400px; opacity: 1; transition: opacity 0.3s ease-in-out; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --markmap-max-width: 400px;"><g transform="translate(20.966667175293026,224.32679779784326) scale(0.9253581331720473)"><path class="markmap-link" data-depth="4" data-path="1.2.3.4" d="M489,-120.352C529,-120.352,529,-134.039,569,-134.039" stroke-width="1.1875" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="4" data-path="1.2.3.5" d="M489,-120.352C529,-120.352,529,-106.852,569,-106.852" stroke-width="1.1875" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="4" data-path="1.2.6.7" d="M618,-50.977C658,-50.977,658,-74.664,698,-74.664" stroke-width="1.1875" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="4" data-path="1.2.6.8" d="M618,-50.977C658,-50.977,658,-47.477,698,-47.477" stroke-width="1.1875" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="4" data-path="1.2.9.10" d="M570,-15.195C610,-15.195,610,-15.289,650,-15.289" stroke-width="1.1875" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="3" data-path="1.2.3" d="M304,-67.586C344,-67.586,344,-120.352,384,-120.352" stroke-width="1.375" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="3" data-path="1.2.6" d="M304,-67.586C344,-67.586,344,-50.977,384,-50.977" stroke-width="1.375" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="3" data-path="1.2.9" d="M304,-67.586C344,-67.586,344,-15.195,384,-15.195" stroke-width="1.375" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="4" data-path="1.11.12.13" d="M466,30.773C506,30.773,506,17.086,546,17.086" stroke-width="1.1875" stroke="rgb(214, 39, 40)"></path><path class="markmap-link" data-depth="4" data-path="1.11.12.14" d="M466,30.773C506,30.773,506,44.273,546,44.273" stroke-width="1.1875" stroke="rgb(214, 39, 40)"></path><path class="markmap-link" data-depth="3" data-path="1.11.12" d="M320,30.961C360,30.961,360,30.773,400,30.773" stroke-width="1.375" stroke="rgb(214, 39, 40)"></path><path class="markmap-link" data-depth="4" data-path="1.15.16.17" d="M475,90.148C515,90.148,515,76.461,555,76.461" stroke-width="1.1875" stroke="rgb(148, 103, 189)"></path><path class="markmap-link" data-depth="4" data-path="1.15.16.18" d="M475,90.148C515,90.148,515,103.648,555,103.648" stroke-width="1.1875" stroke="rgb(148, 103, 189)"></path><path class="markmap-link" data-depth="3" data-path="1.15.16" d="M304,90.336C344,90.336,344,90.148,384,90.148" stroke-width="1.375" stroke="rgb(148, 103, 189)"></path><path class="markmap-link" data-depth="2" data-path="1.2" d="M112,11.75C152,11.75,152,-67.586,192,-67.586" stroke-width="1.75" stroke="rgb(255, 127, 14)"></path><path class="markmap-link" data-depth="2" data-path="1.11" d="M112,11.75C152,11.75,152,30.961,192,30.961" stroke-width="1.75" stroke="rgb(214, 39, 40)"></path><path class="markmap-link" data-depth="2" data-path="1.15" d="M112,11.75C152,11.75,152,90.336,192,90.336" stroke-width="1.75" stroke="rgb(148, 103, 189)"></path><g class="markmap-highlight"></g><g data-depth="4" data-path="1.2.3.4" class="markmap-node" transform="translate(569, -155.6328125)"><line stroke="#ff7f0e" stroke-width="1.1875" x1="-1" x2="165" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="147" height="21"><p xmlns="http://www.w3.org/1999/xhtml">由 BFS 算法扩展而来</p></foreignObject></g><g data-depth="4" data-path="1.2.3.5" class="markmap-node" transform="translate(569, -128.4453125)"><line stroke="#ff7f0e" stroke-width="1.1875" x1="-1" x2="146" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="128" height="21"><p xmlns="http://www.w3.org/1999/xhtml">不能处理负权重边</p></foreignObject></g><g data-depth="3" data-path="1.2.3" class="markmap-node" transform="translate(384, -142.0390625)"><line stroke="#ff7f0e" stroke-width="1.375" x1="-1" x2="107" y1="21.6875" y2="21.6875"></line><circle stroke-width="1.5" r="6" stroke="#ff7f0e" fill="var(--markmap-circle-open-bg)" cx="105" cy="21.6875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="89" height="21"><p xmlns="http://www.w3.org/1999/xhtml">Dijkstra 算法</p></foreignObject></g><g data-depth="4" data-path="1.2.6.7" class="markmap-node" transform="translate(698, -96.2578125)"><line stroke="#ff7f0e" stroke-width="1.1875" x1="-1" x2="165" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="147" height="21"><p xmlns="http://www.w3.org/1999/xhtml">由 BFS 算法扩展而来</p></foreignObject></g><g data-depth="4" data-path="1.2.6.8" class="markmap-node" transform="translate(698, -69.0703125)"><line stroke="#ff7f0e" stroke-width="1.1875" x1="-1" x2="146" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="128" height="21"><p xmlns="http://www.w3.org/1999/xhtml">可以处理负权重边</p></foreignObject></g><g data-depth="3" data-path="1.2.6" class="markmap-node" transform="translate(384, -92.6640625)"><line stroke="#ff7f0e" stroke-width="1.375" x1="-1" x2="236" y1="41.6875" y2="41.6875"></line><circle stroke-width="1.5" r="6" stroke="#ff7f0e" fill="var(--markmap-circle-open-bg)" cx="234" cy="41.6875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="218" height="41"><p xmlns="http://www.w3.org/1999/xhtml">基于队列的 Bellman-Ford 算法<br>（SPFA 算法）</p></foreignObject></g><g data-depth="4" data-path="1.2.9.10" class="markmap-node" transform="translate(650, -36.8828125)"><line stroke="#ff7f0e" stroke-width="1.1875" x1="-1" x2="146" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="128" height="21"><p xmlns="http://www.w3.org/1999/xhtml">可以处理负权重边</p></foreignObject></g><g data-depth="3" data-path="1.2.9" class="markmap-node" transform="translate(384, -36.8828125)"><line stroke="#ff7f0e" stroke-width="1.375" x1="-1" x2="188" y1="21.6875" y2="21.6875"></line><circle stroke-width="1.5" r="6" stroke="#ff7f0e" fill="var(--markmap-circle-open-bg)" cx="186" cy="21.6875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="170" height="21"><p xmlns="http://www.w3.org/1999/xhtml">朴素 Bellman-Ford 算法</p></foreignObject></g><g data-depth="2" data-path="1.2" class="markmap-node" transform="translate(192, -89.4609375)"><line stroke="#ff7f0e" stroke-width="1.75" x1="-1" x2="114" y1="21.875" y2="21.875"></line><circle stroke-width="1.5" r="6" stroke="#ff7f0e" fill="var(--markmap-circle-open-bg)" cx="112" cy="21.875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="96" height="21"><p xmlns="http://www.w3.org/1999/xhtml">单源最短路径</p></foreignObject></g><g data-depth="4" data-path="1.11.12.13" class="markmap-node" transform="translate(546, -4.5078125)"><line stroke="#d62728" stroke-width="1.1875" x1="-1" x2="191" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="173" height="21"><p xmlns="http://www.w3.org/1999/xhtml">由 Dijkstra 算法扩展而来</p></foreignObject></g><g data-depth="4" data-path="1.11.12.14" class="markmap-node" transform="translate(546, 22.6796875)"><line stroke="#d62728" stroke-width="1.1875" x1="-1" x2="146" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="128" height="21"><p xmlns="http://www.w3.org/1999/xhtml">不能处理负权重边</p></foreignObject></g><g data-depth="3" data-path="1.11.12" class="markmap-node" transform="translate(400, 9.0859375)"><line stroke="#d62728" stroke-width="1.375" x1="-1" x2="68" y1="21.6875" y2="21.6875"></line><circle stroke-width="1.5" r="6" stroke="#d62728" fill="var(--markmap-circle-open-bg)" cx="66" cy="21.6875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="50" height="21"><p xmlns="http://www.w3.org/1999/xhtml">A* 算法</p></foreignObject></g><g data-depth="2" data-path="1.11" class="markmap-node" transform="translate(192, 9.0859375)"><line stroke="#d62728" stroke-width="1.75" x1="-1" x2="130" y1="21.875" y2="21.875"></line><circle stroke-width="1.5" r="6" stroke="#d62728" fill="var(--markmap-circle-open-bg)" cx="128" cy="21.875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="112" height="21"><p xmlns="http://www.w3.org/1999/xhtml">点对点最短路径</p></foreignObject></g><g data-depth="4" data-path="1.15.16.17" class="markmap-node" transform="translate(555, 54.8671875)"><line stroke="#9467bd" stroke-width="1.1875" x1="-1" x2="114" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="96" height="21"><p xmlns="http://www.w3.org/1999/xhtml">动态规划算法</p></foreignObject></g><g data-depth="4" data-path="1.15.16.18" class="markmap-node" transform="translate(555, 82.0546875)"><line stroke="#9467bd" stroke-width="1.1875" x1="-1" x2="146" y1="21.59375" y2="21.59375"></line><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="128" height="21"><p xmlns="http://www.w3.org/1999/xhtml">可以处理负权重边</p></foreignObject></g><g data-depth="3" data-path="1.15.16" class="markmap-node" transform="translate(384, 68.4609375)"><line stroke="#9467bd" stroke-width="1.375" x1="-1" x2="93" y1="21.6875" y2="21.6875"></line><circle stroke-width="1.5" r="6" stroke="#9467bd" fill="var(--markmap-circle-open-bg)" cx="91" cy="21.6875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="75" height="21"><p xmlns="http://www.w3.org/1999/xhtml">Floyd 算法</p></foreignObject></g><g data-depth="2" data-path="1.15" class="markmap-node" transform="translate(192, 68.4609375)"><line stroke="#9467bd" stroke-width="1.75" x1="-1" x2="114" y1="21.875" y2="21.875"></line><circle stroke-width="1.5" r="6" stroke="#9467bd" fill="var(--markmap-circle-open-bg)" cx="112" cy="21.875"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="96" height="21"><p xmlns="http://www.w3.org/1999/xhtml">多源最短路径</p></foreignObject></g><g data-depth="1" data-path="1" class="markmap-node" transform="translate(0, -10.5)"><line stroke="#1f77b4" stroke-width="2.5" x1="-1" x2="114" y1="22.25" y2="22.25"></line><circle stroke-width="1.5" r="6" stroke="#1f77b4" fill="var(--markmap-circle-open-bg)" cx="112" cy="22.25"></circle><foreignObject class="markmap-foreign" x="8" y="0" style="opacity: 1;" width="96" height="21"><p xmlns="http://www.w3.org/1999/xhtml">最短路径问题</p></foreignObject></g></g></svg>

初学者不要觉得图论算法有多难，因为它们都是基于简单的算法思想扩展出来的。你把基本的二叉树层序遍历玩明白，自己都能发明出来这些算法，没啥了不起的。

考虑到目前处在基础知识章节，所以本文并不会详细讲解每种算法的完整代码，具体的代码实现会安排在之后的章节。

本文的重点在这些算法的关键原理、适用场景，以及这些高级算法和基础知识的联系，帮助初学者对图结构的最短路径算法有一个整体的认识。

## 最短路径问题概览

最短路径问题在生活中应用广泛，比方说计算最小成本、最短路径长度、最少时间等。

在算法中，我们一般把这类问题抽象成计算 [加权图](https://labuladong.online/zh/algo/data-structure-basic/graph-basic/) 中的最小路径权重。为了方便表述， **在本文中「最短路径」和「最小路径权重和」是等价的** 。

最短路径问题大致可以分为「单源最短路径」和「多源最短路径」两类，下面会介绍几个经典的算法。

### 单源最短路径

所谓单源最短路径，就是让你计算从某个起点出发，到 **其他所有顶点** 的最短路径。

比方说一幅图中有 `n` 个节点，编号为 `0, 1, 2, ..., n-1` ，让你计算从 `2` 号节点到其他节点的最短路径，这就是单源最短路径问题。

单源最短路径算法最终得到的输出应该是一个一维数组 `distTo` ， `distTo[i]` 表示从起点到节点 `i` 的最短路径长度。

比较有代表性的单源最短路径算法有：

1、Dijkstra 算法，其本质是 BFS 算法 + 贪心思想，效率较高，但是不能处理带有负权重的图。

2、基于队列的 Bellman-Ford 算法，其本质也是 BFS 算法，可以处理带有负权重的图，但效率比 Dijkstra 算法低。

### 点对点最短路径

很多算法题中不需要我们计算起点到所有其他节点的最短路径，仅需要计算从起点 `src` 到某一个目标节点 `dst` 的最短路径。这类问题可以称为点对点最短路径问题。

**一般来说，点对点最短路径问题可以视为单源最短路径问题的特例** ，你可以从 `src` 开始执行单源最短路径算法，当算出到达 `dst` 的最短路径时提前结束算法。

但是下面将介绍一种专门处理点对点问题的算法： **A\* 算法** （A Star Algorithm）。

我经常讲，算法的本质是穷举，你想要提高穷举的效率，就得尽可能充分地利用信息。点对点最短路径问题（已知起点和终点）比单源最短路径问题（已知起点）多了终点信息，所以完全有可能利用这个信息来提高算法的效率。

比方说，如果我们知道终点在起点的右下方，那么我们有理由猜测：应该优先向右下方搜索，可能可以更快地到达终点。

A\* 算法的关键就在这里：它能够充分利用已知信息，有方向性地进行搜索，更快地找到终点。我们称这类算法为 **启发式搜索算法** （Heuristic Search Algorithm）。

但是请注意，这个猜测只是经验法则，并不一定总是正确。比方说右下方可能都是死路，偏偏就得经过左上角绕个大弯才能到达终点。

所以启发式算法需要合理设置启发函数（Heuristic Function），在经验法则和实际情况中找到平衡，确保在经验法则失效时，算法的效率也不会太差。

### 多源最短路径

所谓 **多源最短路径** ，就是让你计算任意两节点之间的最短路径。

比方说一幅图中有 `n` 个节点，编号为 `0, 1, 2, ..., n-1` ，让你计算所有节点之间的最短路径，这就是多源最短路径问题。

多源最短路径算法最终得到的输出应该是一个二维数组 `dist` ， `dist[i][j]` 表示从节点 `i` 到节点 `j` 的最短路径长度。

最有代表性的是 Floyd 算法，其本质是动态规划算法。

理论上，我们对所有节点都调用一次单源最短路径算法，就可以得到多源最短路径的解。

但具体实现时，要根据图结构的特点来选择。有些场景用 Floyd 这种多源最短路径算法效率更高，有些场景多次调用 Dijkstra 这种单源最短路径算法效率更高。后面讲到这些算法的复杂度时，你就能理解了。

### 负权重边的影响

在计算最短路径时，需要着重注意的是这幅图是否包含 **负权重边** ；一旦包含负权重边，一定要检查是否包含 **负权重环** 。

为啥负权重边会影响最短路径算法呢？因为负权重边会让问题变得复杂。举个最简单的例子就能直观地理解了：

比方说我们现在站在起点 `s` 上，相邻节点有 `a` 和 `b` ， `s->a` 权重为 3， `s->b` 权重为 4。

如果这幅图不存在负权重边，那么根据上述信息，我就已经可以确定 `s` 到 `a` 的最短路径是 `s->a` ，权重和为 3。因为你从 `s->b` 这条路径走出去，绕一圈到达 `a` 的路径权重和肯定是大于 4 的，不可能比 3 还小。

但如果这幅图存在负权重边，那可就不一定了。因为可能出现负权重边呀，比方说 `b->a` 的权重为 -10，那么从 `s->b->a` 的路径权重和为 -6，比 `s->a` 的路径权重和 3 还小。

想让 Dijkstra 这类包含贪心思想的算法成立，需要一个前提： **它假设随着经过的边的数量增加，路径权重和一定也会增加** 。但负权重边的出现打破了这一假设，导致算法失效。

如果图中存在负权重环，最短路径问题就没有意义了。比方说 `s` 到 `a` 的路径上存在负权重环，那么你可以在这个负权重环上无限转圈，使得路径权重和无限减小下去。

常见最短路径算法中，Dijkstra 算法和 A\* 算法不能处理含有负权重边的图，Floyd 算法和 Bellman-Ford 算法可以处理负权重边，Bellman-Ford 算法常用来检测负权重环。

下面，我们介绍这些算法的核心原理。

## Dijkstra 算法简介

Dijkstra 算法的本质就是 BFS 算法 + 贪心思路，可以解决不包含负权重的单源最短路径问题。

其实你可以很容易地直接从标准的 BFS 遍历出发，推演出 Dijkstra 算法的代码。来思考标准的 [二叉树 BFS（层序）遍历](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-traverse-basic/) 和 [图的 BFS 遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) ，为什么它们能算出最短路径？

因为它们的场景中都是无权边，可以认为每条边的权重都是 1，所以边的条数就等同于路径的权重和；由于 BFS 逐层扩散的逻辑，最先到达终点的路径经过的边数就是最少的，也就是路径权重和最小的路径。

现在考虑加权图，其中每条边可能有不同的权重，边最少的路径，不一定是权重和最小的，所以路径中边的条数已经没有意义了。

首先，我们需要用到 [图的 BFS 遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) 中第三种代码实现，让 BFS 算法关注路径的权重和而不是边的数量。

另外，我们需要优先扩散权重和最小的路径，最先到达终点的路径就是权重和最小的路径。这就是贪心思想的体现，在讲代码实现时我们会进行数学证明。

如何优先扩散权重和最小的路径呢？借助 [优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 把权重小的路径排前面，优先级队列的逻辑是每次出队权重最小的节点，最先到达终点的路径就是权重和最小的路径。

对比标准 BFS 算法，只需修改两个地方即可得到 Dijkstra 算法：

**1、标准 BFS 算法使用普通队列，Dijkstra 算法使用优先级队列** 。

**2、标准 BFS 算法使用一个 `visited` 数组记录访问过的节点，确保算法不会陷入死循环；Dijkstra 算法使用一个 `distTo` 数组，确保算法不会陷入死循环，同时记录起点到其他节点的最短路径** 。

对于初学者来说，上面的描述可能有点抽象，不过不用担心，你现在只需要知道 Dijkstra 算法就是 BFS 算法的变种就行了。具体的代码实现和例题参见 [Dijkstra 算法详解](https://labuladong.online/zh/algo/data-structure/dijkstra/) 。

## A\* 算法简介

对于任意节点 $x$ ，我们用 $g(x)$ 表示从起点 $src$ 到节点 $x$ 的距离，用 $h(x)$ 表示启发函数，用于估计从节点 $x$ 到终点 $dst$ 的距离。

那么 Dijkstra 算法就是借助优先级队列，让 $g(x)$ 最小的节点先出队，从而保证终点第一次出队时，就找到了最短路径。

而 A\* 算法中稍作了一点改动：让 $f(x) = g(x) + h(x)$ 最小的节点优先出队，终点第一次出队时，就找到了最短路径。

仔细想想， $f(x)$ 函数虽然简单，却非常精妙：

- 无论是接近终点还是远离终点， $g(x)$ 肯定是不断增大的。
- 但是接近终点时， $h(x)$ 会逐渐减小；远离终点时， $h(x)$ 会逐渐增大。

也就是说，接近终点时 $f(x)$ 的增速慢，节点更容易出队，算法也就会优先向终点的方向进行搜索；反之，远离终点时 $f(x)$ 的增速快，搜索的优先级就会降低。

只需要稍微修改 Dijkstra 算法的代码即可得到 A\* 算法的代码，具体实现及应用场景会在后面的章节介绍。

## Bellman-Ford/SPFA 算法简介

当说到包含负权重边的最短路径问题是，经常提到 Bellman-Ford 算法和 SPFA 算法（Shortest Path Faster Algorithm）。

这里有必要先澄清一下：当我们说 Bellman-Ford 算法时，一般是指 **朴素 Bellman-Ford 算法** ；当我们说 SPFA 算法时，是指对朴素 Bellman-Ford 算法的一种优化，即 **基于队列的 Bellman-Ford 算法** 。

这里仅介绍 SPFA 算法，因为可以通过标准 BFS 算法推导出来。朴素 Bellman-Ford 算法会在讲解代码实现时再介绍。

对比标准的 BFS 算法，SPFA 算法只有一个地方不一样：

**标准 BFS 算法使用一个布尔数组 `visited` 确保每个节点只会遍历一次，避免算法陷入死循环；SPFA 算法中，需要使用 `inQueue, count` 数组配合，确保算法不会陷入死循环，同时用一个 `distTo` 数组记录起点到其他节点的最短路径** 。

对于初学者来说，上面的描述可能也有点抽象。不过不用担心，你现在只需要知道 SPFA 算法就是 BFS 算法的变种就行了。具体的代码实现和例题会更新在数据结构设计章节。

## Floyd 算法简介

Floyd 算法是求解多源最短路径问题的经典算法，它的核心思想是 [动态规划](https://labuladong.online/zh/algo/essential-technique/dynamic-programming-framework/) ，和前面讲的基于 BFS 算法的单源最短路径算法完全不同。

在这个章节肯定没办法给初学者彻底讲清楚 Floyd 算法的原理，只能尽量描述一下这个算法的思路。

假设图中节点 `i` 和节点 `j` 之间存在最短路径，应该如何计算节点 `i` 到节点 `j` 的最短路径呢？

如果节点 `i` 和节点 `j` 之间有直接相连的边，那么节点 `i` 到节点 `j` 的最短路径就是这条边的权重。

如果节点 `i` 和节点 `j` 之间没有直接相连的边，那么肯定要经过至少 1 个其他节点。

对于任意一个其他节点 `k` ，如果最短路径经过 `k` ，那么节点 `i` 到节点 `j` 的最短路径就是节点 `i` 到节点 `k` 的最短路径加上节点 `k` 到节点 `j` 的最短路径。

这样一来，原问题「 `i` 到 `j` 的最短路径」就变成了两个结构相同，规模更小的子问题「 `i` 到 `k` 的最短路径」和「 `k` 到 `j` 的最短路径」，这就是动态规划的特征，我们将根据这个思路来推导转移方程。

是不是对上面的描述有些懵圈？不必担心，虽然 Floyd 算法的核心代码只有 3 行，但状态转移方程确实不容易理解， [Floyd 算法原理及应用](https://labuladong.online/zh/algo/data-structure/floyd/) 中会详细讲解。

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表