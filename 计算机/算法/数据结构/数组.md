# 数组

## 概述

在不同的编程语言中，「数组」这个概念有着不同的含义和实现方式。为了便于理解和学习，我们需要先统一术语，明确不同类型数组的本质区别。

从底层实现的角度，可以将数组分为两大类：**静态数组**和**动态数组**。

### 数组的分类

#### 静态数组（Static Array）

- **定义**：在编译时或运行时创建时就固定大小的数组，是一块**连续的内存空间**
- **特点**：
  - 大小固定，创建后无法改变
  - 直接映射到内存地址，这是数组的**原始形态**
  - 通过索引进行**O(1)时间复杂度**的随机访问
- **支持语言**：C/C++、Java、Go 等系统级或静态类型语言
- **典型例子**：`int arr[10]`（C++）、`int[] arr = new int[10]`（Java）

#### 动态数组（Dynamic Array）

- **定义**：基于静态数组封装的**高级数据结构**，可以在运行时动态调整大小
- **本质**：底层仍然是静态数组，但提供了**自动扩缩容**和**丰富的操作API**
- **特点**：
  - 大小可变，根据需要自动扩容或缩容
  - 封装了常用操作：插入、删除、查找等
  - 隐藏了内存管理的复杂性
- **支持语言**：几乎所有现代编程语言都提供
- **典型例子**：`vector<int>`（C++）、`ArrayList<Integer>`（Java）、`list`（Python）、`Array`（JavaScript）

### 核心区别

| 特性 | 静态数组 | 动态数组 |
| ------ | ---------- | ---------- |
| **大小** | 固定不变 | 可动态调整 |
| **内存管理** | 手动管理 | 自动管理 |
| **操作API** | 基础的索引访问 | 丰富的增删查改方法 |
| **性能开销** | 最小 | 有一定开销（扩容、内存拷贝） |
| **使用场景** | 底层实现、性能敏感 | 日常开发、算法实现 |

## 静态数组

静态数组在创建的时候就要确定数组的元素类型和元素数量。只有在 C++、Java、Go 这类**静态类型语言**中才提供了创建静态数组的方式，而 Python、JavaScript 这类**动态类型语言**并没有提供静态数组的定义方式。

静态数组的用法比较原始，实际软件开发中很少用到，写算法题也没必要用，我们一般直接用动态数组。但为了理解原理，在这里还是要讲解一下。

### 定义和基本操作

定义一个静态数组的方法如下：

```c++
// 定义一个大小为 10 的静态数组
int arr[10];

// 用 memset 函数把数组的值初始化为 0
memset(arr, 0, sizeof(arr));

// 使用索引赋值
arr[0] = 1;
arr[1] = 2;

// 使用索引取值
int a = arr[0];
```

### 底层原理

`int arr[10]` 这段代码到底做了什么事情呢？

1. 在内存中开辟了一段连续的内存空间，大小是 `10 * sizeof(int)` ，即40字节。

2. 定义了一个名为 arr 的数组指针，指向这段内存空间的首地址。

那么 `arr[1] = 2` 这段代码又做了什么事情呢？主要有这么几件事：

1. 计算 arr 的首地址加上 `1 * sizeof(int)` 字节（4 字节）的偏移量，找到了内存空间中的第二个元素的首地址。

2. 从这个地址开始的 4 个字节的内存空间中写入了整数 2。

### 数组的超能力：随机访问

现在，我们可以从`int arr[10]` 这个语句得知：

1. 我们知道这块内存空间的首地址（数组名 arr 就指向这块内存空间的首地址）。

2. 我们知道了每个元素的类型（比如 int），也就是知道了每个元素占用的内存空间大小（比如一个 int 占 4 字节，32 bit）。

3. 这块内存空间是连续的，其大小为 `10 * sizeof(int)` 即 40 字节。

所以，我们获得了数组的超能力「**随机访问**」：只要给定任何一个数组索引，我可以在 O(1) 的时间内直接获取到对应元素的值。

因为我可以通过首地址和索引直接计算出目标元素的内存地址。计算机的内存寻址时间可以认为是 O(1)，所以数组的随机访问时间复杂度是 O(1)。

## 增删查改

数据结构的职责就是增删查改，再无其他。

那么刚刚介绍数组这种数据结构的底层原理，我们其实只介绍了「查」和「改」的部分，也就是通过索引修改和访问对应元素的值。那么「增删」这两个操作又是如何实现的呢？

### 增加元素

要想给静态数组增加元素，这就有些复杂了，需要分情况讨论。

#### 情况一：数组末尾追加（append）元素

比方说，我有一个大小为 10 的数组，里面装了 4 个元素，现在想在末尾追加一个元素，怎么办？

```cpp
// 大小为 10 的数组已经装了 4 个元素
int arr[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 4
arr[4] = 4;

// 再在数组末尾追加一个元素 5
arr[5] = 5;

// 依此类推
// ...
```

可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度是 **O(1)**。

#### 情况二：数组中间插入（insert）元素

比方说，我有一个大小为 10 的数组 arr，前 4 个索引装了元素，现在想在第 3 个位置（`arr[2]`）插入一个新元素，怎么办？

这就要涉及**数据搬移**，给新元素腾出空位，然后再才能插入新元素。大概的代码逻辑是这样的：

```cpp
// 大小为 10 的数组已经装了 4 个元素
int arr[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 在索引 2 置插入元素 666
// 需要把索引 2 以及之后的元素都往后移动一位
// 注意要倒着遍历数组中已有元素避免覆盖
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}

// 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666;
```

综上，在数组中间插入元素的时间复杂度是 **O(N)**，因为涉及到数据搬移，给新元素腾地方。

#### 情况三：数组空间已满

静态数组在创建时就要确定大小，比方说现在我创建了一个数组 `int arr[10]`（一块 40 字节的连续内存空间），然后往里面存了 10 个元素，这时候我想再插入一个元素，怎么办？无论是追加在尾部还是插入到中间，都没有位置留给新元素了。

可以在原先的数组后面多加上4个字节的位置用来存储前面的元素么？

**不行的**，连续内存必须一次性分配，分配完了之后就不能随意增减了。

那怎么办呢？只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，这就是数组的「**扩容**」操作。

比方说，我重新创建一个更大的数组 `int arr[20]`  
大概的逻辑是这样的：

```cpp
// 大小为 10 的数组已经装满了
int arr[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 10
// 需要先扩容数组
int newArr[20];
// 把原来的 10 个元素复制过去
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}

// 释放旧数组的内存空间
// ...

// 在新的大数组中追加新元素
newArr[10] = 10;
```

综上，数组的扩容操作会涉及到新数组的开辟和数据的复制，时间复杂度是 **O(N)**。

### 删除元素

删除元素的操作和增加元素的操作类似，也需要分情况讨论。

#### 情况一：删除末尾元素

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除末尾的元素，怎么办？

很简单，直接把末尾元素标记为一个特殊值代表已删除就行了，我们这里简单举例，就用 -1 作为特殊值代表已删除好了。后面带大家具体实现动态数组的时候，会有更完善的方法删除数组元素，这里只是为了说明删除数组尾部元素的本质就是进行一次随机访问，时间复杂度是 **O(1)**。

大概的代码逻辑是这样的：

```cpp
// 大小为 10 的数组已经装了 5 个元素
int arr[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1;
```

#### 情况二：删除中间元素

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除第 2 个元素（`arr[1]`），怎么办？

这也要涉及「**数据搬移**」，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。

大概的代码逻辑是这样的：

```cpp
// 大小为 10 的数组已经装了 5 个元素
int arr[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除 arr[1]
// 需要把 arr[1] 之后的元素都往前移动一位
// 注意要正着遍历数组中已有元素避免覆盖
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}

// 最后一个元素置为 -1 代表已删除
arr[4] = -1;
```

综上，在数组中间删除元素的时间复杂度是 **O(N)**，因为涉及到数据搬移。

## 时间复杂度总结

综上，静态数组的增删查改操作的时间复杂度是：

**增：**

- 在末尾追加元素：**O(1)**
- 在中间（非末尾）插入元素：**O(N)**

**删：**

- 删除末尾元素：**O(1)**
- 删除中间（非末尾）元素：**O(N)**

**查：**给定指定索引，查询索引对应的元素的值，时间复杂度 **O(1)**

**改：**给定指定索引，修改索引对应的元素的值，时间复杂度 **O(1)**

### 关于扩容的复杂度

有读者可能问，刚才不是还探讨过数组的扩容操作吗，扩容涉及到新数组空间的开辟和数据的复制，时间复杂度是 O(N)，这个复杂度为什么没有算到「增」的复杂度里面呢？

这个问题很好，但并不是每次增加元素的时候都会触发扩容，所以扩容的复杂度要用「**均摊时间复杂度**」来分析，这个概念我在时空复杂度分析方法中有详细的讲解，这里就不展开了。

### 重要提醒

还有个问题初学者要注意，我们说数组的查、改复杂度是 O(1)，这个仅仅适用于**给定索引**的情况。如果反过来，比方说给你一个值，让你去找这个值在数组中对应的索引，那你只能遍历整个数组去寻找对吧，这个复杂度就是 **O(N)** 了。

所以说要搞清楚原理，而不要去背概念。原理懂了，概念你自己都能推导出来的。
