---
title: 基数排序（Radix Sort）
source: https://labuladong.online/zh/algo/data-structure-basic/radix-sort/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-06
description: 基数排序（Radix Sort）是计数排序的扩展，它的主要思路是对待排序元素的每一位依次进行计数排序。基数排序分为从高位到低位（Most Significant Digit first，简称 MSD）和从低位到高位（Least Significant Digit first，简称 LSD）两种。本文介绍基数排序原理、稳定性、时空复杂度，以及 Java/Python/C++/Go/JavaScript 代码实现。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [排序算法的关键指标](https://labuladong.online/zh/algo/data-structure-basic/sort-basic/)
- [计数排序](https://labuladong.online/zh/algo/data-structure-basic/counting-sort/)

一句话总结

基数排序是 [计数排序](https://labuladong.online/zh/algo/data-structure-basic/counting-sort/) 算法的扩展，它的主要思路是对待排序元素的每一位依次进行计数排序。由于计数排序是稳定的，所以对每一位完成计数排序后，所有元素就完成了排序。

点击 `let maxLen = 0` 这一行代码，可以看到算法将数组元素都转化为了非负数；多次点击 `countSort(nums, k)` 这一行代码，对每一位执行计数排序；最后点击 `nums[i] -= offset` 这一行代码，将数组元素转化回原来的值，完成排序：

算法可视化

首先解释一下基数排序（Radix Sort）这个名词。

基数（Radix）其实就是进制的意思，比如十进制数的基数就是 10，二进制数的基数就是 2。看这个名字就知道这个排序算法肯定和数字的进制有关，进而可以推断，这个算法不是通用排序算法，待排序数据必须是整数，或者能够通过某种规则转化成整数，才能使用基数排序。

我发现网上的很多资料会把基数排序和桶排序放在一起，认为基数排序是桶排序的应用。

但我不认同这种看法，我认为基数排序是计数排序的扩展，可以用来解决计数排序空间复杂度过高的问题，和桶排序关系不大。

现在你已经学习过 [计数排序](https://labuladong.online/zh/algo/data-structure-basic/counting-sort/) 和 [桶排序](https://labuladong.online/zh/algo/data-structure-basic/bucket-sort/) 了，在我介绍了基数排序的原理后，你也可以自己思考一下，它是到底是计数排序的扩展还是桶排序的扩展。

## 基数排序的原理

基数排序的原理很简单，比方说输入的数组都是三位数 `nums = [329, 457, 839, 439, 720, 355, 350]` ，我们先按照个位数排序，然后按照十位数排序，然后按照百位数排序，最终就完成了整个数组的排序。

**这里面的关键在于，对每一位的排序都必须是稳定排序，否则最终结果就不对了** 。

用这个 `nums` 数组为例，演示一下基数排序的过程，我把每个数字竖着写，方便查看每一位的排序效果。

首先是初始状态：

```
329

457

839

439

720

355

350
```

按照个位数进行稳定排序，得到：

```
720

350

355

457

329

839

439

  ^
```

再按照十位数进行稳定排序，得到：

```
720

329

839

439

350

355

457

 ^
```

最后按照百位数进行稳定排序，得到：

```
329

350

355

439

457

720

839

^
```

上面就是基数排序的过程，在给出解法代码之前，先解答一些关于基数排序的问题：

1、为什么对每一位必须使用稳定排序？

2、使用什么稳定排序比较好，为什么？

3、如果待排序数组中的数字不全是三位数，怎么办？有负数怎么办？

4、必须按照从个位数到高位数的顺序进行排序吗？是否可以反过来，从高位数到个位数进行排序？

### 为什么对每一位必须使用稳定排序

举个很简单的例子：

```
56

57
```

个位数已经排好序了，现在要对十位数排序。

十位数都是 5，稳定排序可以保证这两个 5 的顺序不变，最终的结果就是正确的；而如果使用不稳定排序，这两个 5 的顺序就可能被打乱，最终的结果就不对了。

### 使用什么稳定排序比较好

最好的选择是 [计数排序](https://labuladong.online/zh/algo/data-structure-basic/counting-sort/) 。

因为计数排序的时空复杂度是 $O(n + max - min)$ ，主要取决于待排序元素的范围，而对于基数排序的场景，十进制数的每一位都是 0-9，所以计数排序的时间空间复杂度都是线性的 $O(n + 10) = O(n)$ ，所以计数排序是最好的选择。

### 位数不同怎么办

如果待排序数组中的数字的位数不同，可以在逻辑上把所有数字都补齐成相同的位数，位数不足则在前面补 0。

比如 `[1, 10, 100, 1000]` ，我们可以视为 `[0001, 0010, 0100, 1000]` 。算法代码可以轻松做到这一点。

### 有负数怎么办

这个问题有多种解决方法，比如把正数和负数分开排序，最后再合并。

不过我觉得最简单的方法是模仿 [计数排序](https://labuladong.online/zh/algo/data-structure-basic/counting-sort/) 、 [桶排序](https://labuladong.online/zh/algo/data-structure-basic/bucket-sort/) 的处理方式，给所有数字都加上一个偏移量，使得所有数字都是非负数，排序完成后再减去这个偏移量即可。

### 必须从低位到高位吗（LSD 和 MSD）

对于普通的整数排序，必须按照从低位到高位的顺序进行排序，还是举个简单的例子：

```
90

18
```

如果按照从高位到低位的顺序进行排序，最后对个位数排序，会认为 90 比 18 小，这显然是不对的。

基数排序分为从高位到低位（Most Significant Digit first，简称 MSD）和从低位到高位（Least Significant Digit first，简称 LSD）两种。

上面的整数排序算法使用的就是 LSD， **MSD 的主要应用场景是字典序排序，其排序算法需要用到递归，和 LSD 有较大差异** 。

字典序排序和普通的数字排序是不同的，字符串 `"a" < "ab" < "b"` ， `"1" < "10" < "2"` ，这种场景下就需要使用 MSD 顺序进行排序。

### MSD 算法逻辑

模拟一下 MSD 排序的过程，比方说待排序数组是 `["10", "2", "1", "21", "20", "134"]` ，首先按照最左侧的字符进行排序：

```
"10"

"1"

"134"

"2"

"21"

"20"

^
```

接下来呢？你觉得应该怎么办，按照第二位进行排序吗？

那么问题来了，首先就是如果没有第二位怎么办？是否可以默认填充一个字符串，比如 `"0"` ？

答案是不行，因为 `"1"` 应该小于 `"10"` ，如果给 `"1"` 填充一个 `"0"` ，那么相当于它俩相等了，这显然是不对的。

所以对于位数不足的，应该视作空字符串，并规定空字符串小于任何非空字符串，这样就能正确处理 `"1" < "10"` 这种情况了。

接下来还有问题，如果你对所有字符串都按照第二位进行排序，就会发现都乱套了：

```
"1"

"2"

"10"

"20"

"21"

"134"

  ^
```

正确的做法是，不应该对所有字符串都按照第二位进行排序，而应该把这些字符串按照第一位分组，然后对每一组分别对第二位进行排序：

```
"1"

"10"

"134"

  ^

----

"2"

"20"

"21"

  ^
```

第二位完成排序后，再按照第二位分组，然后分别对第三位进行排序，以此类推。

这样，就能正确地按照字典序排序字符串了。

至于如何分组，关键在于对标准 [计数排序](https://labuladong.online/zh/algo/data-structure-basic/counting-sort/) 做了一些改动，利用 `count` 数组的信息进行分组和递归排序。

在讲解计数排序时，我举了这样一个例子来说明 `count` 数组的含义：

`count[0] = 2` 说明 `nums` 排序后，索引区间 `[0, 2)` 都是元素 `0` ；

`count[1] = 3` 说明 `nums` 排序后，索引区间 `[2, 3)` 都是元素 `1` ；

`count[2] = 6` 说明 `nums` 排序后，索引区间 `[3, 6)` 都是元素 `2` ；

`count[3] = 8` 说明 `nums` 排序后，索引区间 `[6, 8)` 都是元素 `3` 。

换句话说， `count[i] = x` 说明 `nums` 排序后，索引区间 `[count[i-1], count[i])` 都是元素 `i` 。

所以，基于 `count` 数组的信息，我们就能对相同前缀的元素进行分组，进而递归地对每组元素进行排序。

考虑到本文处于基础知识章节，暂时先不实现 MSD 算法，我将在后面的专题中添加 MSD 算法的实现。

## LSD 代码实现

**假设有一个正整数 `num` ，从右往左数（LSD），想要获取第 `k` 位数字（ `k` 从 0 开始），可以使用 $(num / 10^k) \% 10$ 这个公式** 。

即使 `num` 的总位数小于 `k` ，则 $(num / 10^k) \% 10 = 0$ ，也是正确的。

因此，我们可以写出 LSD 基数排序代码：

```
// 基数排序

void radixSortLSD(std::vector<int>& nums) {

    int min = INT_MAX;

    for (int num : nums) {

        min = std::min(min, num);

    }

    // 根据最小元素，将所有元素转化为从零开始的非负数

    int offset = -min;

    for (int i = 0; i < nums.size(); i++) {

        nums[i] += offset;

    }

    int max = INT_MIN;

    for (int num : nums) {

        max = std::max(max, num);

    }

    // 计算最大元素的位数

    int maxLen = 0;

    while (max > 0) {

        max /= 10;

        maxLen++;

    }

    // 从低位到高位，依次对每一位进行计数排序

    for (int k = 0; k < maxLen; k++) {

        countSort(nums, k);

    }

    // 将所有元素转化回原来的值

    for (int i = 0; i < nums.size(); i++) {

        nums[i] -= offset;

    }

}

// 基数排序使用的计数排序算法函数

// 已经确保 nums 中的元素都是非负数

// k 是当前需要排序的位数

void countSort(std::vector<int>& nums, int k) {

    // 基数排序中每一位十进制数的取值范围是 0~9

    std::vector<int> count(10, 0);

    // 对每个元素的第 k 位进行计数

    for (int num : nums) {

        int digit = (num / static_cast<int>(std::pow(10, k))) % 10;

        count[digit]++;

    }

    for (int i = 1; i < count.size(); i++) {

        count[i] += count[i - 1];

    }

    // 按照第 k 位的值对元素进行排序

    std::vector<int> sorted(nums.size());

    for (int i = nums.size() - 1; i >= 0; i--) {

        int digit = (nums[i] / static_cast<int>(std::pow(10, k))) % 10;

        sorted[count[digit] - 1] = nums[i];

        count[digit]--;

    }

    // 把排序结果复制回原数组

    for (int i = 0; i < nums.size(); i++) {

        nums[i] = sorted[i];

    }

}
```

这个代码稍加修改，即可解决力扣第 912 题「 [排序数组](https://leetcode.cn/problems/sort-an-array/) 」。

## 时空复杂度及稳定性

对于 LSD 基数排序，由于对每一位的排序都是稳定的，所以最终的排序结果也是稳定的。

假设待排序数组长度为 $n$ ，最大元素的位数为 $m$ ，LSD 计数排序本质上就是执行了 $m$ 次计数排序。

前文分析过，计数排序的时空复杂度都是 $O(n + max - min)$ ，在十进制整数的基数排序的场景中， $max - min$ 的值是常数 10，可以忽略，所以每次计数排序的时空复杂度都是 $O(n)$ 。

因此，LSD 基数排序的时间复杂度是 $O(mn)$ ，空间复杂度是 $O(n)$ 。

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表