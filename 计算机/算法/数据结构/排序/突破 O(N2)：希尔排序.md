---
title: 突破 O(N^2)：希尔排序
source: https://labuladong.online/zh/algo/data-structure-basic/shell-sort/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-06
description: 本文介绍希尔排序的原理、代码实现、时空复杂度和稳定性，并分析优化思路。
tags:
  - clippings
---
# 突破 O(N2)：希尔排序
前置知识

阅读本文前，你需要先学习：

- [选择排序所面临的问题](https://labuladong.online/zh/algo/data-structure-basic/select-sort/)
- [运用逆向思维：插入排序](https://labuladong.online/zh/algo/data-structure-basic/insertion-sort/)

一句话总结

希尔排序是基于 [插入排序](https://labuladong.online/zh/algo/data-structure-basic/insertion-sort/) 的简单改进，通过预处理增加数组的局部有序性，突破了插入排序的 $O(N^2)$ 时间复杂度。

你可以点开可视化面板，点击播放按钮，然后点击加速/减速按钮调节速度，即可直观感受希尔排序的过程：

算法可视化

必须承认，希尔排序的思路很难想到，我是在《算法 4》第一次了解到这个算法，然后惊叹于这个算法的简单优化竟然能给插入排序带来如此大的提升。

首先我们要明确一个 **`h` 有序数组** 的概念。

## h 有序数组

一个数组是 `h` 有序的，是指这个数组中任意间隔为 `h` （或者说间隔元素的个数为 `h-1` ）的元素都是有序的。

这个概念用文字不好描述清楚，直接看个例子吧。比方说 `h=3` 时，一个 `3` 有序数组是这样的：

```
nums:

[1, 2, 4, 3, 5, 7, 8, 6, 10, 9, 12, 11]

 ^--------^--------^---------^

    ^--------^--------^---------^

       ^--------^--------^----------^

 1--------3--------8---------9

    2--------5--------6---------12

        4--------7--------10---------11
```

可以看到， `[1,3,8,9]` 、 `[2,5,6,12]` 、 `[4,7,10,11]` 这三个数组都是有序的，且元素 `1, 3` ，元素 `3, 8` ，元素 `8, 9` ，元素 `2, 5` 等等，每一对儿元素的间隔是 3（或者说间隔元素的个数是 2）。

所以我们称上面这个 `nums` 数组是 `3` 有序数组。你乍一看整个 `nums` 数组，是无序的，但是每 3 个元素分组后再看，每一组又都是有序的。

另外，按照这个定义， **当一个数组完成排序的时候，其实就是 `1` 有序数组** 。

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

 ^--^--^--^--^--^--^--^--^--^
```

## 希尔排序

我在前文 [插入排序](https://labuladong.online/zh/algo/data-structure-basic/insertion-sort/) 分析过，插入排序对于有序度较高的数组效率很高，直逼 $O(n)$ ，但对于有序度低（元素分布较随机）的数组就只有 $O(n^2)$ 了。

是否可以优化插入排序，使得即便有序度很低时，其时间复杂度也低于 $O(n^2)$ 呢？

希尔排序要发表看法了：

你插入排序的问题是，上来就想着一步到位，直接把乱序数组变成 `1` 有序数组。而我希尔排序不着急，比方说，我先把乱序数组变成一个 `16` 有序数组，然后再变成 `8` 有序数组， `4` 有序数组， `2` 有序数组，最后变成 `1` 有序数组，完成排序。

这个 `1, 2, 4, 8, 16...` 的序列称之为「递增函数」，我上面举的例子的递增函数就是 $2^{k-1}$ 。

那么如何把一个数组变成 `h` 有序数组呢？基于插入排序的代码改动几个地方就行了，直接看希尔排序的代码吧：

```
// 希尔排序，对 h 有序数组进行插入排序

// 逐渐缩小 h，最后 h=1 时，完成整个数组的排序

void sort(vector<int>& nums) {

    int n = nums.size();

    // 我们使用的生成函数是 2^(k-1)

    // 即 h = 1, 2, 4, 8, 16...

    int h = 1;

    while (h < n / 2) {

        h = 2 * h;

    }

    // 改动一，把插入排序的主要逻辑套在 h 的 while 循环中

    while (h >= 1) {

        // 改动二，sortedIndex 初始化为 h，而不是 1

        int sortedIndex = h;

        while (sortedIndex < n) {

            // 改动三，把比较和交换元素的步长设置为 h，而不是相邻元素

            for (int i = sortedIndex; i >= h; i -= h) {

                if (nums[i] < nums[i - h]) {

                    // swap(nums[i], nums[i - h])

                    int tmp = nums[i];

                    nums[i] = nums[i - h];

                    nums[i - h] = tmp;

                } else {

                    break;

                }

            }

            sortedIndex++;

        }

        // 按照递增函数的规则，缩小 h

        h /= 2;

    }

}
```

算法可视化

递增函数的选择是关键

希尔排序的性能和递增函数的选择有很大关系，上面的代码中我们使用的递增函数是 $2^{k-1}$ ，因为这是最简单的，但这并不最优的选择。

比方说《算法 4》 中给的递增函数是 $(3^k - 1)/2$ ，即 $1, 4, 13, 40, 121, 364...$ ，代码如下，主要修改 `h` 的初始化和更新逻辑：

```
// 把生成函数换成 (3^k - 1) / 2

// 即 h = 1, 4, 13, 40, 121, 364...

void sort(vector<int>& nums) {

    int n = nums.size();

    int h = 1;

    while (h < n / 3) {

        h = 3 * h + 1;

    }

    while (h >= 1) {

        int sortedIndex = h;

        while (sortedIndex < n) {

            for (int i = sortedIndex; i >= h; i -= h) {

                if (nums[i] < nums[i - h]) {

                    int tmp = nums[i];

                    nums[i] = nums[i - h];

                    nums[i - h] = tmp;

                } else {

                    break;

                }

            }

            sortedIndex++;

        }

        // 按照递增函数的规则，缩小 h

        h /= 3;

    }

}
```

算法可视化

递增函数 $(3^k - 1)/2$ 的效率要高于前面的 $2^{k-1}$ 。

你可以把这两个算法拿到力扣第 912 题「 [排序数组](https://leetcode.cn/problems/sort-an-array/) 」提交，它们都可以通过所有测试用例，但递增函数 $(3^k - 1)/2$ 的算法明显会更快。

## 排序稳定性

希尔排序是不稳定排序。

这个比较容易理解吧，当 `h` 大于 1 时进行的排序操作，就可能打乱相同元素的相对位置了。

## 时空复杂度分析

希尔排序的空间复杂度是 $O(1)$ ，是原地排序算法。

希尔排序的时间复杂度很难分析，主要取决于递增函数的选择，且涉及较多的数学知识，这里就不展开了，不过一个重要结论是： **希尔排序的时间复杂度是小于 $O(N^2)$ 的** 。

这一点可以直观感受出来，毕竟前面的 [选择排序](https://labuladong.online/zh/algo/data-structure-basic/select-sort/) 、 [冒泡排序](https://labuladong.online/zh/algo/data-structure-basic/bubble-sort/) 和 [插入排序](https://labuladong.online/zh/algo/data-structure-basic/insertion-sort/) 都过不了第 912 题的所有用例，而希尔排序可以。

建议把 $(3^k - 1)/2$ 作为递增函数来写希尔排序的代码，这种写法的效率相对较高。

好了，绕了一大圈，终于能够成功通过第 912 题「排序数组」了，有没有感觉到一些小激动？

从希尔排序开始，复杂度为 $O(n^2)$ 的初级排序算法就告一段落了，接下来的高级排序算法一个比一个能打，当然，也很难通过你自己独立推导出来了。

不过，这些高级排序算法的底层思想还是脱胎于基础数据结构和初级排序算法的，只要你把前面的内容稳扎稳打理解透彻，不需要死记硬背就能把它们随心运用出来了。

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表