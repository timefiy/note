---
title: 二叉堆核心原理及可视化
source: https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/
author:
  - "[[../../../../author/labuladong]]"
  - timefiy
published:
created: 2026-02-06
description: 二叉堆可以认为是一种特殊的二叉树，这棵二叉树上的任意节点的值，都必须大于等于（或小于等于）其左右子树所有节点的值。如果是大于等于，我们称之为「大顶堆」，如果是小于等于，我们称之为「小顶堆」。
tags:
  - clippings
  - 笔记
  - 二叉堆
  - 优先队列
  - 堆排序
---
# 二叉堆核心原理及可视化
前置知识

阅读本文前，你需要先学习：

- [二叉树基础及常见类型](../二叉树结构及遍历/二叉树基础及常见类型.md)
- [二叉树的递归/层序遍历](../二叉树结构及遍历/二叉树的递归层序遍历.md)

一句话总结

二叉堆是一种能够动态排序的数据结构，是 [二叉树结构](../二叉树结构及遍历/二叉树基础及常见类型.md) 的延伸。

二叉堆的主要操作就两个， `sink` （下沉）和 `swim` （上浮），用以维护二叉堆的性质。

二叉堆的主要应用有两个，首先是一种很有用的数据结构优先级队列（Priority Queue），第二是一种排序方法堆排序（Heap Sort）。

## 二叉堆的性质

二叉堆就是一种能够动态排序的数据结构。所谓动态排序，就是说我们可以不断往数据结构里面添加或删除元素，数据结构会自动调整元素的位置，使得我们可以有序地从数据结构中读取元素，这是一般的排序算法做不到的。

能动态排序的常用数据结构其实只有两个，一个是优先级队列（底层用二叉堆实现），另一个是二叉搜索树。二叉搜索树的用途更广泛，优先级队列能做的事情，二叉搜索树其实都能做。但优先级队列的 API 和代码实现相较于二叉搜索树更简单，所以一般能用优先级队列解决的问题，我们没必要用二叉搜索树。

二叉堆是怎么做到动态排序的呢？这就要说到二叉堆这种结构的性质了。

二叉堆的性质

- 你可以认为二叉堆是一种特殊的二叉树，==这棵二叉树上的任意节点的值，都必须大于等于（或小于等于）其左右 **子树所有节点** 的值。==如果是大于等于，我们称之为「大顶堆」，如果是小于等于，我们称之为「小顶堆」。

对于小顶堆，每个节点下方的所有节点的值都比它大，那么不难想象根节点就是整棵树上的最小值。同理，大顶堆的根节点就是整棵树上的最大值。所以二叉堆可以辅助我们快速找到最大值或最小值。

二叉堆还有个性质：一个二叉堆的左右子堆（子树）也是一个二叉堆。这个性质主要在 [堆排序算法的优化](../排序/二叉堆结构的运用：堆排序.md) 中有用到。

## 最常见的应用：优先级队列

其实上面的可视化面板展示的就是优先级队列，它主要有四个 API：

```cpp
class MyPriorityQueue {

public:

    // 在二叉堆堆顶插入一个元素，时间复杂度 O(logN)

    // N 为当前二叉堆中的元素个数

    void push(int x);

    // 返回堆顶元素，时间复杂度 O(1)

    // 该堆顶元素就是二叉堆中的最大值或最小值，取决于是最大堆还是最小堆

    int peek();

    // 删除堆顶元素，时间复杂度 O(logN)

    int pop();

    // 返回堆中元素的个数，时间复杂度 O(1)

    int size();

};
```

不同编程语言提供的 API 名字可能不同，但其效果和底层实现是大同小异的。

当然，自动排序是有代价的，注意优先级队列 API 的时间复杂度， **增删元素的复杂度是 $O(logN)$ ，其中 `N` 是当前二叉堆中的元素个数** ，回头在算法题里面用到这种结构的话，你得会计算总的时间复杂度。

为啥叫优先级「队列」？

有的读者可能会问，这明明就是二叉堆，为啥非要叫他优先级队列呢？

主要是因为这个数据结构的 API 和我们之前讲的 [标准队列 API](../队列和栈/队列栈基本原理.md) 很像，标准队列是先进先出的顺序，而二叉堆可以理解为一种会自动排序的队列，所以叫做优先级队列感觉也挺贴切的。

当然，你也一定要明白，虽然它的 API 像队列，但它的底层原理和二叉树有关，和队列没啥关系。

## 另一种应用：堆排序

这种排序算法其实不用专门去学的。它的原理特别简单，就相当于把一个乱序的数组都 `push` 到一个二叉堆（优先级队列）里面，然后再一个个 `pop` 出来，就得到了一个有序的数组：

```cpp
// 堆排序伪码，对 arr 原地排序

// 时间复杂度 O(NlogN)，空间复杂度 O(N)

vector<int> heapSort(vector<int>& arr) {

    vector<int> res(arr.size());

    MyPriorityQueue pq;

    for (int x : arr)

        pq.push(x);

    // 元素出堆的顺序是有序的

    for (int i = 0; i < arr.size(); i++)

        res[i] = pq.pop();

    return res;

}
```

当然，正常的堆排序算法的代码并不依赖优先级队列，且空间复杂度是 $O(1)$ 。那是因为它把 `push` 和 `pop` 的代码逻辑展开了，再加上直接在数组上原地建堆[^1]，这样就不需要额外的空间了。

但堆排序的本质还是依靠二叉堆的性质来排序元素，等我手把手带你实现优先级队列之后，你就可以自己实现堆排序了。

更新时间：2026/02/05 12:53

[^1]: **二叉堆是完全二叉树**，它的节点顺序非常规则。如果我们有一个数组 `arr`，我们可以直接定义：
	
	- **根节点**：`arr[0]`
	- **父节点 $i$ 的左孩子**：$2i + 1$
	- **父节点 $i$ 的右孩子**：$2i + 2$
	- **孩子节点 $j$ 的父节点**：$(j - 1) / 2$
