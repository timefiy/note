---
title: 回溯算法实践：括号生成
source: https://labuladong.online/zh/algo/practice-in-action/generate-parentheses/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文介绍如何利用回溯算法解决括号生成问题，解决力扣/LeetCode 上的 22 题，同时给出 Java/Python/Go/JavaScript/C++ 代码实现。
tags:
  - clippings
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [22\. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) | [22\. 括号生成](https://leetcode.cn/problems/generate-parentheses/) |  |

括号问题可以简单分成两类，一类是前文写过的 [括号的合法性判断](https://labuladong.online/zh/algo/problem-set/parentheses/) ，一类是合法括号的生成。对于括号合法性的判断，主要是借助「栈」这种数据结构，而对于括号的生成，一般都要利用 [回溯算法](https://labuladong.online/zh/algo/essential-technique/backtrack-framework/) 进行暴力穷举。

回到正题，看下力扣第 22 题「 [括号生成](https://leetcode.cn/problems/generate-parentheses/) 」，要求如下：

**22\. 括号生成** | [力扣](https://leetcode.cn/problems/generate-parentheses/) | [LeetCode](https://leetcode.com/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

**提示：**

- `1 <= n <= 8`

题目来源： [力扣 22. 括号生成](https://leetcode.cn/problems/generate-parentheses/) 。

函数签名如下：

```
vector<string> generateParenthesis(int n);
```

有关括号问题，你只要记住以下性质，思路就很容易想出来：

**1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解** 。

**2、对于一个「合法」的括号字符串组合 `p` ，必然对于任何 ` 0 <= i < len(p)` 都有：子串 `p[0..i]` 中左括号的数量都大于或等于右括号的数量** 。

如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

反之，比如这个括号组合 `))((`，前几个子串都是右括号多于左括号，显然不是合法的括号组合。

下面就来手把手实践一下回溯算法框架。

## 回溯思路

明白了合法括号的性质，如何把这道题和回溯算法扯上关系呢？

算法输入一个整数 `n` ，让你计算 **`n` 对儿括号** 能组成几种合法的括号组合，可以改写成如下问题：

**现在有 `2n` 个位置，每个位置可以放置字符 `(` 或者 `)` ，组成的所有括号组合中，有多少个是合法的** ？

这个命题和题目的意思完全是一样的对吧，那么我们先想想如何得到全部 `2^(2n)` 种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事儿了？

如何得到所有的组合呢？这就是标准的暴力穷举回溯框架啊，我们前文 [回溯算法套路框架详解](https://labuladong.online/zh/algo/essential-technique/backtrack-framework/) 都总结过了：

```
result = []

def backtrack(路径, 选择列表):

    if 满足结束条件:

        result.add(路径)

        return

    

    for 选择 in 选择列表:

        做选择

        backtrack(路径, 选择列表)

        撤销选择
```

那么对于我们的需求，如何打印所有括号组合呢？套一下框架就出来了，伪码如下：

```
#include <string>

#include <vector>

#include <iostream>

std::vector<std::string> track;

void print(const std::vector<std::string>& v) {

    for (const std::string& s : v) {

        std::cout << s;

    }

    std::cout << std::endl;

}

void backtrack(int n, int i) {

    // i 代表当前的位置，共 2n 个位置

    // 穷举到最后一个位置了，得到一个长度为 2n 组合

    if (i == 2 * n) {

        print(track);

        return;

    }

    // 对于每个位置可以是左括号或者右括号两种选择

    for (std::string choice : {"(", ")"}) {

        // 做选择

        track.push_back(choice);

        // 穷举下一个位置

        backtrack(n, i + 1); 

        // 撤销选择

        track.pop_back();

    }

}
```

那么，现在能够打印所有括号组合了，如何从它们中筛选出合法的括号组合呢？很简单，加几个条件进行「剪枝」就行了。

对于 `2n` 个位置，必然有 `n` 个左括号， `n` 个右括号，所以我们不是简单的记录穷举位置 `i` ，而是 **用 `left` 记录还可以使用多少个左括号，用 `right` 记录还可以使用多少个右括号** ，这样就可以通过刚才总结的合法括号规律进行筛选了：

```
class Solution {

private:

    // 回溯过程中的路径

    string track = "";

    // 记录所有合法的括号组合

    vector<string> res; 

public:

    vector<string> generateParenthesis(int n) {

        if (n == 0) return res;

        // 可用的左括号和右括号数量初始化为 n

        backtrack(n, n);

        return res;

    }

    // 可用的左括号数量为 left 个，可用的右括号数量为 right 个

    void backtrack(int left, int right) {

        // 若左括号剩下的多，说明不合法

        if (right < left) return;

        // 数量小于 0 肯定是不合法的

        if (left < 0 || right < 0) return;

        // 当所有括号都恰好用完时，得到一个合法的括号组合

        if (left == 0 && right == 0) {

            res.push_back(track);

            return;

        }

        // 做选择，尝试放一个左括号

        track.push_back('(');

        backtrack(left - 1, right);

        // 撤消选择

        track.pop_back();

        // 做选择，尝试放一个右括号

        track.push_back(')');

        backtrack(left, right - 1);

        // 撤销选择

        track.pop_back();

    }

};
```

算法可视化

这样，我们的算法就完成了，算法的复杂度是多少呢？这个比较难分析， **对于递归相关的算法，时间复杂度这样计算（递归次数）\*（递归函数本身的时间复杂度）** 。

`backtrack` 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 `n` ， `backtrack` 函数递归被调用了多少次？

我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。

所以说这里也可以用「状态」这个概念， **对于 `backtrack` 函数，状态有三个，分别是 `left, right, track`** ，这三个变量的所有组合个数就是 `backtrack` 函数的状态个数（调用次数）。

`left` 和 `right` 的组合好办，他俩取值就是 0 ~~n 嘛，组合起来也就 `n^2` 种而已；这个 `track` 的长度虽然取在 0~~ 2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的。

说了这么多，就是想让大家知道这个算法的复杂度是指数级，而且不好算，这里就不具体展开了，是 `4^n / sqrt(n)` ，有兴趣的读者可以搜索一下「卡特兰数」相关的知识了解一下这个复杂度是怎么算的。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表