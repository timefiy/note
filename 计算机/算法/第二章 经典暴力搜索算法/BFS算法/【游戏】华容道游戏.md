---
title: 【游戏】华容道游戏
source: https://labuladong.online/zh/algo/game/huarong-road/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本页面介绍了华容道游戏的基本玩法，并使用算法生成华容道游戏地图。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [BFS 算法框架](https://labuladong.online/zh/algo/essential-technique/bfs-framework/)

![Video Cover](https://labuladong.online/images/algo/vod/huarong-road.jpg)

华容道游戏

华容道游戏就是 [BFS 算法框架](https://labuladong.online/zh/algo/essential-technique/bfs-framework/) 中讲解的数字谜题问题的进阶版本，主要有以下几个不同：

1、数字谜题中，每个数字都占据一个格子，而华容道游戏中的每个棋子的形状和占据格子的数量不一样，曹操占据 4 个格子，五虎上将占据 2 个格子，小兵占据 1 个格子。

2、数字谜题仅要求我们记录完成游戏的最小步数，而这里的华容道没有要求步数最小，但是要求你记录具体操作步骤，这样才能调用 `gameHandler.move` 函数来操作棋盘，完成游戏。

我们可以用 BFS 算法对棋盘的所有移动进行穷举，同时使用额外的数据结构记录操作步骤，找到可行解后再调用 `gameHandler.move` 来操作棋盘，即可完成游戏。

游戏面板仅支持运行 JavaScript 代码，但是这道要求你实现的 `solveHuarongRoad` 函数求的是一个操作序列，不是游戏运行逻辑的一部分，所以我们可以变通一下，用任意编程语言实现算法，只要打印出类似这样的操作序列：

```
gameHandler.move(10, 'left')

gameHandler.move(9, 'right')

gameHandler.move(5, 'down')

...
```

然后把这个操作序列复制到游戏面板的 `solveHuarongRoad` 函数中，也可以完成游戏，检验算法是否正确。

## 讲解

基本思路和 [BFS 算法框架](https://labuladong.online/zh/algo/essential-technique/bfs-framework/) 中讲解的数字谜题一样，这里最关键的一个优化是： **要对形状相同的棋子做等价处理** 。

比方五虎上将中，只有关羽是 2x1 的棋子，其他四个武将都是 1x2 的棋子。在算法中，我们应该认为 4 个 1x2 的棋子是等价的。类似的，四个卒都占 1x1 的格子，在算法中也应该把它们看作是等价的。

这个等价本身也是合理的：我们只是为了方便辨识，所以给每个棋子都赋予了不同的名字/ID，但从算法的角度来看，形状相同的棋子之间并没有什么区别。

因为 BFS 算法中要对棋盘进行序列化，借助 `visited` 来保存穷举过的局面； **如果你把每个棋子都视为不同的，那么就很难遇到重复的局面；如果把形状相同的棋子视为等价的，就更容易遇到重复的局面，进行更有效的剪枝，大幅提升算法效率** 。

具体看代码吧：

```
#include <iostream>

#include <vector>

#include <queue>

#include <unordered_map>

#include <unordered_set>

#include <algorithm>

#include <string>

using namespace std;

// 棋盘尺寸

const int ROWS = 5, COLS = 4;

// 把 board 序列化成类别字符串，用于去重

string boardHash(const vector<vector<int>>& board) {

    // 重要优化：相同形状的棋子可以视为同一类棋子

    // 这样可以更有效地剪枝，大幅减少搜索空间

    unordered_map<int, char> pidToCategory;

    // 空位，0x0，分类 id 为 0

    pidToCategory[0] = '0';

    // 4 个卒分别占据 1x1，分类 id 为 1

    pidToCategory[7] = '1';

    pidToCategory[8] = '1';

    pidToCategory[9] = '1';

    pidToCategory[10] = '1';

    // 张飞、赵云、马超、黄忠都占据 1x2，分类 id 为 2

    pidToCategory[3] = '2';

    pidToCategory[4] = '2';

    pidToCategory[5] = '2';

    pidToCategory[6] = '2';

    // 关羽占据 2x1，分类 id 为 3

    pidToCategory[2] = '3';

    // 曹操占据 2x2，分类 id 为 4

    pidToCategory[1] = '4';

    // 把转化后的 board 序列化成字符串

    string sb;

    for (int r = 0; r < ROWS; r++) {

        for (int c = 0; c < COLS; c++) {

            sb += pidToCategory[board[r][c]];

        }

    }

    return sb;

}

// 收集每个棋子在棋盘上的所有坐标，返回: pid -> List of (r,c)

unordered_map<int, vector<pair<int, int>>> getPositions(const vector<vector<int>>& board) {

    unordered_map<int, vector<pair<int, int>>> pos;

    for (int r = 0; r < ROWS; r++) {

        for (int c = 0; c < COLS; c++) {

            int pid = board[r][c];

            if (pid != 0) {

                pos[pid].push_back({r, c});

            }

        }

    }

    return pos;

}

// 判断曹操(1)是否到达出口：左上角坐标为 (3,1)

bool isSolved(const vector<vector<int>>& board) {

    auto pos = getPositions(board);

    auto& cells = pos[1];

    int minR = INT_MAX, minC = INT_MAX;

    for (auto& p : cells) {

        minR = min(minR, p.first);

        minC = min(minC, p.second);

    }

    return minR == 3 && minC == 1;

}

// 判断一组 cells 能否整体平移 (dr,dc)：

bool canMove(const vector<vector<int>>& board, const vector<pair<int, int>>& cells, int dr, int dc) {

    int minR = INT_MAX, maxR = INT_MIN;

    int minC = INT_MAX, maxC = INT_MIN;

    for (auto& p : cells) {

        minR = min(minR, p.first);

        maxR = max(maxR, p.first);

        minC = min(minC, p.second);

        maxC = max(maxC, p.second);

    }

    // 移动后不能越界

    if (minR + dr < 0 || maxR + dr >= ROWS || minC + dc < 0 || maxC + dc >= COLS) {

        return false;

    }

    // 只能移动到空位上

    if (dr != 0) {

        int checkRow = dr < 0 ? minR + dr : maxR + dr;

        for (int c = minC; c <= maxC; c++) {

            if (board[checkRow][c] != 0) return false;

        }

    } else {

        int checkCol = dc < 0 ? minC + dc : maxC + dc;

        for (int r = minR; r <= maxR; r++) {

            if (board[r][checkCol] != 0) return false;

        }

    }

    return true;

}

// 将 pid 对应的 cells 平移 (dr,dc)，返回新棋盘。

vector<vector<int>> applyMove(const vector<vector<int>>& board, int pid, const vector<pair<int, int>>& cells, int dr, int dc) {

    vector<vector<int>> newb = board;

    // 清空旧位置

    for (auto& p : cells) {

        newb[p.first][p.second] = 0;

    }

    // 放置到新位置

    for (auto& p : cells) {

        newb[p.first + dr][p.second + dc] = pid;

    }

    return newb;

}

struct Move {

    int pid;

    string dir;

    Move(int pid, const string& dir) : pid(pid), dir(dir) {}

};

struct Pair {

    vector<vector<int>> board;

    vector<Move> path;

    Pair(const vector<vector<int>>& b, const vector<Move>& p) : board(b), path(p) {}

};

// BFS 求解华容道问题，并打印操作序列

void printHuarongRoadSolution(const vector<vector<int>>& board) {

    string startKey = boardHash(board);

    unordered_set<string> visited;

    visited.insert(startKey);

    queue<Pair> q;

    q.emplace(board, vector<Move>{});

    int steps = 1;

    vector<string> dirs = {"up", "down", "left", "right"};

    int drs[] = {-1, 1, 0, 0};

    int dcs[] = {0, 0, -1, 1};

    while (!q.empty()) {

        int levelCount = q.size();

        printf("BFS steps: %d, current level states count: %d\n", steps, levelCount);

        for (int i = 0; i < levelCount; i++) {

            Pair cur = q.front(); q.pop();

            auto& curBoard = cur.board;

            auto& curPath = cur.path;

            auto pidToPositions = getPositions(curBoard);

            for (auto& entry : pidToPositions) {

                int pid = entry.first;

                auto& cells = entry.second;

                for (int dirIdx = 0; dirIdx < 4; ++dirIdx) {

                    int dr = drs[dirIdx], dc = dcs[dirIdx];

                    string dirName = dirs[dirIdx];

                    if (!canMove(curBoard, cells, dr, dc)) continue;

                    vector<vector<int>> nextBoard = applyMove(curBoard, pid, cells, dr, dc);

                    string key = boardHash(nextBoard);

                    if (visited.count(key)) continue;

                    visited.insert(key);

                    vector<Move> newPath = curPath;

                    newPath.emplace_back(pid, dirName);

                    if (isSolved(nextBoard)) {

                        // 打印解的所有步骤

                        for (auto& m : newPath) {

                            printf("gameHandler.move(%d, '%s')\n", m.pid, m.dir.c_str());

                        }

                        return;

                    }

                    q.emplace(nextBoard, newPath);

                }

            }

        }

        steps++;

    }

    cout << "Cannot find a solution" << endl;

}

int main() {

    vector<vector<int>> initialBoard = {

        {3, 1, 1, 4},

        {3, 1, 1, 4},

        {5, 2, 2, 6},

        {5, 7, 8, 6},

        {9, 0, 0, 10}

    };

    printHuarongRoadSolution(initialBoard);

    return 0;

}
```

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表