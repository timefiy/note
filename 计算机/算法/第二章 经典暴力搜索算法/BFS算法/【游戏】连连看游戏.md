---
title: 【游戏】连连看游戏
source: https://labuladong.online/zh/algo/game/connect-two/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本页面介绍了连连看游戏的基本玩法，并使用算法来判断两个棋子是否可以相连。
tags:
  - clippings
---
连连看游戏可以消除成对儿的相同棋子，但是仅当两个棋子之间连线不超过两次拐弯时才能消除，如果超过两次拐弯则不能消除。

下面这个游戏要求你实现 `connect` 函数，输入棋盘 `board` 和用户点击的两个棋子的坐标 `row1, col1, row2, col2` ，请你判断这两个棋子是否可以相连。如果可以在两次拐弯内相连，则返回连接路径，否则返回空，具体要求请看题目：

连连看游戏

这道题的一般解法是 [BFS 算法](https://labuladong.online/zh/algo/essential-technique/bfs-framework/) ，但是和力扣上的算法题不同，连连看游戏中的场景更加复杂：

1、这里有一个「不超过两次拐弯」的限制。

2、要记录下连接两个棋子的具体路径。

3、连连看游戏中，棋盘边缘棋子的连接线可能超出棋盘边界。

请你先自己试一试，下面我会贴出参考解法。

## 讲解

这道题中，每走一步，需要维护的状态比较复杂，所以必须要用 [BFS 算法的第三种写法](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) ，即队列中的每个坐标要自行维护自己的状态。

队列中的每个元素是这样一个对象：

```
class State {

    // 当前坐标位置

    int row, col;

    // 当前的方向

    int dir;

    // 已经使用的拐弯次数

    int turns;

    // 已经走过的路径坐标

    List<int[]> path;

}
```

另外，这道题相当于二维数组中的 BFS 遍历，需要有一个 `visited` 集合记录已经访问过的坐标，避免走回头路陷入死循环。

在之前的 BFS 习题中，我们一般只需要把 `row, col` 记录到 `visited` 布尔数组中即可。而这道题中，每个坐标位置不仅仅有 `row, col` 两个状态，而是有 `row, col, dir, turns` 等多个状态，应该合并起来记录到 `visited` 中。

我这里的处理方式是把 `row, col, dir, turns` 组装成一个字符串，存到 `visited` 这个哈希集合中。当然你也可以把 `visited` 设计成四维的布尔数组，都是一样的。

另外请注意 `canPass` 函数对合法坐标的判断，对于连连看游戏的场景， `board` 外围的一圈格子也是合法的连线路径，所以要允许 `r` 和 `c` 越界。

下面的代码供你参考：

```
// 游戏面板仅支持提交 JavaScript 代码

// 其他语言代码的作用是帮助大家理解算法逻辑

#include <vector>

#include <queue>

#include <unordered_set>

#include <string>

struct Position {

    int row, col;

};

struct State {

    int row, col, turns, dir;

    std::vector<Position> path;

};

// canPass 判断 board[r][c] 是否是合法的连线的路径

// 注意这里允许 r 和 c 越界，因为连连看的连线允许超出 board 的边界

bool canPass(const std::vector<std::vector<int>>& board, int r, int c) {

    int m = board.size();

    int n = board[0].size();

    

    // 允许的边界范围为 r ∈ [-1,m] 且 c ∈ [-1,n]

    if (r < -1 || r > m || c < -1 || c > n) {

        return false;

    }

    // 仅 board 外围一圈上的格子可通行

    if ((r == -1 || r == m) && c >= 0 && c < n) {

        return true;

    }

    if ((c == -1 || c == n) && r >= 0 && r < m) {

        return true;

    }

    // 棋盘内的空格才可通行

    if (r >= 0 && r < m && c >= 0 && c < n && board[r][c] == 0) {

        return true;

    }

    return false;

}

std::vector<Position> connect(const std::vector<std::vector<int>>& board, int row1, int col1, int row2, int col2) {

    // 如果是同一个方块或方块值不同，不能连接

    if ((row1 == row2 && col1 == col2) || board[row1][col1] != board[row2][col2]) {

        return {};

    }

    // 使用BFS寻找最短路径

    // 队列中的每个元素包含：当前位置、已经拐弯的次数、当前方向、路径

    std::queue<State> queue;

    // 定义四个方向：上、右、下、左

    std::vector<std::vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

    // 记录已访问的状态（位置+方向+拐弯次数），避免重复搜索

    std::unordered_set<std::string> visited;

    // 将起点加入队列，起点没有特定方向，用-1表示

    queue.push({row1, col1, 0, -1, {{row1, col1}}});

    while (!queue.empty()) {

        State current = queue.front();

        queue.pop();

        // 向四个方向搜索

        for (int i = 0; i < 4; i++) {

            int dr = directions[i][0];

            int dc = directions[i][1];

            int newRow = current.row + dr;

            int newCol = current.col + dc;

            

            // 计算拐弯次数

            int newTurns;

            if (current.dir == -1 || current.dir == i) {

                // 如果是起点或者方向不变，则不需要拐弯

                newTurns = current.turns;

            } else {

                // 如果方向改变，则拐弯次数加 1

                newTurns = current.turns + 1;

            }

            // 超过两次拐弯，跳过

            if (newTurns > 2) {

                continue;

            }

            // 生成状态标识，避免重复搜索

            std::string key = std::to_string(newRow) + "," + std::to_string(newCol) + "," + std::to_string(i) + "," + std::to_string(newTurns);

            if (visited.count(key)) {

                continue;

            }

            visited.insert(key);

            // 到达终点

            if (newRow == row2 && newCol == col2) {

                std::vector<Position> newPath = current.path;

                newPath.push_back({newRow, newCol});

                return newPath;

            }

            

            // 检查(newRow, newCol) 是否可以作为连线路径

            if (!canPass(board, newRow, newCol)) {

                continue;

            }

            // 将新坐标加入队列

            std::vector<Position> newPath = current.path;

            newPath.push_back({newRow, newCol});

            queue.push({newRow, newCol, newTurns, i, newPath});

        }

    }

    // 找不到路径，说明两个点不可连接

    return {};

}
```

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表