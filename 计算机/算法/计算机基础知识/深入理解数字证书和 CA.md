---
title: 深入理解数字证书和 CA
source: https://labuladong.online/zh/algo/computer-science/certificate-and-ca/
author:
  - "[[../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上回溯算法算法的经典习题（第二部分），包含 labuladong 思路讲解和算法可视化，教会读者如何套用回溯算法代码框架。支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [非对称加密的使用场景](https://labuladong.online/zh/algo/computer-science/encryption-intro/)

在 [非对称加密的使用场景](https://labuladong.online/zh/algo/computer-science/encryption-intro/) 这篇文章中，我们学习了非对称加密的两大应用：

1. **加密通信** ：用公钥加密，用私钥解密，实现机密通信。
2. **数字签名** ：用私钥签名，用公钥验证，证明身份和数据完整性。

但是，非对称加密有一个关键问题没有解决： **你怎么确定拿到的公钥是真实可信的？**

## 公钥分发的信任问题

假设你要访问你的银行网站 `https://bank.com` ，银行的服务器会给你发送它的公钥，告诉你：

> 这是我的公钥，你可以用它加密数据发给我，我用私钥解密。

听起来没问题，但实际上有一个巨大的安全隐患： **中间人攻击（Man-in-the-Middle Attack）** 。

想象一下这个场景：

```
你的电脑 <---> 黑客的电脑 <---> 银行服务器
```

当你访问 `https://bank.com` 时，黑客劫持了你的网络请求：

1. 黑客拦截了银行发给你的真实公钥。
2. 黑客把自己的公钥伪装成银行公钥发给你。
3. 你用黑客的公钥加密了你的账号密码，发送出去。
4. 黑客用自己的私钥解密，窃取了你的账号密码。
5. 黑客再用银行的真实公钥加密，转发给银行服务器。

在这个过程中，你完全不知道自己正在和黑客通信，还以为在和银行通信。

**问题的核心在于：你无法确定收到的公钥确实属于银行，而不是黑客伪造的** 。

这就好比有人给你打电话说「我是银行客服」，你怎么确定对方真的是银行客服，而不是诈骗电话？

解决这个问题，就需要引入一个 **双方都信任的第三方** 来做担保，这个第三方就是 **证书颁发机构（Certificate Authority，简称 CA）** 。

## 什么是数字证书

**数字证书（Digital Certificate）就是由可信的第三方 CA 颁发的、用来证明公钥归属的电子文件** 。

继续用银行的例子来说明。

银行不会直接把公钥发给你，而是会先找一个权威的证书颁发机构（比如 DigiCert、Let's Encrypt 等），向 CA 申请一张数字证书。

CA 会对银行的身份进行严格的验证（比如验证银行的公司资质、域名所有权等），确认申请者确实是 `bank.com` 的合法所有者。

验证通过后，CA 会颁发一张数字证书，这张证书主要包含以下信息：

```
数字证书内容：

├─ 证书持有者：bank.com

├─ 证书持有者的公钥：AAABBB...（银行的公钥）

├─ 证书颁发者：DigiCert CA

├─ 证书有效期：2024-01-01 到 2025-01-01

├─ 证书用途：服务器身份验证

└─ CA 的数字签名：XXXYYY...（CA 用自己的私钥签名）
```

关键在于最后一项： **CA 的数字签名** 。

CA 会用自己的私钥对整张证书内容（包括银行的公钥、域名等信息）进行签名，生成一个数字签名附加在证书上。

这样一来，任何人拿到这张证书后，都可以用 CA 的公钥来验证签名，从而确认：

1. **这张证书确实是由 CA 颁发的** ，因为只有 CA 的私钥才能生成有效的签名。
2. **证书中的内容没有被篡改** ，任何修改都会导致签名验证失败。

现在，当你访问 `https://bank.com` 时，银行服务器会把这张数字证书发给你的浏览器。

你的浏览器会用 CA 的公钥验证证书上的签名，验证通过后，就可以确信：

- 这张证书确实是由可信的 CA 颁发的。
- 证书上的公钥确实属于 `bank.com` ，而不是黑客伪造的。

这样，中间人攻击就被防住了。即使黑客拦截了真实证书并伪造一张假证书，由于黑客没有 CA 的私钥，无法生成有效的签名，你的浏览器会立即发现证书不可信并拒绝连接。

## CA 的公钥从哪来？

你可能会问： **验证证书需要 CA 的公钥，那 CA 的公钥又怎么确保是真实可信的呢？通过网络中获取 CA 的公钥，也会遭到中间人攻击，这不是死循环了吗？**

这个问题问得非常好！这就涉及到 **根证书（Root Certificate）** 和 **信任链（Chain of Trust）** 的概念。

### 根证书

CA 的公钥也包含在一张数字证书中，这张证书叫做 **CA 证书** 。

但是，谁来为 CA 的证书签名呢？有两种情况：

1. **根 CA（Root CA）** ：位于信任链顶端的 CA，它的证书是 **自签名** 的（用自己的私钥给自己的证书签名），这种证书叫做 **根证书** 。
2. **中间 CA（Intermediate CA）** ：由根 CA 或其他中间 CA 签发证书的 CA，它的证书由上级 CA 签名。

那么，自签名的根证书凭什么可信？

答案是： **根证书是被预装在操作系统或浏览器中的** 。

你的 Windows、macOS、Linux 操作系统，以及 Chrome、Firefox 等浏览器，在出厂时都预装了一批全球权威 CA 的根证书。

这些根 CA 包括 DigiCert、Let's Encrypt 等等权威 CA 机构。

你可以在浏览器的设置中可以查看已安装的根证书，也可以在操作系统的证书管理工具中查看。这些根证书是由操作系统厂商和浏览器厂商经过严格审查后预装的。

**只要你信任你的操作系统和浏览器，就相当于信任了这些预装的根 CA，这就是整个信任体系的起点** 。

警告

不要在系统中安装未知来源的根证书，也不要使用非官方的浏览器或操作系统，否则很容易遭到中间人攻击。

### 证书信任链

实际应用中，一个 web 服务器的证书通常不是直接由根 CA 签发的，而是由 **中间 CA** 签发的。

这样就形成了一条 **证书链（Certificate Chain）** ：

```
根 CA 证书（自签名，预装在系统中）

   ↓ 签发

中间 CA 证书（由根 CA 签名）

   ↓ 签发

bank.com 服务器证书（由中间 CA 签名）
```

当你访问 `https://bank.com` 时，银行服务器会把完整的证书链发给你，其中包含：

```
1. bank.com 的服务器证书

   ├─ bank.com 的公钥

   └─ 中间 CA 的签名（由中间 CA 的公钥验证）

2. 中间 CA 的证书

   ├─ 中间 CA 的公钥

   └─ 根 CA 的签名（由本地预装的的根 CA 的公钥验证）
```

你的浏览器会按照以下步骤验证：

1. 从 **中间 CA 的证书** 中提取 **中间 CA 的公钥** ，用来验证 `bank.com` 服务器的证书。验证成功，则说明 `bank.com` 服务器的证书是由中间 CA 签发的。
2. 从 **本地系统预装的根证书** 中提取 **根 CA 的公钥** ，用来验证中间 CA 的证书。验证成功，则说明中间 CA 的证书是由根 CA 签发的。
3. 受信的根 CA 信任中间 CA，中间 CA 信任 `bank.com` 服务器，信任链形成，证明 `bank.com` 服务器是可信的。

这就是 **证书信任链的验证过程** 。只要链条中的每一环都能验证通过，最终又能追溯到系统预装的根 CA，那么这张服务器证书就是可信的。

得益于数字签名的防伪功能，对证书链中任何篡改都会导致签名验证失败，只要信任的源头（预装的根 CA）不被破坏，黑客就无法发起中间人攻击。

为什么不直接用根 CA 签发服务器证书？

你可能会疑惑：为什么要搞这么复杂，引入中间 CA？直接让根 CA 给所有服务器签发证书不行吗?

主要有几个原因：

1. **安全性** ：根 CA 的私钥非常重要，一旦泄露，整个信任体系就会崩溃。所以根 CA 的私钥通常被严格保护，甚至离线存储（即不联网的硬件设备）。如果根 CA 直接签发所有证书，私钥就需要频繁使用，泄露风险大大增加。
2. **灵活性** ：通过引入中间 CA，根 CA 可以将签发证书的工作委托给多个中间 CA，实现分布式管理。每个中间 CA 可以专注于不同的业务领域（比如企业证书、个人证书等）。
3. **吊销方便** ：如果某个中间 CA 出现问题（比如私钥泄露），只需要吊销这个中间 CA 的证书，不会影响整个根 CA 体系。

## HTTPS 如何使用证书

现在我们知道了数字证书和 CA 的作用，接下来看看 HTTPS 是如何利用证书建立安全连接的。

当你在浏览器中访问 `https://bank.com` 时，会经历以下步骤：

### 第 1 步：客户端发起请求

你的浏览器向 `bank.com` 发送一个 HTTPS 请求，要求服务器出示数字证书自证身份。

### 第 2 步：服务器返回证书

`bank.com` 的服务器收到请求后，会把自己的 **数字证书** （包含服务器公钥）和 **证书链** 一起发送给浏览器。

### 第 3 步：浏览器验证证书

浏览器收到证书后，会进行一系列严格的验证：

1. **验证证书链** ：按照前面讲的信任链逻辑，逐级验证签名，确保最终能追溯到系统预装的根 CA。
2. **验证证书有效期** ：检查证书是否在有效期内（没有过期或尚未生效）。
3. **验证域名匹配** ：检查证书上的域名是否与你正在访问的域名一致。比如证书上写的是 `bank.com` ，你访问的也必须是 `bank.com` ，不能是 `fake-bank.com` 。
4. **检查证书吊销状态** ：查询证书是否已被 CA 吊销（比如私钥泄露后，CA 会吊销该证书）。浏览器会通过 OCSP（在线证书状态协议）或 CRL（证书吊销列表）来检查。

如果以上任何一项验证失败，浏览器都会显示安全警告，阻止你继续访问。

如果所有验证都通过，浏览器就可以确信：

- 这张证书确实是由可信 CA 颁发的。
- 证书上的公钥确实属于 `bank.com` 。
- 你正在和真实的 `bank.com` 服务器通信，而不是黑客伪造的服务器。

### 第 4 步：利用公钥建立加密通信

在前面验证证书的过程中，公私钥主要用于 **数字签名** ，用来确认服务器的真实身份，防范中间人攻击。

现在服务器身份已经确认，而且浏览器又能从证书中获取 `bank.com` 服务器的公钥，就可以借助这个公钥建立 **加密通信** 了。

浏览器使用这个公钥加密通信数据，只有服务器才能用私钥解密，这就保证了它们之间通信无法被窃取。

提示

理论上公钥就可以直接加密通信数据，但是由于非对称加密的性能开销比较大，所以实际应用中会使用这个公钥加密一个对称性的秘钥（一个随机字符串）作为会话密钥，然后使用这个会话密钥进行加密通信。

这样技能保证通信的安全性，又能保证通信的效率。

## 常见问题

### CA 如何给服务器颁发证书？

CA 颁发证书的关键在于 **验证你确实拥有该域名的控制权** 。

以 Let's Encrypt 为例，它使用 **ACME 协议** 来自动验证域名所有权，常见的验证方式有：

- **HTTP 验证** ：在你的服务器上放置一个特定文件（如 `http://example.com/.well-known/acme-challenge/随机token` ），CA 访问这个 URL 来确认你控制该服务器。
- **DNS 验证** ：在域名的 DNS 记录中添加一个特定的 TXT 记录，CA 通过查询 DNS 来确认你控制该域名。

验证通过后，CA 就会签发证书，其中包含你的公钥、域名、有效期等信息，并附有 CA 的数字签名。

### 证书过期了会怎样？

如果服务器的证书过期了，浏览器会拒绝建立连接，并显示「证书已过期」的警告。

这时候网站管理员需要重新申请一张新证书，并部署到服务器上。

### 如果 CA 的私钥泄露了怎么办？

如果某个 CA 的私钥泄露了，黑客就可以伪造任意域名的证书。这是一个非常严重的安全事故。

发生这种情况后，操作系统和浏览器厂商会立即将该 CA 的根证书从信任列表中移除，并通过系统更新推送给用户。

历史上确实发生过几次 CA 安全事故，比如 2011 年荷兰 CA DigiNotar 被攻破，导致大量伪造证书流入市场，最终该 CA 的根证书被全球主流浏览器移除，公司破产倒闭。

### 中间人可以修改证书吗?

不能。证书内容（包括公钥、域名等）都被 CA 的数字签名保护，任何修改都会导致签名验证失败。

黑客唯一能做的就是 **完全替换证书** （比如用自己的自签名证书），但这会立即被浏览器识破并警告用户，因为黑客的证书不被任何根 CA 信任。

### 为什么有些网站显示「不安全」？

如果网站使用 HTTP 而不是 HTTPS，或者 HTTPS 证书有问题（过期、域名不匹配、自签名等），浏览器都会显示警告。

现代浏览器（Chrome、Firefox 等）会在地址栏明确标识网站是否使用了有效的 HTTPS 证书：

- 🔒 **锁形图标** ：证书有效，连接安全。
- ⚠️ **警告图标** ：证书有问题，连接可能不安全。
- ❗️ **不安全提示** ：使用 HTTP，通信内容完全明文传输。

## 总结

- **公钥分发的信任问题** ：无法确定公钥是否真实,可能遭受中间人攻击。
- **数字证书** ：由可信 CA 颁发，包含公钥、域名、有效期等信息，并附有 CA 的数字签名。
- **证书颁发机构（CA）** ：权威的第三方机构，负责验证身份并签发证书。
- **根证书和信任链** ：根 CA 的证书是自签名的，预装在操作系统和浏览器中。通过中间 CA 形成证书链，逐级验证签名。
- **HTTPS 验证流程** ：浏览器验证证书链、有效期、域名匹配、吊销状态，确认证书可信后建立加密连接。
- **自签名证书** ：只适合开发测试，生产环境应使用受信任的 CA（如 Let's Encrypt）签发的证书。

数字证书和 CA 是 HTTPS 安全的基石，它们通过信任链机制，解决了公钥分发的信任问题，使得我们可以在不安全的互联网上建立安全的通信。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表