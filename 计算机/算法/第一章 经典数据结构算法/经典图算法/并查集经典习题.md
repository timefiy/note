---
title: 并查集经典习题
source: https://labuladong.online/zh/algo/problem-set/union-find/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有 并查集/Union Find 算法的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [并查集（Union Find）算法详解](https://labuladong.online/zh/algo/data-structure/union-find/)

### 323\. 无向图中连通分量的数目

力扣第 323 题「 [无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/) 」就是最基本的连通分量题目：

给你输入一个包含 `n` 个节点的图，用一个整数 `n` 和一个数组 `edges` 表示，其中 `edges[i] = [ai, bi]` 表示图中节点 `ai` 和 `bi` 之间有一条边。请你计算这幅图的连通分量个数。

函数签名如下：

这道题我们可以直接套用 `UF` 类来解决：

### 130\. 被围绕的区域

一些使用 DFS/BFS 解决的问题，也可以用 Union-Find 算法解决。

比如力扣第 130 题「 [被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) 」：

给你一个 M×N 的二维矩阵，其中包含字符 `X` 和 `O` ，让你找到矩阵中 **四面** 被 `X` 围住的 `O` ，并且把它们替换成 `X` 。

注意哦，必须是四面被围的 `O` 才能被换成 `X` ，也就是说边角上的 `O` 一定不会被围，进一步，与边角上的 `O` 相连的 `O` 也不会被 `X` 围四面，也不会被替换。

![](https://labuladong.online/images/algo/unionfind-in-action/2.jpg)

Note

这让我想起小时候玩的棋类游戏「黑白棋」，只要你用两个棋子把对方的棋子夹在中间，对方的子就被替换成你的子。可见，占据四角的棋子是无敌的，与其相连的边棋子也是无敌的（无法被夹掉）。

其实这个问题应该归为 [岛屿系列问题](https://labuladong.online/zh/algo/frequency-interview/island-dfs-summary/) 使用 DFS 算法解决：

先用 for 循环遍历棋盘的 **四边** ，用 DFS 算法把那些与边界相连的 `O` 换成一个特殊字符，比如 `#` ；然后再遍历整个棋盘，把剩下的 `O` 换成 `X` ，把 `#` 恢复成 `O` 。这样就能完成题目的要求，时间复杂度 $O(MN)$ 。

但这个问题也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。

**你可以把那些不需要被替换的 `O` 看成一个拥有独门绝技的门派，它们有一个共同「祖师爷」叫 `dummy` ，这些 `O` 和 `dummy` 互相连通，而那些需要被替换的 `O` 与 `dummy` 不连通** 。

![](https://labuladong.online/images/algo/unionfind-in-action/3.jpg)

这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。

首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。

这个很简单，二维坐标 `(x,y)` 可以转换成 `x * n + y` 这个数（ `m` 是棋盘的行数， `n` 是棋盘的列数）， **敲黑板，这是将二维坐标映射到一维的常用技巧** 。

其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 `[0.. m*n-1]` 都是棋盘内坐标的一维映射，那就让这个虚拟的 `dummy` 节点占据索引 `m * n` 好了。

看解法代码：

这段代码很长，其实就是刚才的思路实现，只有和边界 `O` 相连的 `O` 才具有和 `dummy` 的连通性，他们不会被替换。

### 990\. 等式方程的可满足性

其实用 Union-Find 算法解决这个简单的问题有点杀鸡用牛刀，它可以解决更复杂，更具有技巧性的问题， **主要思路是适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系** 。

力扣第 990 题「 [等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/) 」用 Union-Find 算法就显得十分优美了，题目是这样：

给你一个数组 `equations` ，装着若干字符串表示的算式。每个算式 `equations[i]` 长度都是 4，而且只有这两种情况： `a==b` 或者 `a!=b` ，其中 `a,b` 可以是任意小写字母。你写一个算法，如果 `equations` 中所有算式都不会互相冲突，返回 true，否则返回 false。

比如说，输入 `["a==b","b!=c","c==a"]` ，算法返回 false，因为这三个算式不可能同时正确。

再比如，输入 `["c==c","b==d","x!=z"]` ，算法返回 true，因为这三个算式并不会造成逻辑冲突。

我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 `==` 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。

**核心思想是，将 `equations` 中的算式根据 `==` 和 `!=` 分成两部分，先处理 `==` 算式，使得他们通过相等关系各自勾结成门派（连通分量）；然后处理 `!=` 算式，检查不等关系是否破坏了相等关系的连通性** 。

至此，这道判断算式合法性的问题就解决了，借助 Union-Find 算法，是不是很简单呢？

另外，Union-Find 算法也会在一些其他经典图论算法中用到，比如判断「图」和「树」，以及最小生成树的计算，详情见 [Kruskal 最小生成树算法](https://labuladong.online/zh/algo/data-structure/kruskal/) 。

### 547\. 省份数量

**547\. 省份数量** | [力扣](https://leetcode.cn/problems/number-of-provinces/) | [LeetCode](https://leetcode.com/problems/number-of-provinces/)

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2020/12/24/graph1.jpg)
```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2020/12/24/graph2.jpg)
```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```

**提示：**

- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` 为 `1` 或 `0`
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`

题目来源： [力扣 547. 省份数量](https://leetcode.cn/problems/number-of-provinces/) 。

#### 基本思路

这题当然可以用 [BFS 算法](https://labuladong.online/zh/algo/essential-technique/bfs-framework/) 或者 [DFS 算法](https://labuladong.online/zh/algo/frequency-interview/island-dfs-summary/) 来解决，但这道题也是 [Union-Find 并查集](https://labuladong.online/zh/algo/data-structure/union-find/) 的经典应用场景，直接把我们在前文实现的 `UF` 类粘贴过来用就行了。

#### 解法代码

#### 算法可视化

算法可视化

### 1361\. 验证二叉树

**1361\. 验证二叉树** | [力扣](https://leetcode.cn/problems/validate-binary-tree-nodes/) | [LeetCode](https://leetcode.com/problems/validate-binary-tree-nodes/)

二叉树上有 `n`  个节点，按从  `0`  到 `n - 1`  编号，其中节点  `i`  的两个子节点分别是  `leftChild[i]` 和 `rightChild[i]` 。

只有 **所有** 节点能够形成且 **只** 形成 **一颗** 有效的二叉树时，返回 `true` ；否则返回 `false` 。

如果节点 `i`  没有左子节点，那么  `leftChild[i]` 就等于 `-1` 。右子节点也符合该规则。

注意：节点没有值，本问题中仅仅使用节点编号。

**示例 1：**

**![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/02/23/1503_ex1.png)**

```
输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
输出：true
```

**示例 2：**

**![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/02/23/1503_ex2.png)**

```
输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
输出：false
```

**示例 3：**

**![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/02/23/1503_ex3.png)**

```
输入：n = 2, leftChild = [1,0], rightChild = [-1,-1]
输出：false
```

**提示：**

- `n == leftChild.length == rightChild.length`
- `1 <= n <= 10<sup>4</sup>`
- `-1 <= leftChild[i], rightChild[i] <= n - 1`

题目来源： [力扣 1361. 验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/) 。

#### 基本思路

看到这道题我就想到 [261\. 以图判树](https://leetcode.cn/problems/graph-valid-tree/description/) ，你可以先去做这道题，理解树和图的关键区别之后再来做这道题。

我们解决 261 题的思路是用 [Union-Find 并查集算法](https://labuladong.online/zh/algo/data-structure/union-find/) ，但这道题的不同之处在于：

这里的每条边相当于是有方向的，而标准的并查集算法是处理无向图的，如果直接套用的话会出问题。

比如说，一个正常二叉树的节点不可能有两个入度（两个父节点），单纯的并查集算法只能检查是否成环，无法检查每个节点到底有多少入度。

不过我们可以用额外的代码来检查每个节点的入度是否合法，最后用并查集算法检测是否成环，从而判断二叉树是否合法。

除了并查集算法，我们还可以用二叉树的遍历函数来检查是否成环，两种思路我都写了解法代码，具体细节见代码注释。

#### 解法代码

#### 算法可视化

算法可视化

### 947\. 移除最多的同行或同列石头

**947\. 移除最多的同行或同列石头** | [力扣](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/) | [LeetCode](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/)

`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 `n` 的数组 `stones` ，其中 `stones[i] = [x<sub>i</sub>, y<sub>i</sub>]` 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。

**示例 1：**

```
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

**示例 2：**

```
输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
```

**示例 3：**

```
输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
```

**提示：**

- `1 <= stones.length <= 1000`
- `0 <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>`
- 不会有两块石头放在同一个坐标点上

题目来源： [力扣 947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/) 。

#### 基本思路

只要你看过前文 [Union-Find 算法详解](https://labuladong.online/zh/algo/data-structure/union-find/) ，这道题就很简单。

我们可以把每一块石头看做图中的一个节点，同一行的节点之间互相连通，同一列的节点之间也互相连通，这样，整幅图中就会有若干连通分量：

![](https://labuladong.online/images/algo/brief-extra/947.jpg)

按照题目消除石头的规则，最优消除的策略可以消除每个连通分量中的大部分石头，最终无论如何会剩下一个石头。

所以可以消除掉的石头个数就是石头总数和连通分量个数之差。具体解法看代码吧。

#### 解法代码

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论(1)

Markdown

Ctrl+Enter 发表

![赤城](https://thirdwx.qlogo.cn/mmopen/vi_32/55nGYbvmmP29htPm8mFRM2ldX11Y10MtO2m3cEiaUW6RPIXp9hvdhferme0WPHDtDKRzdSKkgzPXIoibgdWhuIZoCkZsM6Ea7ib5cAxic4fOCY8/132)

赤城 大约 1 个月前

这个代码感觉简单一点 但是最后一个超大测试用例超时了

```
public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {

        UF uf=new UF(n);

        for (int i=0;i<leftChild.length;i++){

            if (leftChild[i]!=-1){

                //uf.find(leftChild[i])!=leftChild[i]  一个节点只能当一次儿子 初始状态是自己是自己的儿子

                  //用来判断这个左子节点是否成为别人的儿子

                //uf.connected(i,leftChild[i]) 用来判断是否已经和自己是同一个父亲 如果是同一个父亲,则成环了

                if (uf.find(leftChild[i])!=leftChild[i]||uf.connected(i,leftChild[i])){

                    return false;

                }

                uf.union(i,leftChild[i]);

            }

            if (rightChild[i]!=-1){

                if (uf.find(rightChild[i])!=rightChild[i]||uf.connected(i,rightChild[i])){

                    return false;

                }

                uf.union(i,rightChild[i]);

            }

        }

        return uf.getCount()==1;

    }
```