---
title: 同时运用两种思维解题
source: https://labuladong.online/zh/algo/problem-set/binary-tree-combine-two-view/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有能够同时利用遍历和分解问题两种思维的二叉树经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [二叉树的遍历基础](https://labuladong.online/zh/algo/data-structure-basic/binary-tree-traverse-basic/)
- [二叉树心法（纲领篇）](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/)

有的题目可以同时用「遍历」和「分解问题」两种思路来解，你可以利用这些题目训练自己的思维。

### 559\. N 叉树的最大深度

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：3
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2019/11/08/sample_4_964.png)

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
```

**提示：**

- 树的深度不会超过 `1000` 。
- 树的节点数目位于 `[0, 10<sup>4</sup>]` 之间。

题目来源： [力扣 559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/) 。

#### 基本思路

前文 [手把手刷二叉树总结篇](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时使用两种思维模式，我把两种解法都写一下。

可以对照 [104\. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/) 题的解法。

#### 解法代码

```
// 分解问题的思路

class Solution {

public:

    int maxDepth(Node* root) {

        if (root == nullptr) {

            return 0;

        }

        int subTreeMaxDepth = 0;

        for (Node* child : root->children) {

            subTreeMaxDepth = std::max(subTreeMaxDepth, maxDepth(child));

        }

        return 1 + subTreeMaxDepth;

    }

};

// 遍历的思路

class Solution2 {

public:

    int maxDepth(Node* root) {

        traverse(root);

        return res;

    }

private:

    // 记录递归遍历到的深度

    int depth = 0;

    // 记录最大的深度

    int res = 0;

    void traverse(Node* root) {

        if (root == nullptr) {

            return;

        }

        // 前序遍历位置

        depth++;

        res = std::max(res, depth);

        for (Node* child : root->children) {

            traverse(child);

        }

        // 后序遍历位置

        depth--;

    }

};
```

#### 算法可视化

算法可视化

### 112\. 路径总和

**112\. 路径总和** | [力扣](https://leetcode.cn/problems/path-sum/) | [LeetCode](https://leetcode.com/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数  `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2021/01/18/pathsum1.jpg)
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2021/01/18/pathsum2.jpg)
```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

题目来源： [力扣 112. 路径总和](https://leetcode.cn/problems/path-sum/) 。

#### 基本思路

前文 [我的刷题经验总结](https://labuladong.online/zh/algo/essential-technique/algorithm-summary/) 说过，二叉树的遍历代码是动态规划和回溯算法的祖宗。

[动态规划](https://labuladong.online/zh/algo/essential-technique/dynamic-programming-framework/) 的关键在于明确递归函数的定义，把用子问题的结果推导出大问题的结果。

[回溯算法](https://labuladong.online/zh/algo/essential-technique/backtrack-framework/) 就简单粗暴多了，就是单纯的遍历回溯树。

下面给出两种思路下的解法，请仔细体会。

#### 解法代码

```
class Solution {

public:

    // 解法一、分解问题的思路

    // 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径

    bool hasPathSum(TreeNode* root, int targetSum) {

        // base case

        if (root == nullptr) {

            return false;

        }

        // root.left == root.right 等同于 root.left == null && root.right == null

        if (root->left == nullptr && root->right == nullptr && root->val == targetSum) {

            return true;

        }

        return hasPathSum(root->left, targetSum - root->val)

            || hasPathSum(root->right, targetSum - root->val);

    }

    // 解法二、遍历二叉树的思路

    int target;

    bool found = false;

    // 记录遍历过程中的路径和

    int curSum = 0;

    bool hasPathSum_2(TreeNode* root, int targetSum) {

        if (root == nullptr) {

            return false;

        }

        this->target = targetSum;

        traverse(root);

        return found;

    }

    // 二叉树遍历函数

    void traverse(TreeNode* root) {

        if (root == nullptr) {

            return;

        }

        // 前序遍历位置

        curSum += root->val;

        if (root->left == nullptr && root->right == nullptr) {

            if (curSum == target) {

                found = true;

            }

        }

        traverse(root->left);

        traverse(root->right);

        // 后序遍历位置

        curSum -= root->val;

    }

};
```

#### 算法可视化

算法可视化

### 113\. 路径总和 II

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2021/01/18/pathsumii1.jpg)
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2021/01/18/pathsum2.jpg)
```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

**提示：**

- 树中节点总数在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

题目来源： [力扣 113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) 。

#### 基本思路

前文 [手把手刷二叉树总结篇](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时运用两种思维。

遍历的思维很简单，只要遍历一遍二叉树，就可以把所有符合条件的路径找出来。为了维护经过的路径，在进入递归的时候要在 `path` 列表添加节点，结束递归的时候删除节点，类似 [回溯算法](https://labuladong.online/zh/algo/essential-technique/backtrack-framework/) 。

分解问题的思路也不难，你计算以 `root` 为根的二叉树中和为 `sum` 的路径，不就可以分解成计算以 `root.left, root.right` 为根的二叉树中所有和为 `sum - root.val` 的路径，然后再加上 `root` 节点吗？

我这里同时写出了遍历思路和分解问题思路的解法，供大家参考。

#### 解法代码

```
class Solution {

    vector<vector<int>> res;

public:

    vector<vector<int>> pathSum(TreeNode* root, int sum) {

        if (root == nullptr) return res;

        traverse(root, sum, vector<int>());

        return res;

    }

private:

    // 遍历二叉树

    void traverse(TreeNode* root, int sum, vector<int> path) {

        if (root == nullptr) return;

        int remain = sum - root->val;

        if (root->left == nullptr && root->right == nullptr) {

            if (remain == 0) {

                // 找到一条路径

                path.push_back(root->val);

                res.push_back(path);

                path.pop_back();

            }

            return;

        }

        // 维护路径列表

        path.push_back(root->val);

        traverse(root->left, remain, path);

        path.pop_back();

        path.push_back(root->val);

        traverse(root->right, remain, path);

        path.pop_back();

    }

};

// 分解问题的思维模式

class Solution2 {

public:

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> rootAnswers;

        if (root == nullptr) {

            return rootAnswers;

        }

        // 如果是叶子节点并且值等于 targetSum，则找到一条路径

        if (root->left == nullptr && root->right == nullptr && root->val == targetSum) {

            vector<int> path;

            path.push_back(root->val);

            rootAnswers.push_back(path);

            return rootAnswers;

        }

        // 分别递归左右子树，找到子树中和为 targetSum - root.val 的路径

        vector<vector<int>> leftAnswers = pathSum(root->left, targetSum - root->val);

        vector<vector<int>> rightAnswers = pathSum(root->right, targetSum - root->val);

        // 左右子树的路径加上根节点，就是和为 targetSum 的路径

        for (auto& answer : leftAnswers) {

            // 因为底层使用的是 LinkedList，所以这个操作的复杂度是 O(1)

            answer.insert(answer.begin(), root->val);

            rootAnswers.push_back(answer);

        }

        for (auto& answer : rightAnswers) {

            // 因为底层使用的是 LinkedList，所以这个操作的复杂度是 O(1)

            answer.insert(answer.begin(), root->val);

            rootAnswers.push_back(answer);

        }

        return rootAnswers;

    }

};
```

#### 算法可视化

算法可视化

### 617\. 合并二叉树

**617\. 合并二叉树** | [力扣](https://leetcode.cn/problems/merge-two-binary-trees/) | [LeetCode](https://leetcode.com/problems/merge-two-binary-trees/)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则， **不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2021/02/05/merge.jpg)
```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`

题目来源： [力扣 617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/) 。

#### 基本思路

前文 [手把手刷二叉树总结篇](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时用到两种思维模式。

虽然输入的是两棵树的根节点，但它们的操作是同步的，所以可以看做是在遍历 `root1` 这一棵二叉树，顺便把 `root2` 的节点合并过来。下面我给出两种思维模式的解法代码，具体看注释吧。

#### 解法代码

```
class Solution {

    // 分解问题的思维模式

    // 定义：输入两棵树的根节点，返回合并后的树的根节点

public:

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {

        // 如果一棵树非空，那么合并后就是另一棵树

        if (root1 == nullptr) {

            return root2;

        }

        if (root2 == nullptr) {

            return root1;

        }

        // 两棵树都有的节点，叠加节点值

        root1->val += root2->val;

        // 利用函数定义，子树合并后接到

        root1->left = mergeTrees(root1->left, root2->left);

        root1->right = mergeTrees(root1->right, root2->right);

        return root1;

    }

};

class Solution2 {

    // 遍历的思维模式

public:

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {

        if (root1 == nullptr) {

            return root2;

        }

        // 遍历 root1，顺便把 root2 的节点合并过来

        traverse(root1, root2);

        return root1;

    }

    void traverse(TreeNode* root1, TreeNode* root2) {

        if (root1 == nullptr || root2 == nullptr) {

            return;

        }

        if (root1 != nullptr && root2 != nullptr) {

            // 两棵树都有的节点，叠加节点值

            root1->val += root2->val;

        }

        // 如果 root1 没有子树而 root2 有，那么就把 root2 的子树接到 root1 上

        // 注意接完之后把 root2 的子树置为 null，免得错误计算节点累加值

        if (root1->left == nullptr && root2->left != nullptr) {

            root1->left = root2->left;

            root2->left = nullptr;

        }

        if (root1->right == nullptr && root2->right != nullptr) {

            root1->right = root2->right;

            root2->right = nullptr;

        }

        // 递归遍历左右子节点，root2 的节点也跟着同步移动

        traverse(root1->left, root2->left);

        traverse(root1->right, root2->right);

    }

};
```

#### 算法可视化

算法可视化

**897\. 递增顺序搜索树** | [力扣](https://leetcode.cn/problems/increasing-order-search-tree/) | [LeetCode](https://leetcode.com/problems/increasing-order-search-tree/)

给你一棵二叉搜索树的 `root` ，请你 **按中序遍历** 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2020/11/17/ex1.jpg)
```
输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2020/11/17/ex2.jpg)
```
输入：root = [5,1,7]
输出：[1,null,5,null,7]
```

**提示：**

- 树中节点数的取值范围是 `[1, 100]`
- `0 <= Node.val <= 1000`

题目来源： [力扣 897. 递增顺序搜索树](https://leetcode.cn/problems/increasing-order-search-tree/) 。

#### 基本思路

前文 [手把手刷二叉树总结篇](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时用到两种思维模式。

「遍历」的话很简单，你对 BST 做中序遍历，其结果就是有序的，重新构造出题目要求的这个类似链表的二叉树即可。

「分解问题」的思路也不难，你只要做过 [114\. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/) 这道题，稍微改下解法就可以解决这道题了，明确 `increasingBST` 的定义，然后利用这个定义进行操作即可。

这里我给出分解问题的解法思路。

#### 解法代码

```
class Solution {

public:

    // 输入一棵 BST，返回一个有序「链表」

    TreeNode* increasingBST(TreeNode* root) {

        if (root == nullptr) {

            return nullptr;

        }

        // 先把左右子树拉平

        TreeNode* left = increasingBST(root->left);

        root->left = nullptr;

        TreeNode* right = increasingBST(root->right);

        root->right = right;

        // 左子树为空的话，就不用处理了

        if (left == nullptr) {

            return root;

        }

        // 左子树非空，需要把根节点和右子树接到左子树末尾

        TreeNode* p = left;

        while (p->right != nullptr) {

            p = p->right;

        }

        p->right = root;

        return left;

    }

};
```

#### 算法可视化

### 938\. 二叉搜索树的范围和

**938\. 二叉搜索树的范围和** | [力扣](https://leetcode.cn/problems/range-sum-of-bst/) | [LeetCode](https://leetcode.com/problems/range-sum-of-bst/)

给定二叉搜索树的根结点 `root` ，返回值位于范围 *`[low, high]`* 之间的所有结点的值的和。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2020/11/05/bst1.jpg)
```
输入：root = [10,5,15,3,7,null,18], low = 7, high = 15
输出：32
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2020/11/05/bst2.jpg)
```
输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出：23
```

**提示：**

- 树中节点数目在范围 `[1, 2 * 10<sup>4</sup>]` 内
- `1 <= Node.val <= 10<sup>5</sup>`
- `1 <= low <= high <= 10<sup>5</sup>`
- 所有 `Node.val` **互不相同**

题目来源： [力扣 938. 二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/) 。

#### 基本思路

前文 [手把手刷二叉树总结篇](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时使用这两种思维模式。

遍历的思路就是单纯用 `traverse` 函数遍历一遍 BST，找到落在区间的元素。分解问题的思路关键是要明确函数定义，然后利用这个定义。

#### 解法代码

```
// 遍历的思路

class Solution {

    int sum = 0;

public:

    int rangeSumBST(TreeNode* root, int low, int high) {

        if (root == nullptr) return 0;

        // 遍历一遍 BST 计算区间元素和

        traverse(root, low, high);

        return sum;

    }

    void traverse(TreeNode* root, int low, int high) {

        if (root == nullptr) {

            return;

        }

        if (root->val < low) {

            // 目标区间在右子树

            traverse(root->right, low, high);

        } else if (root->val > high) {

            // 目标区间在左子树

            traverse(root->left, low, high);

        } else {

            // root.val 落在目标区间，累加 sum

            sum += root->val;

            // 继续遍历左右子树

            traverse(root->right, low, high);

            traverse(root->left, low, high);

        }

    }

};

// 分解问题的思路

class Solution2 {

public:

    // 定义：输入一个 BST，计算值落在 [low, high] 之间的元素之和

    int rangeSumBST(TreeNode* root, int low, int high) {

        if (root == nullptr) return 0;

        if (root->val < low) {

            // 目标区间在右子树

            return rangeSumBST(root->right, low, high);

        } else if (root->val > high) {

            // 目标区间在左子树

            return rangeSumBST(root->left, low, high);

        } else {

            // 以 root 为根的这棵 BST 落在 [low, high] 之间的元素之和，

            // 等于 root.val 加上左右子树落在区间的元素之和

            return root->val

                    + rangeSumBST(root->left, low, high)

                    + rangeSumBST(root->right, low, high);

        }

    }

};
```

#### 算法可视化

算法可视化

### 1379\. 找出克隆二叉树中的相同节点

**1379\. 找出克隆二叉树中的相同节点** | [力扣](https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/) | [LeetCode](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/)

给你两棵二叉树，原始树 `original` 和克隆树 `cloned` ，以及一个位于原始树 `original`  中的目标节点  `target` 。

其中，克隆树 `cloned`  是原始树 `original` 的一个 **副本** 。

请找出在树 `cloned`  中，与  `target` **相同** 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。

**注意：** 你 **不能** 对两棵二叉树，以及 `target` 节点进行更改。 **只能** 返回对克隆树 `cloned` 中已有的节点的引用。

**示例 1:**

![](https://labuladong.online/images/lc/uploads/2020/02/21/e1.png)

```
输入: tree = [7,4,3,null,null,6,19], target = 3
输出: 3
解释: 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。
```

**示例 2:**

![](https://labuladong.online/images/lc/uploads/2020/02/21/e2.png)

```
输入: tree = [7], target =  7
输出: 7
```

**示例 3:**

![](https://labuladong.online/images/lc/uploads/2020/02/21/e3.png)

```
输入: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
输出: 4
```

**提示：**

- 树中节点的数量范围为 `[1, 10<sup>4</sup>]` 。
- 同一棵树中，没有值相同的节点。
- `target`  节点是树  `original`  中的一个节点，并且不会是  `null` 。

**进阶：** 如果树中允许出现值相同的节点，将如何解答？

题目来源： [力扣 1379. 找出克隆二叉树中的相同节点](https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/) 。

#### 基本思路

前文 [手把手刷二叉树总结篇](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时用到两种思维。

说白了，这道题就是让你从一棵二叉树中搜索一个目标节点，考虑到题目的 follow up 问你节点的值存在重复的情况，所以用对比节点引用的方式进行比较。

#### 解法代码

```
// 遍历的思路

class Solution {

public:

    // 定义：找到 original 中 target 节点在 cloned 树中对应的节点

    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {

        this->target = target;

        traverse(original, cloned);

        return res;

    }

    TreeNode* target = nullptr, *res = nullptr;

    // 二叉树遍历函数

    void traverse(TreeNode* original, TreeNode* cloned) {

        if (original == nullptr || res != nullptr) {

            return;

        }

        if (original == target) {

            res = cloned;

            return;

        }

        // 二叉树遍历框架

        traverse(original->left, cloned->left);

        traverse(original->right, cloned->right);

    }

};

// 分解问题的思路

class Solution2 {

public:

    // 定义：找到 original 中 target 节点在 cloned 树中对应的节点

    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {

        if (original == nullptr) {

            return nullptr;

        }

        // 找到目标节点

        if (target == original) {

            return cloned;

        }

        // 去左子树找

        TreeNode* left = getTargetCopy(original->left, cloned->left, target);

        if (left != nullptr) {

            return left;

        }

        // 左子树找不到的话去右子树找

        return getTargetCopy(original->right, cloned->right, target);

    }

};
```

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表