---
title: 更多经典设计习题
source: https://labuladong.online/zh/algo/problem-set/ds-design/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有设计类算法的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [用链表加强哈希表](https://labuladong.online/zh/algo/data-structure-basic/hashtable-with-linked-list/)
- [用数组加强哈希表](https://labuladong.online/zh/algo/data-structure-basic/hashtable-with-array/)

设计类题目都是让你把基本数据结构进行组合，去解决某些具体场景中的问题。我们先来看几道比较简单但比较有意思的题目吧。

## 算法设计场景

### 729\. 我的日程安排表 I

实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的日程安排不会造成 **重复预订** ，则可以存储这个新的日程安排。

当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 **重复预订** 。

日程可以用一对整数 `start` 和 `end` 表示，这里的时间是半开区间，即 `[start, end)`, 实数 `x` 的范围为，   `start <= x < end` 。

实现 `MyCalendar` 类：

- `MyCalendar()` 初始化日历对象。
- `boolean book(int start, int end)` 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 `true` 。否则，返回 `false` 并且不要将该日程安排添加到日历中。

**示例：**

```
输入：
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
输出：
[null, true, false, true]

解释：
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。
myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。
```

**提示：**

- `0 <= start < end <= 10<sup>9</sup>`
- 每个测试用例，调用 `book` 方法的次数最多不超过 `1000` 次。

题目来源： [力扣 729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/) 。

#### 基本思路

这道题可以有两种思路，第一种思路是利用 [线段树结构](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) ，第二种思路是利用 [二叉搜索树（TreeMap）](https://labuladong.online/zh/algo/data-structure-basic/tree-map-basic/) 。

线段树的思路比较简单，可以创建一个计算区间最大值的线段树，每次 `book(start, end)` 之前先对区间 `[start, end)` 进行查询，如果这个区间内的元素最大值大于 0，说明这个区间内已经存在会议，返回 false，否则返回 true，然后对区间 `[start, end)` 的所有元素加一。

线段树结构对区间更新和查询的复杂度都是 `logN` ，所以 `book` 方法的复杂度就是 `logN` 。

可以直接使用 [懒更新线段树代码实现](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) 最后给出的 `AllInOneSegmentTree` 创建一个最大值线段树，完成这道题：

```
class MyCalendar {

    

    // 创建最大值线段树

    // 因为题目说数据规模为 10^9，所以需要开 10^9 的区间

    AllInOneSegmentTree st = new AllInOneSegmentTree(0, 1000000000, 0, "max");

    public boolean book(int start, int end) {

        if (st.query(start, end - 1) > 0) {

            // 区间最大值大于 0，说明这个区间内已经有一个会议了

            return false;

        }

        // 区间内没有会议，可以添加一个会议

        st.rangeAdd(start, end - 1, 1);

        return true;

    }

}
```

这道题也可以用基本的二叉搜索树结构（TreeMap）解决。什么情况下一个日程会有冲突？有两种情况：

1、之前的那个日程还没结束，这个日程就开始了。

2、这个日程还没结束的时候，下个日程就开始了。

在这里，我们用一个 [TreeMap](https://labuladong.online/zh/algo/data-structure-basic/tree-map-basic/) 存储每个日程，TreeMap 的键是日程的开始时间，值是日程的结束时间，这样就可以通过 `floorKey` 和 `ceilingKey` 方法判断上述两种情况是否发生了，具体看解法吧。

#### 解法代码

```
#include <map>

class MyCalendar {

    // 记录日程，键是日程的开始时间，值是日程的结束时间

    std::map<int, int> calendar;

public:

    MyCalendar() {

    }

    bool book(int start, int end) {

        auto earlier = calendar.lower_bound(start);

        if (earlier != calendar.end() && earlier->first < end) {

            // 本次日程还没结束，下个日程就开始了

            return false;

        }

        auto later = calendar.upper_bound(start);

        if (later != calendar.begin() && start < (--later)->second) {

            // 上个日程还没结束，本次日程就开始了

            return false;

        }

        // 成功安排日程

        calendar[start] = end;

        return true;

    }

};
```

#### 算法可视化

算法可视化

### 950\. 按递增顺序显示卡牌

**950\. 按递增顺序显示卡牌** | [力扣](https://leetcode.cn/problems/reveal-cards-in-increasing-order/) | [LeetCode](https://leetcode.com/problems/reveal-cards-in-increasing-order/)

牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。

最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。

现在，重复执行以下步骤，直到显示所有卡牌为止：

1. 从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。
2. 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。
3. 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。

返回能以 **递增顺序** 显示卡牌的牌组顺序。

答案中的第一张牌被认为处于牌堆顶部。

**示例：**

```
输入：[17,13,11,2,3,5,7]
输出：[2,13,3,11,5,17,7]
解释：
我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。
重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。
我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。
我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。
我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。
我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。
我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。
我们展示 13，然后将 17 移到底部。牌组现在是 [17]。
我们显示 17。
由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。
```

**提示：**

1. `1 <= A.length <= 1000`
2. `1 <= A[i] <= 10^6`
3. 对于所有的 `i != j` ， `A[i] != A[j]`

题目来源： [力扣 950. 按递增顺序显示卡牌](https://leetcode.cn/problems/reveal-cards-in-increasing-order/) 。

#### 基本思路

对于这道题，我首先想到的是找规律，乍一看感觉把 `deck` 排序，然后按照奇数位、偶数位递增排列好像就是答案。但仔细看下没这么简单，因为随着翻牌过程的推进，每张牌的位置规律就不是简单的奇偶能表示的了。

**那么进一步的想法就是模拟这个翻牌的逆过程** ，题目给的翻牌过程如下：

你精心设计好牌堆 `res` 的顺序，翻开 `res` 顶部的那张牌放到牌堆 `sorted` 顶部，然后把 `res` 的下一张牌放到 `res` 最底下，不断重复，最终的 `sorted` 的点数是递增的。

你想一下这个翻牌的逆过程：

现在有一个点数 **递减** 的牌堆 `sorted` ，你先把牌堆 `res` 中最底部的那张牌（如果有的话）放到 `res` 的顶部，然后拿出 `sorted` 顶部的牌，放到 `res` 顶部，不断重复，直到 `sorted` 为空，此时 `res` 的顺序即为答案。

写代码模拟这个逆过程即可得到答案。

#### 解法代码

```
#include <vector>

#include <algorithm>

#include <deque>

class Solution {

public:

    std::vector<int> deckRevealedIncreasing(std::vector<int>& deck) {

        int n = deck.size();

        // 链表头部代表牌堆顶，尾部代表牌堆底

        std::deque<int> res;

        // 升序排列，然后从倒着遍历，就是点数递减

        std::sort(deck.begin(), deck.end());

        for (int i = n - 1; i >= 0; i--) {

            if (!res.empty()) {

                res.push_front(res.back());

                res.pop_back();

            }

            res.push_front(deck[i]);

        }

        

        // 将双链表转化成 Java 的数组

        return std::vector<int>(res.begin(), res.end()); // Note: This line converts the deque to a vector, the equivalent in C++ to a Java array.

    }

};
```

#### 算法可视化

算法可视化

### 1700\. 无法吃午餐的学生数量

**1700\. 无法吃午餐的学生数量** | [力扣](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/) | [LeetCode](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/)

学校的自助午餐提供圆形和方形的三明治，分别用数字 `0`  和  `1` 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。  
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 **栈** 里，每一轮：

- 如果队列最前面的学生 **喜欢** 栈顶的三明治，那么会 **拿走它** 并离开队列。
- 否则，这名学生会 **放弃这个三明治** 并回到队列的尾部。

这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。

给你两个整数数组 `students` 和  `sandwiches`  ，其中  `sandwiches[i]` 是栈里面第 `i<sup>​​​​​​</sup>` 个三明治的类型（ `i = 0`  是栈的顶部），  `students[j]` 是初始队列里第 `j<sup>​​​​​​</sup>` 名学生对三明治的喜好（ `j = 0` 是队列的最开始位置）。请你返回无法吃午餐的学生数量。

**示例 1：**

```
输入：students = [1,1,0,0], sandwiches = [0,1,0,1]
输出：0 
解释：
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。
所以所有学生都有三明治吃。
```

**示例 2：**

```
输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
输出：3
```

**提示：**

- `1 <= students.length, sandwiches.length <= 100`
- `students.length == sandwiches.length`
- `sandwiches[i]` 要么是 `0`  ，要么是  `1` 。
- `students[i]` 要么是 `0`  ，要么是  `1` 。

题目来源： [力扣 1700. 无法吃午餐的学生数量](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/) 。

#### 基本思路

因为学生队伍可以循环，所以理论上栈顶的那个三明治可以被所有（剩下还没吃饭的）学生挑选。

所以，当剩下的学生都不想要最上面的三明治的时候，就进入死循环，他们都吃不上饭了。即以下情况：

1、剩下的所有学生都想吃 `1` ，但栈顶是 `0` 。

2、剩下的所有学生都想吃 `0` ，但栈顶是 `1` 。

所以我们先统计所有学生对 `0` 和 `1` 的需求，然后顺序遍历三明治栈的顺序，即可得知以上两种可能是否会发生。

#### 解法代码

```
class Solution {

public:

    int countStudents(vector<int>& students, vector<int>& sandwiches) {

        // studentCount[0 or 1] 分别代表吃 0 和吃 1的学生数量

        int studentCount[2] = {0, 0};

        for (int type : students) {

            studentCount[type]++;

        }

        // 遍历三明治栈，若栈顶的三明治无法被取走，则剩下的人都吃不上了

        for (int type : sandwiches) {

            if (studentCount[type] == 0) {

                // 两种喜好加起来就是剩下的学生数量

                return studentCount[0] + studentCount[1];

            }

            studentCount[type]--;

        }

        return 0;

    }

};
```

#### 算法可视化

算法可视化

### 155\. 最小栈

**155\. 最小栈** | [力扣](https://leetcode.cn/problems/min-stack/) | [LeetCode](https://leetcode.com/problems/min-stack/)

设计一个支持 `push` ， `pop` ， `top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `-2<sup>31</sup> <= val <= 2<sup>31</sup> - 1`
- `pop` 、 `top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and  `getMin` 最多被调用  `3 * 10<sup>4</sup>` 次

题目来源： [力扣 155. 最小栈](https://leetcode.cn/problems/min-stack/) 。

#### 基本思路

[根据我们之前亲自动手实现的栈](https://labuladong.online/zh/algo/data-structure-basic/queue-stack-basic/) ，我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 `getMin` 方法，只能老老实实把所有元素弹出来然后找最小值。 **想提高时间效率，那肯定要通过空间换时间的思路** 。

不过在具体说解法之前，我想聊一下动态集合中维护最值的问题。这类问题看似简单，但实际上是个很棘手的问题。其实本题就是如下一个场景：

假设你有若干数字，你用一个 `min` 变量维护了其中的最小值，如果现在给这些数字中添加一个新数字，那么只要比较这个新数字和 `min` 的大小就可以得出最新的最小值。但如果现在从这些数字钟删除一个数字，你还能用 `min` 变量得到最小值吗？答案是不能，因为如果这个被删除的数字恰好是最小值，那么新的 `min` 变量应该更新为第二小的元素对吧，但是我没有记录第二小的元素是多少，所以只能把所有数字重新遍历一遍。

明确了难点再回到本题，就可以对症下药了。删除栈顶元素的时候，不确定新的最小值是多少，但楼下那哥们知道啊，他当时入栈时的最小值，就是现在的最小值呗。

所以这道题的关键就是， **每个元素入栈时，还要记下来当前栈中的最小值** 。比方说，可以用一个额外的栈 `minStk` 来记录栈中每个元素入栈时的栈中的最小元素是多少，这样每次删除元素时就能快速得到剩余栈中的最小元素了。

![](https://labuladong.online/images/algo/brief-extra/155.jpeg)

当然，我们还可以做一些优化，减少 `minStk` 中存储的元素个数，我把原始解法和优化解法都写出来了，供参考。

> PS：这道题并不难，但我还是很细致地分析了，希望你深刻理解其中的难点。下一步可以做一下 [239\. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/) ，请仔细观察和思考，队列结构是如何解决这个难点的。

#### 解法代码

```
// 原始思路

class MinStack1 {

    // 记录栈中的所有元素

    stack<int> stk;

    // 阶段性记录栈中的最小元素

    stack<int> minStk;

public:

    void push(int val) {

        stk.push(val);

        // 维护 minStk 栈顶为全栈最小元素

        if (minStk.empty() || val <= minStk.top()) {

            // 新插入的这个元素就是全栈最小的

            minStk.push(val);

        } else {

            // 插入的这个元素比较大

            minStk.push(minStk.top());

        }

    }

    

    void pop() {

        stk.pop();

        minStk.pop();

    }

    

    int top() {

        return stk.top();

    }

    

    int getMin() {

        // minStk 栈顶为全栈最小元素

        return minStk.top();

    }

};

// 优化版

class MinStack {

    // 记录栈中的所有元素

    stack<int> stk;

    // 阶段性记录栈中的最小元素

    stack<int> minStk;

public:

    void push(int val) {

        stk.push(val);

        // 维护 minStk 栈顶为全栈最小元素

        if (minStk.empty() || val <= minStk.top()) {

            // 新插入的这个元素就是全栈最小的

            minStk.push(val);

        }

    }

    void pop() {

        // 注意 Java 的语言特性，比较 Integer 相等要用 equals 方法

        if (stk.top() == minStk.top()) {

            // 弹出的元素是全栈最小的

            minStk.pop();

        }

        stk.pop();

    }

    int top() {

        return stk.top();

    }

    int getMin() {

        // minStk 栈顶为全栈最小元素

        return minStk.top();

    }

};
```

#### 算法可视化

算法可视化

### 1670\. 设计前中后队列

**1670\. 设计前中后队列** | [力扣](https://leetcode.cn/problems/design-front-middle-back-queue/) | [LeetCode](https://leetcode.com/problems/design-front-middle-back-queue/)

请你设计一个队列，支持在前，中，后三个位置的 `push`  和 `pop` 操作。

请你完成 `FrontMiddleBack` 类：

- `FrontMiddleBack()` 初始化队列。
- `void pushFront(int val)` 将 `val` 添加到队列的 **最前面** 。
- `void pushMiddle(int val)` 将 `val` 添加到队列的 **正中间** 。
- `void pushBack(int val)` 将 `val` 添加到队里的 **最后面** 。
- `int popFront()` 将 **最前面** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。
- `int popMiddle()` 将 **正中间** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。
- `int popBack()` 将 **最后面** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。

请注意当有 **两个** 中间位置的时候，选择靠前面的位置进行操作。比方说：

- 将 `6` 添加到 `[1, 2, 3, 4, 5]` 的中间位置，结果数组为 `[1, 2, **6**, 3, 4, 5]` 。
- 从 `[1, 2, **3**, 4, 5, 6]` 的中间位置弹出元素，返回 `3` ，数组变为 `[1, 2, 4, 5, 6]` 。

**示例 1：**

```
输入：
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
输出：
[null, null, null, null, null, 1, 3, 4, 2, -1]

解释：
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // 返回 1 -> [4, 3, 2]
q.popMiddle();    // 返回 3 -> [4, 2]
q.popMiddle();    // 返回 4 -> [2]
q.popBack();      // 返回 2 -> []
q.popFront();     // 返回 -1 -> [] （队列为空）
```

**提示：**

- `1 <= val <= 10<sup>9</sup>`
- 最多调用 `1000`  次  `pushFront` ，  `pushMiddle` ，  `pushBack` ，  `popFront` ，  `popMiddle`  和  `popBack` 。

题目来源： [力扣 1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/) 。

#### 基本思路

这题有点难度，主要是细节不好把控。常规的队列只能在首尾进行操作，想在中间操作队列，需要在底层把队列切分成 `left, right` 两个列表，但这里的细节问题就是元素为奇数时两个链表中元素的分配问题。

直接看代码吧，注释很详细。

#### 解法代码

```
class FrontMiddleBackQueue {

    // 用两个列表表示队列的左右两部分，以便从中间操作元素

    deque<int> left;

    deque<int> right;

    // 如果是奇数个元素，维护左边少右边多，所以：

    // 1、如果有偶数个元素时，pushMiddle 优先向右边添加

    // 2、如果有奇数个元素时，popMiddle 优先从右边删除

    // 3、如果只有 1 个元素，popFront 的时候，要去右边删除

    // 要把以上三个特点写到代码里，才能保证细节不出错

    // 维护左边少右边多的状态，每次增删元素之后都要执行一次

    void balance() {

        // 右边最多比左边多一个元素

        if (right.size() > left.size() + 1) {

            // 右边多，匀一个给左边

            left.push_back(right.front());

            right.pop_front();

        }

        if (left.size() > right.size()) {

            // 左边多，匀一个给右边

            right.push_front(left.back());

            left.pop_back();

        }

    }

public:

    void pushFront(int val) {

        left.push_front(val);

        balance();

    }

    void pushMiddle(int val) {

        if (size() % 2 == 0) {

            // 如果有偶数个元素时，pushMiddle 优先向右边添加

            right.push_front(val);

        } else {

            left.push_back(val);

        }

        balance();

    }

    void pushBack(int val) {

        right.push_back(val);

        balance();

    }

    int popFront() {

        if (size() == 0) {

            return -1;

        }

        if (size() == 1) {

            // 如果只有 1 个元素，popFront 的时候，要去右边删除

            int e = right.front();

            right.pop_front();

            return e;

        }

        int e = left.front();

        left.pop_front();

        balance();

        return e;

    }

    int popMiddle() {

        if (size() == 0) {

            return -1;

        }

        int e;

        if (size() % 2 == 0) {

            e = left.back();

            left.pop_back();

        } else {

            // 如果有奇数个元素时，popMiddle 优先从右边删除

            e = right.front();

            right.pop_front();

        }

        balance();

        return e;

    }

    int popBack() {

        if (size() == 0) {

            return -1;

        }

        int e = right.back();

        right.pop_back();

        balance();

        return e;

    }

    int size() {

        return left.size() + right.size();

    }

};
```

#### 算法可视化

算法可视化

### 895\. 最大频率栈

**895\. 最大频率栈** | [力扣](https://leetcode.cn/problems/maximum-frequency-stack/) | [LeetCode](https://leetcode.com/problems/maximum-frequency-stack/)

设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出 **出现频率** 最高的元素。

实现 `FreqStack` 类:

- `FreqStack()` 构造一个空的堆栈。
- `void push(int val)` 将一个整数 `val` 压入栈顶。
- `int pop()` 删除并返回堆栈中出现频率最高的元素。
	- 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。

**示例 1：**

```
输入：
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
```

**提示：**

- `0 <= val <= 10<sup>9</sup>`
- `push`  和 `pop`  的操作数不大于 `2 * 10<sup>4</sup>` 。
- 输入保证在调用 `pop` 之前堆栈中至少有一个元素。

题目来源： [力扣 895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/) 。

#### 基本思路

**这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API** 。

那么，我们仔细思考一下 `push` 和 `pop` 方法，难点如下：

1、每次 `pop` 时，必须要知道频率最高的元素是什么。

2、如果频率最高的元素有多个，还得知道哪个是最近 `push` 进来的元素是哪个。

为了实现上述难点，我们要做到以下几点：

1、肯定要有一个变量 `maxFreq` 记录当前栈中最高的频率是多少。

2、我们得知道一个频率 `freq` 对应的元素有哪些，且这些元素要有时间顺序。

3、随着 `pop` 的调用，每个 `val` 对应的频率会变化，所以还得维持一个映射记录每个 `val` 对应的 `freq` 。

综上，我们可以先实现 `FreqStack` 所需的数据结构：

```
class FreqStack {

    // 记录 FreqStack 中元素的最大频率

    int maxFreq = 0;

    // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表

    HashMap<Integer, Integer> valToFreq = new HashMap<>();

    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表

    HashMap<Integer, Stack<Integer>> freqToVals = new HashMap<>();

}
```

其实这有点类似前文 [手把手实现 LFU 算法](https://labuladong.online/zh/algo/frequency-interview/lfu/) ，注意 `freqToVals` 中 `val` 列表用一个栈实现，如果一个 `freq` 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。

具体看解法代码吧，要记住在 `push` 和 `pop` 方法中同时修改 `maxFreq` 、 `VF` 表、 `FV` 表，否则容易出现 bug。

算法执行过程如下 GIF 所示：

![](https://labuladong.online/images/algo/freq-stack/1.gif)

#### 解法代码

```
#include <unordered_map>

#include <stack>

using namespace std;

class FreqStack {

    // 记录 FreqStack 中元素的最大频率

    int maxFreq = 0;

    // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表

    unordered_map<int, int> valToFreq;

    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表

    unordered_map<int, stack<int>> freqToVals;

public:

    void push(int val) {

        // 修改 VF 表：val 对应的 freq 加一

        int freq = valToFreq.count(val) ? valToFreq[val] + 1 : 1;

        valToFreq[val] = freq;

        // 修改 FV 表：在 freq 对应的列表加上 val

        freqToVals[freq].push(val);

        // 更新 maxFreq

        maxFreq = max(maxFreq, freq);

    }

    int pop() {

        // 修改 FV 表：pop 出一个 maxFreq 对应的元素 v

        int v = freqToVals[maxFreq].top();

        freqToVals[maxFreq].pop();

        // 修改 VF 表：v 对应的 freq 减一

        valToFreq[v]--;

        // 更新 maxFreq

        if (freqToVals[maxFreq].empty()) {

            // 如果 maxFreq 对应的元素空了

            maxFreq--;

        }

        return v;

    }

};
```

#### 算法可视化

算法可视化

## 设计迭代器

Tip

设计迭代器也是一类常见题目。

### 284\. 窥视迭代器

**284\. 窥视迭代器** | [力扣](https://leetcode.cn/problems/peeking-iterator/) | [LeetCode](https://leetcode.com/problems/peeking-iterator/)

请你在设计一个迭代器，在集成现有迭代器拥有的 `hasNext` 和 `next` 操作的基础上，还额外支持 `peek` 操作。

实现 `PeekingIterator` 类：

- `PeekingIterator(Iterator<int> nums)` 使用指定整数迭代器 `nums` 初始化迭代器。
- `int next()` 返回数组中的下一个元素，并将指针移动到下个元素处。
- `bool hasNext()` 如果数组中存在下一个元素，返回 `true` ；否则，返回 `false` 。
- `int peek()` 返回数组中的下一个元素，但 **不** 移动指针。

**注意：** 每种语言可能有不同的构造函数和迭代器 `Iterator` ，但均支持 `int next()` 和 `boolean hasNext()` 函数。

**示例 1：**

```
输入：
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
输出：
[null, 1, 2, 2, 3, false]

解释：
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]
peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]
peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]
peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]
peekingIterator.hasNext(); // 返回 False
```

**提示：**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 1000`
- 对 `next` 和 `peek` 的调用均有效
- `next` 、 `hasNext` 和 `peek ` 最多调用 `1000` 次

**进阶：** 你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？

题目来源： [力扣 284. 窥视迭代器](https://leetcode.cn/problems/peeking-iterator/) 。

#### 基本思路

这个题需要你了解「迭代器」的接口特性，用 Java 来做比较好，建议你先做下 [251\. 展开二维向量](https://leetcode.cn/problems/flatten-2d-vector/description/) 了解下迭代器是什么。

你看构造函数的入参是 `Iterator<Integer>` 类型，就是说输入一个装 `Integer` 的迭代器，且你只能调用 `hasNext` 方法判断迭代器内是否还有元素和 `next` 方法从迭代器中拿出下一个元素。

这道题的关键是让你额外实现一个 `peek` 方法，这个 `peek` 返回迭代器中的下一个元素，但不能删除这个元素。注意 `next` 方法是返回 **并删除** 迭代器中的下一个元素。

所以我们可以把迭代器的第一个元素缓存起来，以实现 `peek` 方法，直接看代码吧。

#### 解法代码

```
class PeekingIterator : public Iterator {

private:

    // 标记是否还有下一个元素

    bool hasNextFlag;

    // 缓存下一个元素

    int nextElem;

    // 迭代器

    Iterator* iter;

public:

    PeekingIterator(const vector<int>& nums) : Iterator(nums) {

        iter = new Iterator(nums);

        // 把迭代器的下一个元素提前拿出来并缓存起来

        int next = iter->next();

        nextElem = next;

        hasNextFlag = true;

    }

    

    int peek() {

        return nextElem;

    }

    

    int next() {

        int res = nextElem;

        // 更新 nextElem

        if (iter->hasNext()) {

            nextElem = iter->next();

        } else {

            hasNextFlag = false;

        }

        return res;

    }

    

    bool hasNext() const {

        return hasNextFlag;

    }

};
```

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表