---
title: 拓展：惰性展开多叉树
source: https://labuladong.online/zh/algo/data-structure/flatten-nested-list-iterator/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文讲解如何利用栈和递归解决扁平化嵌套列表问题，解决力扣/LeetCode 上的 341 题，同时给出 Java/Python/Go/JavaScript/C++ 代码实现。
tags:
  - clippings
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [341\. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/) | [341\. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/) |  |

今天来讲一道非常有启发性的设计题目，为什么说它有启发性，我们后面再说。

## 一、题目描述

这是力扣第 341 题「 [扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/) 」：

**341\. 扁平化嵌套列表迭代器** | [力扣](https://leetcode.cn/problems/flatten-nested-list-iterator/) | [LeetCode](https://leetcode.com/problems/flatten-nested-list-iterator/)

给你一个嵌套的整数列表 `nestedList` 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。

实现扁平迭代器类 `NestedIterator` ：

- `NestedIterator(List<NestedInteger> nestedList)` 用嵌套列表 `nestedList` 初始化迭代器。
- `int next()` 返回嵌套列表的下一个整数。
- `boolean hasNext()` 如果仍然存在待迭代的整数，返回 `true` ；否则，返回 `false` 。

你的代码将会用下述伪代码检测：

```
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
```

如果 `res` 与预期的扁平化列表匹配，那么你的代码将会被判为正确。

**示例 1：**

```
输入：nestedList = [[1,1],2,[1,1]]
输出：[1,1,2,1,1]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
```

**示例 2：**

```
输入：nestedList = [1,[4,[6]]]
输出：[1,4,6]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。
```

**提示：**

- `1 <= nestedList.length <= 500`
- 嵌套列表中的整数值在范围 `[-10<sup>6</sup>, 10<sup>6</sup>]` 内

题目来源： [力扣 341. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/) 。

我们的算法会被输入一个 `NestedInteger` 列表，我们需要做的就是写一个迭代器类 `NestedIterator` ，将这个带有嵌套结构 `NestedInteger` 的列表「拍平」：

```
class NestedIterator: public Iterator<int> {

public:

    // 构造器输入一个 NestedInteger 列表

    NestedIterator(vector<NestedInteger> &nestedList) {}

    

    // 返回下一个整数

    int next() {}

    // 是否还有下一个元素？

    bool hasNext() {}

};
```

我们写的这个 `NestedIterator` 类会被这样调用， **先调用 `hasNext` 方法，后调用 `next` 方法** ：

```
NestedIterator i = new NestedIterator(nestedList);

while (i.hasNext())

    print(i.next());
```

学过设计模式的朋友应该知道，迭代器也是设计模式的一种，目的就是为调用者屏蔽底层数据结构的细节，简单地通过 `hasNext` 和 `next` 方法有序地进行遍历。

为什么说这个题目很有启发性呢？因为我最近在用一款类似印象笔记的软件，叫做 Notion（挺有名的）。这个软件的一个亮点就是「万物皆 block」，比如说标题、页面、表格都是 block。有的 block 甚至可以无限嵌套，这就打破了传统笔记本「文件夹」->「笔记本」->「笔记」的三层结构。

回想这个算法问题， `NestedInteger` 结构实际上也是一种支持无限嵌套的结构，而且可以同时表示整数和列表两种不同类型，我想 Notion 的核心数据结构 block 估计也是这样的一种设计思路。

那么话说回来，对于这个算法问题，我们怎么解决呢？ `NestedInteger` 结构可以无限嵌套，怎么把这个结构「打平」，为迭代器的调用者屏蔽底层细节，得到扁平化的输出呢？

## 二、解题思路

显然， `NestedInteger` 这个神奇的数据结构是问题的关键，不过题目专门提醒我们不要尝试去实现它，也不要去猜测它的实现。

**为什么？凭什么？是不是题目在误导我？是不是我进行推测之后，这道题就不攻自破了** ？

你不让推测，我就偏偏要去推测！我反手就把 `NestedInteger` 这个结构给实现出来：

```
class NestedInteger {

private:

    int val;

    vector<NestedInteger> list;

public:

    NestedInteger(int val) {

        this->val = val;

        this->list = vector<NestedInteger>();

    }

    NestedInteger(vector<NestedInteger> list) {

        this->list = list;

        this->val = 0;

    }

    // 如果其中存的是一个整数，则返回 true，否则返回 false

    bool isInteger() {

        return val != 0;

    }

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null

    int getInteger() {

        return this->val;

    }

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null

    vector<NestedInteger> getList() {

        return this->list;

    }

};
```

嗯，其实这个实现也不难嘛，写出来之后，我不禁翻出前文 [多叉树基础及遍历](https://labuladong.online/zh/algo/data-structure-basic/n-ary-tree-traverse-basic/) ，发现这玩意儿竟然……

```
class NestedInteger {

public:

    int val;

    std::vector<NestedInteger> list;

};

// 基本的 N 叉树节点

class TreeNode {

public:

    int val;

    std::vector<TreeNode*> children;

};
```

**这玩意儿不就是棵 N 叉树吗？叶子节点是 `Integer` 类型，其 `val` 字段非空；其他节点都是 `List<NestedInteger>` 类型，其 `val` 字段为空，但是 `list` 字段非空，装着孩子节点** 。

比如说输入是 `[[1,1],2,[1,1]]` ，其实就是如下树状结构：

![](https://labuladong.online/images/algo/nestedList/1.jpeg)

好的，刚才题目说什么来着？把一个 `NestedInteger` 扁平化对吧？ **这不就等价于遍历一棵 N 叉树的所有「叶子节点」吗** ？我把所有叶子节点都拿出来，不就可以作为迭代器进行遍历了吗？

N 叉树的遍历怎么整？我又不禁翻出前文 [多叉树遍历框架](https://labuladong.online/zh/algo/data-structure-basic/n-ary-tree-traverse-basic/) ：

```
void traverse(TreeNode* root) {

    if (root == nullptr) {

        return;

    }

    for (TreeNode* child : root->children) {

        traverse(child);

    }

}
```

这个框架可以遍历所有节点，而我们只对整数型的 `NestedInteger` 感兴趣，也就是我们只想要「叶子节点」，所以 `traverse` 函数只要在到达叶子节点的时候把 `val` 加入结果列表即可：

```
class NestedIterator {

private:

    vector<int> res;

    vector<int>::iterator it;

    // 遍历以 nestedList 为根的多叉树

    void traverse(NestedInteger& root) {

        if (root.isInteger()) {

            // 到达叶子节点

            res.push_back(root.getInteger());

            return;

        }

        // 遍历框架

        for (auto child : root.getList()) {

            traverse(child);

        }

    }

public:

    NestedIterator(vector<NestedInteger>& nestedList) {

        // 存放将 nestedList 打平的结果

        for (auto node : nestedList) {

            // 以每个节点为根遍历

            traverse(node);

        }

        it = res.begin();

    }

    int next() {

        return *it++;

    }

    bool hasNext() {

        return it != res.end();

    }

};
```

这样，我们就把原问题巧妙转化成了一个 N 叉树的遍历问题，并且得到了解法。

## 三、进阶思路

以上解法虽然可以通过，但是在面试中，也许是有瑕疵的。

我们的解法中，一次性算出了所有叶子节点的值，全部装到 `result` 列表，也就是内存中， `next` 和 `hasNext` 方法只是在对 `result` 列表做迭代。如果输入的规模非常大，构造函数中的计算就会很慢，而且很占用内存。

一般的迭代器求值应该是「惰性的」，也就是说，如果你要一个结果，我就算一个（或是一小部分）结果出来，而不是一次把所有结果都算出来。

如果想做到这一点，使用递归函数进行 DFS 遍历肯定是不行的，而且我们其实只关心「叶子节点」，所以传统的 BFS 算法也不行。实际的思路很简单：

**调用 `hasNext` 时，如果 `nestedList` 的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型** 。

仔细想一下这个过程应该就能理解了，一次只展开一个最内层的 `nestedList` ，不会一次性把所有 `nestedList` 展开，相当于惰性的 DFS 遍历。

由于调用 `next` 方法之前一定会调用 `hasNext` 方法，这就可以保证每次调用 `next` 方法的时候第一个元素是整数型，直接返回并删除第一个元素即可。

看一下代码：

```
#include <stack>

#include <vector>

class NestedInteger; // Forward declaration of NestedInteger class.

class NestedIterator {

public:

    std::stack<NestedInteger> stack;

    NestedIterator(std::vector<NestedInteger>& nestedList) {

        // 不直接用 nestedList 的引用，是因为不能确定它的底层实现

        // 必须保证是 LinkedList，否则下面的 addFirst 会很低效

        // Since we are using a stack in C++ instead of a list, this comment does not apply directly.

        // We reverse iterate to simulate adding to the front of the list which is similar in spirit.

        for (auto it = nestedList.rbegin(); it != nestedList.rend(); ++it) {

            stack.push(*it);

        }

    }

    int next() {

        // hasNext 方法保证了第一个元素一定是整数类型

        NestedInteger top = stack.top();

        stack.pop();

        return top.getInteger();

    }

    bool hasNext() {

        // 循环拆分列表元素，直到列表第一个元素是整数类型

        while (!stack.empty() && !stack.top().isInteger()) {

            NestedInteger top = stack.top();

            stack.pop();

            // 当列表开头第一个元素是列表类型时，进入循环

            // 将第一个列表打平并按顺序添加到开头

            std::vector<NestedInteger> list = top.getList();

            for (auto it = list.rbegin(); it != list.rend(); ++it) {

                stack.push(*it);

            }

        }

        return !stack.empty();

    }

};
```

以这种方法，符合迭代器惰性求值的特性，是比较好的解法。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表