---
title: 括号类问题汇总
source: https://labuladong.online/zh/algo/problem-set/parentheses/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 滑动窗口是一种快慢指针技巧，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组。本文介绍滑动窗口算法核心框架，总结了力扣/LeetCode 上所有滑动窗口问题的通用解题思路和代码模板。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [队列/栈的原理](https://labuladong.online/zh/algo/data-structure-basic/queue-stack-basic/)

## 20\. 有效的括号

对括号的有效性判断多次在笔试中出现，现实中也很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 `[](){}` ，判断起来有一点难度。

来看一看力扣第 20 题「 [有效的括号](https://leetcode.cn/problems/valid-parentheses/) 」，输入一个字符串，其中包含 `[](){}` 六种括号，请你判断这个字符串组成的括号是否有效：

**20\. 有效的括号** | [力扣](https://leetcode.cn/problems/valid-parentheses/) | [LeetCode](https://leetcode.com/problems/valid-parentheses/)

给定一个只包括 `'('` ， `')'` ， `'{'` ， `'}'` ， `'['` ， `']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**提示：**

- `1 <= s.length <= 10<sup>4</sup>`
- `s` 仅由括号 `'()[]{}'` 组成

题目来源： [力扣 20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 。

解决这个问题之前，我们先降低难度，思考一下， **如果只有一种括号 `()`** ，应该如何判断字符串组成的括号是否有效呢？

假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：

**每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配** 。

比如说字符串 `()))((` 中，中间的两个右括号 **左边** 就没有左括号匹配，所以这个括号组合是无效的。

那么根据这个思路，我们可以写出算法：

```
bool isValid(std::string str) {

    // 待匹配的左括号数量

    int left = 0;

    for (int i = 0; i < str.size(); i++) {

        if (str[i] == '(') {

            left++;

        } else {

            // 遇到右括号

            left--;

        }

        // 右括号太多

        if (left == -1)

            return false;

    }

    // 是否所有的左括号都被匹配了

    return left == 0;

}
```

如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 `left1` ， `left2` ， `left3` 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。

但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 `(())` 是有效的，但是多种括号的情况下， `[(])` 显然是无效的。

仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

我们这道题就用一个名为 `left` 的栈代替之前思路中的 `left` 变量， **遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配** ：

```
class Solution {

public:

    bool isValid(string str) {

        stack<char> left;

        for (char c : str) {

            if (c == '(' || c == '{' || c == '[') {

                // 字符 c 是左括号，入栈

                left.push(c);

            } else {

                // 字符 c 是右括号

                if (!left.empty() && leftOf(c) == left.top()) {

                    left.pop();

                } else {

                    // 和最近的左括号不匹配

                    return false;

                }

            }

        }

        // 是否所有的左括号都被匹配了

        return left.empty();

    }

private:

    char leftOf(char c) {

        if (c == '}') return '{';

        if (c == ')') return '(';

        return '[';

    }

};
```

算法可视化

接下来讲另外两个常见的问题，如何通过最小的插入次数将括号变成有效的？

## 921\. 使括号有效的最小添加

先来个简单的，力扣第 921 题「 [使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/) 」：

**921\. 使括号有效的最少添加** | [力扣](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/) | [LeetCode](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

只有满足下面几点之一，括号字符串才是有效的：

- 它是一个空字符串，或者
- 它可以被写成 `AB`  （ `A`  与  `B`  连接）, 其中  `A` 和  `B` 都是有效字符串，或者
- 它可以被写作 `(A)` ，其中 `A` 是有效字符串。

给定一个括号字符串 `s` ，在每一次操作中，你都可以在字符串的任何位置插入一个括号

- 例如，如果 `s = "()))"` ，你可以插入一个开始括号为 `"(()))"` 或结束括号为 `"())))"` 。

返回 *为使结果字符串 `s` 有效而必须添加的最少括号数* 。

**示例 1：**

```
输入：s = "())"
输出：1
```

**示例 2：**

```
输入：s = "((("
输出：3
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 只包含 `'('` 和 `')'` 字符。

题目来源： [力扣 921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/) 。

这其实和前文的判断括号有效性非常类似，我们直接看代码：

```
class Solution {

public:

    int minAddToMakeValid(string s) {

        // res 记录插入次数

        int res = 0;

        // need 变量记录右括号的需求量

        int need = 0;

        for (int i = 0; i < s.length(); i++) {

            if (s[i] == '(') {

                // 对右括号的需求 + 1

                need++;

            }

            if (s[i] == ')') {

                // 对右括号的需求 - 1

                need--;

                if (need == -1) {

                    need = 0;

                    // 需插入一个左括号

                    res++;

                }

            }

        }

        return res + need;

    }

};
```

算法可视化

这段代码就是最终解法， **核心思路是以左括号为基准，通过维护对右括号的需求数 `need` ，来计算最小的插入次数** 。需要注意两个地方：

**1、当 `need == -1` 的时候意味着什么** ？

因为只有遇到右括号 `)` 的时候才会 `need--` ， `need == -1` 意味着右括号太多了，所以需要插入左括号。

比如说 `s = "))"` 这种情况，需要插入 2 个左括号，使得 `s` 变成 `"()()"` ，才是一个有效括号串。

**2、算法为什么返回 `res + need`** ？

因为 `res` 记录的左括号的插入次数， `need` 记录了右括号的需求，当 for 循环结束后，若 `need` 不为 0，那么就意味着右括号还不够，需要插入。

比如说 `s = "))("` 这种情况，插入 2 个左括号之后，还要再插入 1 个右括号，使得 `s` 变成 `"()()()"` ，才是一个有效括号串。

以上就是这道题的思路，接下来我们看一道进阶题目，如果左右括号不是 1:1 配对，会出现什么问题呢？

## 1541\. 平衡括号串的最少插入

这是力扣第 1541 题「 [平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/) 」：

**1541\. 平衡括号字符串的最少插入次数** | [力扣](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/) | [LeetCode](https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/)

给你一个括号字符串 `s` ，它只包含字符 `'('` 和 `')'` 。一个括号字符串被称为平衡的当它满足：

- 任何左括号 `'('` 必须对应两个连续的右括号 `'))'` 。
- 左括号 `'('` 必须在对应的连续两个右括号 `'))'` 之前。

比方说 `"())"` ， `"())(())))"` 和 `"(())())))"` 都是平衡的， `")()"` ， `"()))"` 和 `"(()))"` 都是不平衡的。

你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。

请你返回让 `s` 平衡的最少插入次数。

**示例 1：**

```
输入：s = "(()))"
输出：1
解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。
```

**示例 2：**

```
输入：s = "())"
输出：0
解释：字符串已经平衡了。
```

**示例 3：**

```
输入：s = "))())("
输出：3
解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
```

**示例 4：**

```
输入：s = "(((((("
输出：12
解释：添加 12 个 ')' 得到平衡字符串。
```

**示例 5：**

```
输入：s = ")))))))"
输出：5
解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。
```

**提示：**

- `1 <= s.length <= 10^5`
- `s` 只包含 `'('` 和 `')'` 。

题目来源： [力扣 1541. 平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/) 。

现在假设 1 个左括号需要匹配 2 个右括号才叫做有效的括号组合，那么给你输入一个括号串 `s` ，请问你如何计算使得 `s` 有效的最小插入次数呢？

**核心思路还是和刚才一样，通过一个 `need` 变量记录对右括号的需求数，根据 `need` 的变化来判断是否需要插入** 。

第一步，我们按照刚才的思路正确维护 `need` 变量：

```
int minInsertions(std::string s) {

    // need 记录需右括号的需求量

    int res = 0, need = 0;

    for (int i = 0; i < s.size(); i++) {

        // 一个左括号对应两个右括号

        if (s[i] == '(') {

            need += 2;

        }

        if (s[i] == ')') {

            need--;

        }

    }

    return res + need;

}
```

现在想一想，当 `need` 为什么值的时候，我们可以确定需要进行插入？

**首先，类似第一题，当 `need == -1` 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号** 。

比如说当 `s = ")"` ，我们肯定需要插入一个左括号让 `s = "()"` ，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：

```
if (s[i] == ')') {

    need--;

    // 说明右括号太多了

    if (need == -1) {

        // 需要插入一个左括号

        res++;

        // 同时，对右括号的需求变为 1

        need = 1;

    }

}
```

**另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号** 。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。

所以遇到左括号时要做如下判断：

```
if (s[i] == '(') {

    need += 2;

    if (need % 2 == 1) {

        // 插入一个右括号

        res++;

        // 对右括号的需求减一

        need--;

    }

}
```

综上，我们可以写出正确的代码：

```
class Solution {

public:

    int minInsertions(string s) {

        // need 记录需右括号的需求量

        int res = 0, need = 0;

        for (int i = 0; i < s.length(); i++) {

            // 一个左括号对应两个右括号

            if (s[i] == '(') {

                need += 2;

                if (need % 2 == 1) {

                    // 插入一个右括号

                    res++;

                    need--;

                }

            }

            if (s[i] == ')') {

                need--;

                // 说明右括号太多了

                if (need == -1) {

                    // 需要插入一个左括号

                    res++;

                    // 同时，对右括号的需求变为 1

                    need = 1;

                }

            }

        }

        return res + need;

    }

};
```

算法可视化

更新时间：2026/02/17 14:24

## 评论(9)

Markdown

Ctrl+Enter 发表

![凡](https://thirdwx.qlogo.cn/mmopen/vi_32/Cox3ic6iavejkNOBadZRYxspRmkN6Zbq8ZBIRM4epWt8I3YFtIUT3KsLFTpATNSefaicrib6nGSicbQduic0PKbOwZUw/132)

凡 大约 1 年前

这个篇幅可以考虑再加一题吗？1249：Minimum Remove to Make Valid Parentheses。上面的题都是插入，这题是删除括号。可以按照这个res，need。来写吗？

![yuqing19118](https://avatars.githubusercontent.com/u/19398621?v=4)

yuqing19118

yuqing19118 12 个月前

```
class Solution {

    public String minRemoveToMakeValid(String s) {

        int needRight = 0;

        char[] charArr = s.toCharArray();

        //remove the extra )

        for(int i = 0; i < s.length(); i++) {

            char c = s.charAt(i);

            if(c == '(') {

                needRight++;

            } 

            if(c == ')') {

                needRight--;

                if(needRight == -1) {

                    charArr[i] = '*';

                    needRight = 0;

                }

            }

        }

        //remove the extra (

        needRight = 0;

        for(int i = s.length() - 1; i >= 0; i--) {

            char c = s.charAt(i);

            if(c == ')') {

                needRight++;

            } 

            if(c == '(') {

                needRight--;

                if(needRight == -1) {

                    charArr[i] = '*';

                    needRight = 0;

                }

            }

        }

        StringBuilder sb = new StringBuilder();

        for(char c : charArr) {

            if(c != '*') {

                sb.append(c);

            }

        }

        return sb.toString();

    }

}
```

![Chesterious](https://thirdwx.qlogo.cn/mmopen/vi_32/O1I5fwApMaIUMkmu6mk5mrDH8k7tY1OOfFqFI6HTbMfKmaicErbRrYic5lCnibeS3AjQeicvicBKmMKEqXKWLKdJR2Q/132)

Chesterious

Chesterious 大约 2 个月前

1541题，我尝试用栈去写，结果总是出bug，虽然最后也能写出来，但不得不说： 维护这个栈的难度要远远大于维护need+res这俩的难度。

![卷柏](https://thirdwx.qlogo.cn/mmopen/vi_32/dnEbIHUp2D2RibgI7MDqnZ5E7WCNcJPmMpoBLgFaho1ee1icDDKNBH03yLO7rfgia44iaFWYficg1XLsoXwhtkaGzv5D4eUqOhb8sBgiakVwYyNhk/132)

卷柏 7 个月前

可以用left，right么，好像更好理解：

```
class Solution {

    public int minInsertions(String s) {

        int left = 0;  // 需要添加的左括号数量

        int right = 0;  // 需要添加的右括号数量

        for (int i = 0; i < s.length(); i++) {

            char c = s.charAt(i);

            if (c == '(') {

                right += 2;  // 每个 '(' 需要两个 ')'

                // 如果 right 是奇数，说明需要补一个 ')'

                if (right % 2 == 1) {

                    left++;    // 补一个 '(' 来平衡

                    right--;   // 减少一个 ')'

                }

            } else {  // c == ')'

                if (right > 0) {

                    right--;  // 消耗一个 ')'

                } else {

                    // 没有 '(' 可以匹配，需要补一个 '('

                    left++;    // 补一个 '('

                    right = 1; // 还需要一个 ')'

                }

            }

        }

        return left + right;

    }

}
```

![Yuuuuu](https://thirdwx.qlogo.cn/mmopen/vi_32/3eLEXowzDITh7HtkklXC0bkPsWcmxLhElR558AsW1mHb9ltBqYzRtbLzEzmEBfzWJt1S2viaW8J1ZP2sNslruTw/132)

Yuuuuu 11 个月前

这篇文章应该改成解决3题

![Jsun](https://thirdwx.qlogo.cn/mmopen/vi_32/ctI2ictkuicWmCgFzoibXviaNdVMQTJTQo0eCJvlic8WsKGX6Rd5a6L7IBPJ3clKcKnr9LsgkichhIYfg2jWEaNfISRRN3Jq3F2v5HLzJ4dyv8RQ8/132)

Jsun 10 个月前

921 我觉得我这个方法好理解一点 如果当前新的字符和栈顶匹配栈就会弹出栈顶 最后栈留下几个就代表这些字符没有匹配成功 那么就是需要的元素个数

```
int minAddToMakeValid(string s) {

        stack<char> stack;

        for(int i = 0;i<s.size();i++){

            if(stack.empty()||s[i]==stack.top()){

                stack.push(s[i]);

            }else{

                if(s[i]==')'&&stack.top()=='('){

                    stack.pop();

                }else{

                    stack.push(s[i]);

                }

            }

        }

        return stack.size();

    }
```

![yyy.](https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKbIBzaPhYkljhxdXDNadc6c3PGsZn1ZgXDFhKWtWwpBV5icSMiaEttheIecuDCSy2iceIchGCVEzD6ycAaEesfQuFEtpbNWh3Zlup9tkzcgZHFg/132)

yyy.5 个月前

如果2个（ 对三个 ） 呢，这种有解答吗东哥，想了好久

![🧀](https://thirdwx.qlogo.cn/mmopen/vi_32/E0yB3ficiaXuRme0IZFuTRJSibFsoia9zqtwGw4mP5yIf13ay5w4NYG1d3OwJ7YFA6PH0xZZYfApevCdQhyicTMC736DH6OsY9vfoic0jRicu0X6FQ/132)

🧀 11 个月前

第三道题为什么右括号的需求必须是偶数？举个很简单的例子“()”，要想平衡就需要加一个右括号啊

![momo](https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7F72ofjghSqBXicIrZpyPrz1lEGhghECkm0SywuBVlzG3iaWpj2vOdwvrhyptEXJaia8LR8UWN3a89w/132)

momo 8 个月前

1541如果改成问 需要分别加多少左括号和右括号，应该怎么写？好几个ai居然都写不出来。 可以试试这两个case "(()))" “)("