---
title: 队列的经典习题
source: https://labuladong.online/zh/algo/problem-set/queue/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有队列结构的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [队列/栈的原理](https://labuladong.online/zh/algo/data-structure-basic/queue-stack-basic/)

## 考察先进先出性质

队列常见考点主要是元素「先进先出」的顺序特性，比如维护队列内的元素在「时序上」的某些性质，下面是几道例题，队列充当「滑动窗口」的作用。

**933\. 最近的请求次数** | [力扣](https://leetcode.cn/problems/number-of-recent-calls/) | [LeetCode](https://leetcode.com/problems/number-of-recent-calls/)

写一个 `RecentCounter` 类来计算特定时间范围内最近的请求。

请你实现 `RecentCounter` 类：

- `RecentCounter()` 初始化计数器，请求数为 0 。
- `int ping(int t)` 在时间 `t` 添加一个新请求，其中 `t` 表示以毫秒为单位的某个时间，并返回过去 `3000` 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 `[t-3000, t]` 内发生的请求数。

**保证** 每次对 `ping` 的调用都使用比之前更大的 `t` 值。

**示例 1：**

```
输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
```

**提示：**

- `1 <= t <= 10<sup>9</sup>`
- 保证每次对 `ping` 调用所使用的 `t` 值都 **严格递增**
- 至多调用 `ping` 方法 `10<sup>4</sup>` 次

题目来源： [力扣 933. 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/) 。

#### 基本思路

这题很简单，和 [346\. 数据流中的移动平均值](https://leetcode.cn/problems/moving-average-from-data-stream/description/) 有点类似，要求动态维护队列中的元素。

#### 解法代码

#### 算法可视化

## 队列相关的设计题

队列相关的设计题也是一大重点，但不算很难，下面是几道例题。

### 622\. 设计循环队列

**622\. 设计循环队列** | [力扣](https://leetcode.cn/problems/design-circular-queue/) | [LeetCode](https://leetcode.com/problems/design-circular-queue/)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

- `MyCircularQueue(k)`: 构造器，设置队列长度为 k 。
- `Front`: 从队首获取元素。如果队列为空，返回 -1 。
- `Rear`: 获取队尾元素。如果队列为空，返回 -1 。
- `enQueue(value)`: 向循环队列插入一个元素。如果成功插入则返回真。
- `deQueue()`: 从循环队列中删除一个元素。如果成功删除则返回真。
- `isEmpty()`: 检查循环队列是否为空。
- `isFull()`: 检查循环队列是否已满。

**示例：**

```
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```

**提示：**

- 所有的值都在 0 至 1000 的范围内；
- 操作数将在 1 至 1000 的范围内；
- 请不要使用内置的队列库。

题目来源： [力扣 622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/) 。

#### 基本思路

这道题考察的是普通队列的实现，底层可以用链表或数组实现，用链表实现比较简单，用数组的话要用到环形数组的技巧。具体可以参见 [用链表实现队列/栈](https://labuladong.online/zh/algo/data-structure-basic/linked-queue-stack/) 和 [用数组实现环形队列](https://labuladong.online/zh/algo/data-structure-basic/array-queue-stack/) 两篇文章。

#### 解法代码

#### 算法可视化

算法可视化

### 641\. 设计循环双端队列

**641\. 设计循环双端队列** | [力扣](https://leetcode.cn/problems/design-circular-deque/) | [LeetCode](https://leetcode.com/problems/design-circular-deque/)

设计实现双端队列。

实现 `MyCircularDeque` 类:

- `MyCircularDeque(int k)` ：构造函数,双端队列最大为 `k` 。
- `boolean insertFront()` ：将一个元素添加到双端队列头部。 如果操作成功返回 `true`  ，否则返回 `false` 。
- `boolean insertLast()` ：将一个元素添加到双端队列尾部。如果操作成功返回 `true`  ，否则返回 `false` 。
- `boolean deleteFront()` ：从双端队列头部删除一个元素。 如果操作成功返回 `true`  ，否则返回 `false` 。
- `boolean deleteLast()` ：从双端队列尾部删除一个元素。如果操作成功返回 `true`  ，否则返回 `false` 。
- `int getFront()` )：从双端队列头部获得一个元素。如果双端队列为空，返回 `-1` 。
- `int getRear()` ：获得双端队列的最后一个元素。 如果双端队列为空，返回 `-1` 。
- `boolean isEmpty()` ：若双端队列为空，则返回 `true`  ，否则返回 `false` 。
- `boolean isFull()` ：若双端队列满了，则返回 `true`  ，否则返回 `false` 。

**示例 1：**

```
输入
["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
输出
[null, true, true, true, false, 2, true, true, true, 4]

解释
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);                    // 返回 true
circularDeque.insertLast(2);                    // 返回 true
circularDeque.insertFront(3);                    // 返回 true
circularDeque.insertFront(4);                    // 已经满了，返回 false
circularDeque.getRear();                  // 返回 2
circularDeque.isFull();                        // 返回 true
circularDeque.deleteLast();                    // 返回 true
circularDeque.insertFront(4);                    // 返回 true
circularDeque.getFront();                // 返回 4
```

**提示：**

- `1 <= k <= 1000`
- `0 <= value <= 1000`
- `insertFront`, `insertLast`, `deleteFront`, `deleteLast`, `getFront`, `getRear`, `isEmpty`, `isFull`   调用次数不大于  `2000` 次

题目来源： [力扣 641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/) 。

#### 基本思路

这道题考察的是双端队列的实现，底层可以用链表或数组实现，用链表实现比较简单，用数组的话要用到 [环形数组](https://labuladong.online/zh/algo/data-structure-basic/cycle-array/) 的技巧。

#### 解法代码

#### 算法可视化

算法可视化

### 1670\. 设计前中后队列

**1670\. 设计前中后队列** | [力扣](https://leetcode.cn/problems/design-front-middle-back-queue/) | [LeetCode](https://leetcode.com/problems/design-front-middle-back-queue/)

请你设计一个队列，支持在前，中，后三个位置的 `push`  和 `pop` 操作。

请你完成 `FrontMiddleBack` 类：

- `FrontMiddleBack()` 初始化队列。
- `void pushFront(int val)` 将 `val` 添加到队列的 **最前面** 。
- `void pushMiddle(int val)` 将 `val` 添加到队列的 **正中间** 。
- `void pushBack(int val)` 将 `val` 添加到队里的 **最后面** 。
- `int popFront()` 将 **最前面** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。
- `int popMiddle()` 将 **正中间** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。
- `int popBack()` 将 **最后面** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。

请注意当有 **两个** 中间位置的时候，选择靠前面的位置进行操作。比方说：

- 将 `6` 添加到 `[1, 2, 3, 4, 5]` 的中间位置，结果数组为 `[1, 2, **6**, 3, 4, 5]` 。
- 从 `[1, 2, **3**, 4, 5, 6]` 的中间位置弹出元素，返回 `3` ，数组变为 `[1, 2, 4, 5, 6]` 。

**示例 1：**

```
输入：
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
输出：
[null, null, null, null, null, 1, 3, 4, 2, -1]

解释：
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // 返回 1 -> [4, 3, 2]
q.popMiddle();    // 返回 3 -> [4, 2]
q.popMiddle();    // 返回 4 -> [2]
q.popBack();      // 返回 2 -> []
q.popFront();     // 返回 -1 -> [] （队列为空）
```

**提示：**

- `1 <= val <= 10<sup>9</sup>`
- 最多调用 `1000`  次  `pushFront` ，  `pushMiddle` ，  `pushBack` ，  `popFront` ，  `popMiddle`  和  `popBack` 。

题目来源： [力扣 1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/) 。

#### 基本思路

这题有点难度，主要是细节不好把控。常规的队列只能在首尾进行操作，想在中间操作队列，需要在底层把队列切分成 `left, right` 两个列表，但这里的细节问题就是元素为奇数时两个链表中元素的分配问题。

直接看代码吧，注释很详细。

#### 解法代码

#### 算法可视化

算法可视化

### 2073\. 买票需要的时间

**2073\. 买票需要的时间** | [力扣](https://leetcode.cn/problems/time-needed-to-buy-tickets/) | [LeetCode](https://leetcode.com/problems/time-needed-to-buy-tickets/)

有 `n` 个人前来排队买票，其中第 `0` 人站在队伍 **最前方** ，第 `(n - 1)` 人站在队伍 **最后方** 。

给你一个下标从 **0** 开始的整数数组 `tickets` ，数组长度为 `n` ，其中第 `i` 人想要购买的票数为 `tickets[i]` 。

每个人买票都需要用掉 **恰好 1 秒** 。一个人 **一次只能买一张票** ，如果需要购买更多票，他必须走到 **队尾** 重新排队（ **瞬间** 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 **离开** 队伍。

返回位于位置 `k` （下标从 **0** 开始）的人完成买票需要的时间（以秒为单位）。

**示例 1：**

```
输入：tickets = [2,3,2], k = 2
输出：6
解释： 
- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。
- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。
位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。
```

**示例 2：**

```
输入：tickets = [5,1,1,1], k = 0
输出：8
解释：
- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。
- 接下来的 4 轮，只有位置 0 的人在买票。
位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。
```

**提示：**

- `n == tickets.length`
- `1 <= n <= 100`
- `1 <= tickets[i] <= 100`
- `0 <= k < n`

题目来源： [力扣 2073. 买票需要的时间](https://leetcode.cn/problems/time-needed-to-buy-tickets/) 。

#### 基本思路

既然是排队问题，你用一个队列模拟整个买票过程，然后数一数过了多少秒就行了，不过时间空间复杂度就高了。

稍微思考一下可以想到更高效的方式：

首先，第 `k` 个人离开的时间，其实就是从开始到这个人买完票之后，卖出的总票数。

那么第 `k` 个人买完票之后，总共卖了多少票呢？

排在 `k` 之前的人最多买了 `tickets[k]` 张票；而排在 `k` 之后的人最多买了 `tickets[k] - 1` 张票。为什么说「最多」呢，因为有的人可能需要的票比较少，买完就直接走了。

综上，思路就出来了，看代码理解吧。

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [编程语言刷题实践](https://labuladong.online/zh/algo/programming-language-basic/lc-practice/)

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表