---
title: 二分搜索算法核心代码模板
source: https://labuladong.online/zh/algo/essential-technique/binary-search-framework/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文用统一的两端都闭搜索区间，讲解二分搜索的三种场景：搜索元素、搜索左边界、搜索右边界，确保你能准确写出二分搜索代码。
tags:
  - clippings
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [704\. Binary Search](https://leetcode.com/problems/binary-search/) | [704\. 二分查找](https://leetcode.cn/problems/binary-search/) |  |
| [34\. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | [34\. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) |  |
| [LCR 172. 统计目标成绩的出现次数](https://leetcode.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) | [LCR 172. 统计目标成绩的出现次数](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) |  |

前置知识

阅读本文前，你需要先学习：

- [数组基础](https://labuladong.online/zh/algo/data-structure-basic/array-basic/)

先给大家讲个笑话乐呵一下：

有一天阿东到图书馆借了 `N` 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？

于是保安把书分成两堆，让第一堆过一下报警器，报警器响，这说明引起报警的书包含在里面；于是再把这堆书分成两堆，把第一堆过一下报警器，报警器又响，继续分成两堆……

最终，检测了 `logN` 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。

从此，图书馆丢了 `N - 1` 本书（手动狗头）。

二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找： **思路很简单，细节是魔鬼** 。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 `mid` 加一还是减一，while 里到底用 `<=` 还是 `<` 。

你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑，谁写谁知道。

本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。这三种场景使用统一的框架，while 条件统一用 `<=` ，边界更新统一用 `mid ± 1` ，便于记忆。

## 二分查找框架

二分搜索主要有两种主流写法，分别是「两端都闭」的写法和「左闭右开」的写法。 **本文介绍「两端都闭」的写法** ，因为这种写法更容易记忆和统一。「左闭右开」的写法会在 [二分搜索的左闭右开写法](https://labuladong.online/zh/algo/essential-technique/binary-search-left-open/) 拓展。

无论哪种写法，二分搜索的代码都符合以下框架：

```
int binarySearch(vector<int>& nums, int target) {

    int left = 0, right = nums.size() - 1;

    while (...) {

        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {

            ...

        } else if (nums[mid] < target) {

            left = ...

        } else if (nums[mid] > target) {

            right = ...

        }

    }

}
```

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方，后面用实例分析这些地方能有什么样的变化。

想写对二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。当你能够理清所有细节之后，可以自行简化。

**另外提前说明一下，计算 `mid` 时需要防止溢出** ，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致整型溢出的情况。

## 搜索区间的概念

准确理解二分查找的关键在于理解「搜索区间」这个概念，也就是 `left` 和 `right` 指针的含义。

比如说，如果我们把 `right` 初始化为 `nums.length - 1` ，即最后一个元素的索引，那么搜索区间就是两端都闭的 `[left, right]` ，这个索引区间就是每次进行搜索的范围。

如果 `right` 初始化为 `nums.length` ，即最后一个元素的索引 + 1，那么搜索区间就是左闭右开的 `[left, right)` 。

**二分搜索的本质，其实就是利用 `while` 循环调整 `left` 和 `right` 指针，不断收缩搜索区间，最终锁定目标值所在的那个索引** 。

搜索区间的开闭不同，对应的写法就不同。对于一个正确的二分搜索算法，我们需要确保：

- 搜索区间为空时，应该停止搜索，否则算法就会死循环。
- 搜索的过程中，不能漏掉元素，否则就会得到错误的答案。

记住这两个原则，下面我们来使用「 **两端都闭** 」的二分搜索写法，探讨二分搜索的三种场景：寻找一个数、寻找左侧边界、寻找右侧边界。

## 寻找一个数

这个场景是最简单的，搜索一个数，如果存在返回其索引，否则返回 -1。

```
class Solution {

public:

    // 标准的二分搜索框架，搜索目标元素的索引，若不存在则返回 -1

    int search(vector<int>& nums, int target) {

        int left = 0;

        // 注意

        int right = nums.size() - 1;

        while(left <= right) {

            int mid = left + (right - left) / 2;

            if(nums[mid] == target) {

                return mid;   

            } else if (nums[mid] < target) {

                // 注意

                left = mid + 1;

            } else if (nums[mid] > target) {

                // 注意

                right = mid - 1;

            }

        }

        return -1;

    }

};
```

这段代码可以解决力扣第 704 题「 [二分查找](https://leetcode.cn/problems/binary-search/) 」，我们深入探讨一下其中的细节。

### 为什么 while 循环的条件是 <= 而不是 <？

对于两端都闭的搜索区间， `<=` 不会漏掉元素。

`while(left <= right)` 的终止条件是 `left == right + 1` ，此时的搜索区间是 `[right + 1, right]` ，没有元素既大于等于 `right+1` 又小于等于 `right` ，所以搜索区间为空，while 循环终止是正确的。

如果使用 `while(left < right)` ，终止条件是 `left == right` ，写成区间的形式就是 `[left, left]` ， **这时候搜索区间还有一个元素** ，但 while 循环终止了，就会漏掉这个元素，如果目标值恰好是这个元素，算法就会误以为目标值不存在。

从这里也可以看出来二分搜索为什么难完全写对：bug 是偶发性的，可能大部分测试用例都能得到正确答案，只有特定的测试用例会出现错误。

所以必须彻底理解搜索区间，才能写出完全正确的代码。

### 为什么是 left = mid + 1，right = mid - 1？

因为 `mid` 已经搜索过，应该从搜索区间中去除。

因为我们的搜索区间是两端都闭的 `[left, right]` 。当我们发现索引 `mid` 不是要找的 `target` 时，搜索区间应该收缩为 `[left, mid-1]` 或者区间 `[mid+1, right]` 。

### 此算法有什么缺陷？

比如说给你有序数组 `nums = [1,2,2,2,3]` ， `target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

你也许会说，找到一个 `target` ，然后向左或向右线性搜索不行吗？可以，但是这样难以保证二分查找对数级的复杂度了。

我们后续的算法就来讨论这两种寻找边界的算法，这也是实际算法题中比较常见的场景。

## 寻找左侧边界

先直接看寻找左侧边界的二分搜索代码：

```
int left_bound(vector<int>& nums, int target) {

    int left = 0, right = nums.size() - 1;

    // 搜索区间为 [left, right]

    while (left <= right) {

        int mid = left + (right - left) / 2;

        if (nums[mid] < target) {

            // 搜索区间变为 [mid+1, right]

            left = mid + 1;

        } else if (nums[mid] > target) {

            // 搜索区间变为 [left, mid-1]

            right = mid - 1;

        } else if (nums[mid] == target) {

            // 收缩右侧边界

            right = mid - 1;

        }

    }

    return left;

}
```

### 为什么该算法能够搜索左侧边界？

关键在于对 `nums[mid] == target` 这个条件的处理：

```
if (nums[mid] == target) {

    // 收缩右侧边界

    right = mid - 1;

}
```

找到 target 时不要立即返回，而是收缩右边界 `right = mid - 1` ，在区间 `[left, mid-1]` 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

### 如果 target 不存在怎么办？

如果 `target` 不存在， `left_bound` 返回的索引是「 **大于 `target` 的最小索引** 」。

这个结论不用死记，举个例子就明白了： `nums = [2,3,5,7], target = 4` ， `left_bound` 返回值是 2，因为元素 5 是大于 4 的最小元素。

如果你想在 `target` 不存在时返回 -1，在返回时额外判断一下 `nums[left]` 是否等于 `target` 就行了：

```
// 如果越界，target 肯定不存在，返回 -1

if (left < 0 || left >= nums.length) {

    return -1;

}

// 判断一下 nums[left] 是不是 target

if (nums[left] != target) {

    return -1;

}

// nums[left] == target，目标索引为 left

return left;
```

## 寻找右侧边界

先直接看寻找右侧边界的二分搜索代码：

```
int right_bound(vector<int>& nums, int target) {

    int left = 0, right = nums.size() - 1;

    while (left <= right) {

        int mid = left + (right - left) / 2;

        if (nums[mid] < target) {

            left = mid + 1;

        } else if (nums[mid] > target) {

            right = mid - 1;

        } else if (nums[mid] == target) {

            // 这里改成收缩左侧边界即可

            left = mid + 1;

        }

    }

    // 最后改成返回 right

    return right;

}
```

### 为什么该算法能够搜索右侧边界？

关键在于对 `nums[mid] == target` 这个条件的处理：

```
if (nums[mid] == target) {

    // 收缩左侧边界

    left = mid + 1;

}
```

找到 target 时不要立即返回，而是收缩左边界 `left = mid + 1` ，在区间 `[mid+1, right]` 中继续搜索，即不断向右收缩，达到锁定右侧边界的目的。

### 如果 target 不存在怎么办？

如果 `target` 不存在， `right_bound` 返回的索引是「 **小于 `target` 的最大索引** 」。

比如 `nums = [2,3,5,7], target = 4` ， `right_bound` 返回值是 1，因为元素 3 是小于 4 的最大元素。

如果你想在 `target` 不存在时返回 -1，在返回时额外判断一下 `nums[right]` 是否等于 `target` 就行了：

```
// 索引越界则说明不存在 target

if (right < 0 || right >= nums.length) {

    return -1;

}

// 目标索引不等于 target 则说明不存在 target

if (nums[right] != target) {

    return -1;

}

// nums[right] == target，目标索引为 right

return right;
```

## 五、统一模板

三种场景使用统一的两端都闭搜索区间 `[left, right]` ，只有 `nums[mid] == target` 时的处理不同：

```
int binary_search(vector<int>& nums, int target) {

    int left = 0, right = nums.size()-1; 

    while(left <= right) {

        int mid = left + (right - left) / 2;

        if (nums[mid] < target) {

            left = mid + 1;

        } else if (nums[mid] > target) {

            right = mid - 1; 

        } else if(nums[mid] == target) {

            // 直接返回

            return mid;

        }

    }

    // 直接返回

    return -1;

}

int left_bound(vector<int>& nums, int target) {

    int left = 0, right = nums.size()-1;

    while (left <= right) {

        int mid = left + (right - left) / 2;

        if (nums[mid] < target) {

            left = mid + 1;

        } else if (nums[mid] > target) {

            right = mid - 1;

        } else if (nums[mid] == target) {

            // 别返回，锁定左侧边界

            right = mid - 1;

        }

    }

    // 判断 target 是否存在于 nums 中

    if (left < 0 || left >= nums.size()) {

        return -1;

    }

    // 判断一下 nums[left] 是不是 target

    return nums[left] == target ? left : -1;

}

int right_bound(vector<int>& nums, int target) {

    int left = 0, right = nums.size()-1;

    while (left <= right) {

        int mid = left + (right - left) / 2;

        if (nums[mid] < target) {

            left = mid + 1;

        } else if (nums[mid] > target) {

            right = mid - 1;

        } else if (nums[mid] == target) {

            // 别返回，锁定右侧边界

            left = mid + 1;

        }

    }

    // 由于 while 的结束条件是 right == left - 1，且现在在求右边界

    // 所以用 right 替代 left - 1 更好记

    if (right < 0 || right >= nums.size()) {

        return -1;

    }

    return nums[right] == target ? right : -1;

}
```

通过本文，你学会了：

1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。

2、注意「搜索区间」和 while 的终止条件，搜索区间为空时终止。

3、三种场景统一使用两端都闭的写法，只需修改 `nums[mid] == target` 条件处的代码和返回逻辑即可。

最后我想说，以上二分搜索的框架属于「术」的范畴，如果上升到「道」的层面， **二分思维的精髓就是：通过已知信息尽可能多地收缩（折半）搜索空间** ，从而增加穷举效率，快速找到目标。

理解本文能保证你写出正确的二分查找代码。本文介绍的两端都闭写法是我推荐的写法，三种场景框架统一，便于记忆。

不过你可能在网上看到另一种写法：左闭右开的搜索区间 `[left, right)` ，使用 `while (left < right)` 和 `right = mid` 。这种写法也很常见，如果你想深入理解这种写法的逻辑，可以阅读 [二分搜索的左闭右开写法](https://labuladong.online/zh/algo/essential-technique/binary-search-left-open/) 。

实际题目中不会直接让你写二分代码，我会在 [二分查找的运用](https://labuladong.online/zh/algo/frequency-interview/binary-search-in-action/) 和 [二分查找的更多习题](https://labuladong.online/zh/algo/problem-set/binary-search/) 中进一步讲解如何把二分思维运用到更多算法题中。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表