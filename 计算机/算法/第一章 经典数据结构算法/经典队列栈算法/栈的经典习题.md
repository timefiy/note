---
title: 栈的经典习题
source: https://labuladong.online/zh/algo/problem-set/stack/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有栈结构相关的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [队列/栈的原理](https://labuladong.online/zh/algo/data-structure-basic/queue-stack-basic/)

## 考察先进后出性质

对于栈这种数据结构的考察，主要考察先进后出特点的运用，比如表达式运算、括号合法性检测等问题，下面列出几个使用栈的经典场景。

### 71\. 简化路径

**71\. 简化路径** | [力扣](https://leetcode.cn/problems/simplify-path/) | [LeetCode](https://leetcode.com/problems/simplify-path/)

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即， `'//'` ）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如， `'...'` ）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在） **不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'` ）。

返回简化后得到的 **规范路径** 。

**示例 1：**

```
输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2：**

```
输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
```

**示例 3：**

```
输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**

```
输入：path = "/a/./b/../../c/"
输出："/c"
```

**提示：**

- `1 <= path.length <= 3000`
- `path` 由英文字母，数字， `'.'` ， `'/'` 或 `'_'` 组成。
- `path` 是一个有效的 Unix 风格绝对路径。

题目来源： [力扣 71. 简化路径](https://leetcode.cn/problems/simplify-path/) 。

#### 基本思路

这题比较简单，利用栈先进后出的特性处理上级目录 `..`，最后组装化简后的路径即可。

#### 解法代码

```
#include <string>

#include <vector>

#include <sstream>

class Solution {

public:

    std::string simplifyPath(std::string path) {

        std::vector<std::string> parts;

        std::istringstream ss(path);

        std::string part;

        // 借助栈计算最终的文件夹路径

        while (std::getline(ss, part, '/')) {

            if (part.empty() || part == ".") {

                // Skip empty parts and current directory symbol.

                continue;

            }

            if (part == "..") {

                // Go up one directory (pop from the stack) unless the stack is empty.

                if (!parts.empty()) parts.pop_back();

            } else {

                // Add the non-empty and non-".." part to the stack.

                parts.push_back(part);

            }

        }

        // 栈中存储的文件夹组成路径

        std::string res;

        for (const auto& p : parts) {

            res += "/" + p;

        }

        // If the result is empty, it means the path is root directory.

        return res.empty() ? "/" : res;

    }

};
```

#### 算法可视化

算法可视化

### 143\. 重排链表

**143\. 重排链表** | [力扣](https://leetcode.cn/problems/reorder-list/) | [LeetCode](https://leetcode.com/problems/reorder-list/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1：**

![](https://labuladong.online/images/lc/1626420311-PkUiGI-image.png)

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**

![](https://labuladong.online/images/lc/1626420320-YUiulT-image.png)

```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

**提示：**

- 链表的长度范围为 `[1, 5 * 10<sup>4</sup>]`
- `1 <= node.val <= 1000`

题目来源： [力扣 143. 重排链表](https://leetcode.cn/problems/reorder-list/) 。

#### 基本思路

这题的难点在于：一个单链表只能从头部向尾部遍历节点，无法从尾部开始向头部遍历节点。

那么我们可以利用「栈」先进后出的结构特点，按从头到尾的顺序让链表节点入栈，那么出栈顺序就是反过来从尾到头了。

有了这个栈，算法的大致逻辑如下：

```
ListNode p = head;

while (p != null) {

    // 链表尾部的节点

    ListNode lastNode = stk.pop();

    // 按题目要求拼接

    ListNode next = p.next;

    p.next = lastNode;

    lastNode.next = next;

    p = next;

}
```

当然，处理单链表时细节问题比较多，注意操作指针时的顺序，避免操作失误形成环形链表，直接看我的代码注释吧。

#### 解法代码

```
#include <stack>

class Solution {

public:

    void reorderList(ListNode* head) {

        std::stack<ListNode*> stk;

        // 先把所有节点装进栈里，得到倒序结果

        ListNode* p = head;

        while (p != nullptr) {

            stk.push(p);

            p = p->next;

        }

        p = head;

        while (!stk.empty()) {

            // 链表尾部的节点

            ListNode* lastNode = stk.top();

            stk.pop();

            ListNode* next = p->next;

            if (lastNode == next || lastNode->next == next) {

                // 结束条件，链表节点数为奇数或偶数时均适用

                lastNode->next = nullptr;

                break;

            }

            p->next = lastNode;

            lastNode->next = next;

            p = next;

        }

    }

};
```

#### 算法可视化

算法可视化

### 20\. 有效的括号

**20\. 有效的括号** | [力扣](https://leetcode.cn/problems/valid-parentheses/) | [LeetCode](https://leetcode.com/problems/valid-parentheses/)

给定一个只包括 `'('` ， `')'` ， `'{'` ， `'}'` ， `'['` ， `']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**提示：**

- `1 <= s.length <= 10<sup>4</sup>`
- `s` 仅由括号 `'()[]{}'` 组成

题目来源： [力扣 20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 。

#### 基本思路

栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

括号的有效性判断在笔试中和现实中都很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 `[](){}` ，判断起来有一点难度。

解决这个问题之前，我们先降低难度，思考一下， **如果只有一种括号 `()`** ，应该如何判断字符串组成的括号是否有效呢？

假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：

**每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配** 。

比如说字符串 `()))((` 中，中间的两个右括号 **左边** 就没有左括号匹配，所以这个括号组合是无效的。

那么根据这个思路，我们可以写出算法：

```
boolean isValid(String str) {

    // 待匹配的左括号数量

    int left = 0;

    for (int i = 0; i < str.length(); i++) {

        if (str.charAt(i) == '(') {

            left++;

        } else {

            // 遇到右括号

            left--;

        }

        // 右括号太多

        if (left == -1)

            return false;

    }

    // 是否所有的左括号都被匹配了

    return left == 0;

}
```

如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 `left1` ， `left2` ， `left3` 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。

但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 `(())` 是有效的，但是多种括号的情况下， `[(])` 显然是无效的。

仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。

我们这道题就用一个名为 `left` 的栈代替之前思路中的 `left` 变量， **遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配** 。

#### 解法代码

```
class Solution {

public:

    bool isValid(string str) {

        stack<char> left;

        for (char c : str) {

            if (c == '(' || c == '{' || c == '[') {

                // 字符 c 是左括号，入栈

                left.push(c);

            } else {

                // 字符 c 是右括号

                if (!left.empty() && leftOf(c) == left.top()) {

                    left.pop();

                } else {

                    // 和最近的左括号不匹配

                    return false;

                }

            }

        }

        // 是否所有的左括号都被匹配了

        return left.empty();

    }

private:

    char leftOf(char c) {

        if (c == '}') return '{';

        if (c == ')') return '(';

        return '[';

    }

};
```

#### 算法可视化

算法可视化

**详细题解**:

- [编程语言刷题实践](https://labuladong.online/zh/algo/programming-language-basic/lc-practice/)

### 150\. 逆波兰表达式求值

**150\. 逆波兰表达式求值** | [力扣](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) | [LeetCode](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'` 、 `'-'` 、 `'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

**提示：**

- `1 <= tokens.length <= 10<sup>4</sup>`
- `tokens[i]` 是一个算符（ `"+"` 、 `"-"` 、 `"*"` 或 `"/"` ），或是在范围 `[-200, 200]` 内的一个整数

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * ` 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

题目来源： [力扣 150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 。

#### 基本思路

逆波兰表达式发明出来就是为了方便计算机运用「栈」进行表达式运算的，其运算规则如下：

按顺序遍历逆波兰表达式中的字符，如果是数字，则放入栈；如果是运算符，则将栈顶的两个元素拿出来进行运算，再将结果放入栈。对于减法和除法，运算顺序别搞反了，栈顶第二个数是被除（减）数。

所以这题很简单，直接按照运算规则借助栈计算表达式结果即可。

#### 解法代码

```
#include <vector>

#include <string>

#include <stack>

class Solution {

public:

    int evalRPN(vector<string>& tokens) {

        std::stack<int> stk;

        for (const std::string& token : tokens) {

            if (token == "+" || token == "-" || token == "*" || token == "/") {

                // 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈

                int a = stk.top(); stk.pop();

                int b = stk.top(); stk.pop();

                if (token == "+") stk.push(b + a);

                else if (token == "*") stk.push(b * a);

                else if (token == "-") {

                    // 对于减法和除法，顺序别搞反了，第二个数是被除（减）数

                    stk.push(b - a);

                }

                else if (token == "/") stk.push(b / a);

            } else {

                // 是个数字，直接入栈即可

                stk.push(std::stoi(token));

            }

        }

        // 最后栈中剩下一个数字，即是计算结果

        return stk.top();

    }

};
```

#### 算法可视化

算法可视化

### 225\. 用队列实现栈

**225\. 用队列实现栈** | [力扣](https://leetcode.cn/problems/implement-stack-using-queues/) | [LeetCode](https://leetcode.com/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（ `push` 、 `top` 、 `pop` 和 `empty` ）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back` 、 `peek/pop from front` 、 `size` 和  `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列, 只要是标准的队列操作即可。

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push` 、 `pop` 、 `top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

**进阶：** 你能否仅用一个队列来实现栈。

题目来源： [力扣 225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) 。

#### 基本思路

底层用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。

底层队列只能向队尾添加元素，所以栈的 `pop` API 相当于要从队尾取元素：

![](https://labuladong.online/images/algo/stack-queue/5.jpg)

那么最简单的思路就是，把队尾元素前面的所有元素重新塞到队尾，让队尾元素排到队头，这样就可以取出了：

![](https://labuladong.online/images/algo/stack-queue/6.jpg)

#### 解法代码

```
class MyStack {

    queue<int> q;

    int top_elem = 0;

public:

    // 将元素 x 压入栈顶

    void push(int x) {

        // x 是队列的队尾，是栈的栈顶

        q.push(x);

        top_elem = x;

    }

    // 返回栈顶元素

    int top() {

        return top_elem;

    }

    // 删除栈顶的元素并返回

    int pop() {

        int size = q.size();

        // 留下队尾 2 个元素

        while (size > 2) {

            q.push(q.front());

            q.pop();

            size--;

        }

        // 记录新的队尾元素

        top_elem = q.front();

        q.push(q.front());

        q.pop();

        // 删除之前的队尾元素

        int result = q.front();

        q.pop();

        return result;

    }

    // 判断栈是否为空

    bool empty() {

        return q.empty();

    }

};
```

#### 算法可视化

算法可视化

**详细题解**:

- [队列实现栈以及栈实现队列](https://labuladong.online/zh/algo/data-structure/stack-queue/)

### 388\. 文件的最长绝对路径

**388\. 文件的最长绝对路径** | [力扣](https://leetcode.cn/problems/longest-absolute-file-path/) | [LeetCode](https://leetcode.com/problems/longest-absolute-file-path/)

假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：

![](https://labuladong.online/images/lc/uploads/2020/08/28/mdir.jpg)

这里将 `dir` 作为根目录中的唯一目录。 `dir` 包含两个子目录 `subdir1` 和 `subdir2` 。 `subdir1` 包含文件 `file1.ext` 和子目录 `subsubdir1` ； `subdir2` 包含子目录 `subsubdir2` ，该子目录下包含文件 `file2.ext` 。

在文本格式中，如下所示(⟶表示制表符)：

```
dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
```

如果是代码表示，上面的文件系统可以写为 `"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"` 。 `'\n'` 和 `'\t'` 分别是换行符和制表符。

文件系统中的每个文件和文件夹都有一个唯一的 **绝对路径** ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 `'/'` 连接。上面例子中，指向 `file2.ext` 的 **绝对路径** 是 `"dir/subdir2/subsubdir2/file2.ext"` 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 `name.extension` 的格式，其中 `name` 和 `extension` 由字母、数字和/或空格组成。

给定一个以上述格式表示文件系统的字符串 `input` ，返回文件系统中 *指向 **文件** 的 **最长绝对路径** 的长度* 。 如果系统中没有文件，返回 `0` 。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2020/08/28/dir1.jpg)
```
输入：input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
输出：20
解释：只有一个文件，绝对路径为 "dir/subdir2/file.ext" ，路径长度 20
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2020/08/28/dir2.jpg)
```
输入：input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
输出：32
解释：存在两个文件：
"dir/subdir1/file1.ext" ，路径长度 21
"dir/subdir2/subsubdir2/file2.ext" ，路径长度 32
返回 32 ，因为这是最长的路径
```

**示例 3：**

```
输入：input = "a"
输出：0
解释：不存在任何文件
```

**示例 4：**

```
输入：input = "file1.txt\nfile2.txt\nlongfile.txt"
输出：12
解释：根目录下有 3 个文件。
因为根目录中任何东西的绝对路径只是名称本身，所以答案是 "longfile.txt" ，路径长度为 12
```

**提示：**

- `1 <= input.length <= 10<sup>4</sup>`
- `input` 可能包含小写或大写的英文字母，一个换行符 `'\n'` ，一个制表符 `'\t'` ，一个点 `'.'` ，一个空格 `' '` ，和数字。

题目来源： [力扣 388. 文件的最长绝对路径](https://leetcode.cn/problems/longest-absolute-file-path/) 。

#### 基本思路

我觉得这道题还是比较实用的，因为在我做这道题之前，我就思考并解决过这个问题，可以在这里和大家分享下我的使用场景：

你可以看我的 [GitHub 仓库中的文章目录](https://github.com/labuladong/fucking-algorithm#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95) ，是通过缩进来表示层级的，很类似本题所说的场景。然而我需要把这些目录转化成 HTML 文档，按照文件目录的形式把这些 HTML 部署到 [我的网站](https://labuladong.gitee.io/algo/) 上。你看，这是不是就涉及到本题生成文件的绝对路径的问题？

对于这个场景，我当时其实尝试很多可行的办法。但这里我还是写一个最简单直接容易理解的解法吧，那就是用栈来辅助，对于每一个路径，都去维护正确的父路径，从而计算最长路径的长度。具体看代码注释吧。

#### 解法代码

```
#include <deque>

#include <string>

#include <vector>

#include <algorithm>

using namespace std;

class Solution {

public:

    int lengthLongestPath(string input) {

        // 这个栈存储之前的父路径。实际上这里只用存父路径的长度就够了，这个优化留给你吧

        deque<int> stack;

        int maxLen = 0;

        vector<string> parts = split(input, '\n');

        for (const string& part : parts) {

            int level = part.rfind("\t") + 1;

            // 让栈中只保留当前目录的父路径

            while (level < stack.size()) {

                stack.pop_back();

            }

            stack.push_back(part.size() - level);

            // 如果是文件，就计算路径长度

            if (part.find('.') != string::npos) {

                int sum = 0;

                for (int len : stack) {

                    sum += len;

                }

                // 加上父路径的分隔符

                sum += stack.size() - 1;

                maxLen = max(maxLen, sum);

            }

        }

        return maxLen;

    }

private:

    vector<string> split(const string& s, char delimiter) {

        vector<string> tokens;

        string token;

        istringstream tokenStream(s);

        while (getline(tokenStream, token, delimiter)) {

            tokens.push_back(token);

        }

        return tokens;

    }

};
```

#### 算法可视化

算法可视化

## 栈的设计题

除了上面几道题，还有一类常考题目是让你设计具备额外功能的栈结构。

### 155\. 最小栈

**155\. 最小栈** | [力扣](https://leetcode.cn/problems/min-stack/) | [LeetCode](https://leetcode.com/problems/min-stack/)

设计一个支持 `push` ， `pop` ， `top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `-2<sup>31</sup> <= val <= 2<sup>31</sup> - 1`
- `pop` 、 `top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and  `getMin` 最多被调用  `3 * 10<sup>4</sup>` 次

题目来源： [力扣 155. 最小栈](https://leetcode.cn/problems/min-stack/) 。

#### 基本思路

[根据我们之前亲自动手实现的栈](https://labuladong.online/zh/algo/data-structure-basic/queue-stack-basic/) ，我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 `getMin` 方法，只能老老实实把所有元素弹出来然后找最小值。 **想提高时间效率，那肯定要通过空间换时间的思路** 。

不过在具体说解法之前，我想聊一下动态集合中维护最值的问题。这类问题看似简单，但实际上是个很棘手的问题。其实本题就是如下一个场景：

假设你有若干数字，你用一个 `min` 变量维护了其中的最小值，如果现在给这些数字中添加一个新数字，那么只要比较这个新数字和 `min` 的大小就可以得出最新的最小值。但如果现在从这些数字钟删除一个数字，你还能用 `min` 变量得到最小值吗？答案是不能，因为如果这个被删除的数字恰好是最小值，那么新的 `min` 变量应该更新为第二小的元素对吧，但是我没有记录第二小的元素是多少，所以只能把所有数字重新遍历一遍。

明确了难点再回到本题，就可以对症下药了。删除栈顶元素的时候，不确定新的最小值是多少，但楼下那哥们知道啊，他当时入栈时的最小值，就是现在的最小值呗。

所以这道题的关键就是， **每个元素入栈时，还要记下来当前栈中的最小值** 。比方说，可以用一个额外的栈 `minStk` 来记录栈中每个元素入栈时的栈中的最小元素是多少，这样每次删除元素时就能快速得到剩余栈中的最小元素了。

![](https://labuladong.online/images/algo/brief-extra/155.jpeg)

当然，我们还可以做一些优化，减少 `minStk` 中存储的元素个数，我把原始解法和优化解法都写出来了，供参考。

> PS：这道题并不难，但我还是很细致地分析了，希望你深刻理解其中的难点。下一步可以做一下 [239\. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/) ，请仔细观察和思考，队列结构是如何解决这个难点的。

#### 解法代码

```
// 原始思路

class MinStack1 {

    // 记录栈中的所有元素

    stack<int> stk;

    // 阶段性记录栈中的最小元素

    stack<int> minStk;

public:

    void push(int val) {

        stk.push(val);

        // 维护 minStk 栈顶为全栈最小元素

        if (minStk.empty() || val <= minStk.top()) {

            // 新插入的这个元素就是全栈最小的

            minStk.push(val);

        } else {

            // 插入的这个元素比较大

            minStk.push(minStk.top());

        }

    }

    

    void pop() {

        stk.pop();

        minStk.pop();

    }

    

    int top() {

        return stk.top();

    }

    

    int getMin() {

        // minStk 栈顶为全栈最小元素

        return minStk.top();

    }

};

// 优化版

class MinStack {

    // 记录栈中的所有元素

    stack<int> stk;

    // 阶段性记录栈中的最小元素

    stack<int> minStk;

public:

    void push(int val) {

        stk.push(val);

        // 维护 minStk 栈顶为全栈最小元素

        if (minStk.empty() || val <= minStk.top()) {

            // 新插入的这个元素就是全栈最小的

            minStk.push(val);

        }

    }

    void pop() {

        // 注意 Java 的语言特性，比较 Integer 相等要用 equals 方法

        if (stk.top() == minStk.top()) {

            // 弹出的元素是全栈最小的

            minStk.pop();

        }

        stk.pop();

    }

    int top() {

        return stk.top();

    }

    int getMin() {

        // minStk 栈顶为全栈最小元素

        return minStk.top();

    }

};
```

#### 算法可视化

算法可视化

### 895\. 最大频率栈

**895\. 最大频率栈** | [力扣](https://leetcode.cn/problems/maximum-frequency-stack/) | [LeetCode](https://leetcode.com/problems/maximum-frequency-stack/)

设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出 **出现频率** 最高的元素。

实现 `FreqStack` 类:

- `FreqStack()` 构造一个空的堆栈。
- `void push(int val)` 将一个整数 `val` 压入栈顶。
- `int pop()` 删除并返回堆栈中出现频率最高的元素。
	- 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。

**示例 1：**

```
输入：
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
```

**提示：**

- `0 <= val <= 10<sup>9</sup>`
- `push`  和 `pop`  的操作数不大于 `2 * 10<sup>4</sup>` 。
- 输入保证在调用 `pop` 之前堆栈中至少有一个元素。

题目来源： [力扣 895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/) 。

#### 基本思路

**这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API** 。

那么，我们仔细思考一下 `push` 和 `pop` 方法，难点如下：

1、每次 `pop` 时，必须要知道频率最高的元素是什么。

2、如果频率最高的元素有多个，还得知道哪个是最近 `push` 进来的元素是哪个。

为了实现上述难点，我们要做到以下几点：

1、肯定要有一个变量 `maxFreq` 记录当前栈中最高的频率是多少。

2、我们得知道一个频率 `freq` 对应的元素有哪些，且这些元素要有时间顺序。

3、随着 `pop` 的调用，每个 `val` 对应的频率会变化，所以还得维持一个映射记录每个 `val` 对应的 `freq` 。

综上，我们可以先实现 `FreqStack` 所需的数据结构：

```
class FreqStack {

    // 记录 FreqStack 中元素的最大频率

    int maxFreq = 0;

    // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表

    HashMap<Integer, Integer> valToFreq = new HashMap<>();

    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表

    HashMap<Integer, Stack<Integer>> freqToVals = new HashMap<>();

}
```

其实这有点类似前文 [手把手实现 LFU 算法](https://labuladong.online/zh/algo/frequency-interview/lfu/) ，注意 `freqToVals` 中 `val` 列表用一个栈实现，如果一个 `freq` 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。

具体看解法代码吧，要记住在 `push` 和 `pop` 方法中同时修改 `maxFreq` 、 `VF` 表、 `FV` 表，否则容易出现 bug。

算法执行过程如下 GIF 所示：

![](https://labuladong.online/images/algo/freq-stack/1.gif)

#### 解法代码

```
#include <unordered_map>

#include <stack>

using namespace std;

class FreqStack {

    // 记录 FreqStack 中元素的最大频率

    int maxFreq = 0;

    // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表

    unordered_map<int, int> valToFreq;

    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表

    unordered_map<int, stack<int>> freqToVals;

public:

    void push(int val) {

        // 修改 VF 表：val 对应的 freq 加一

        int freq = valToFreq.count(val) ? valToFreq[val] + 1 : 1;

        valToFreq[val] = freq;

        // 修改 FV 表：在 freq 对应的列表加上 val

        freqToVals[freq].push(val);

        // 更新 maxFreq

        maxFreq = max(maxFreq, freq);

    }

    int pop() {

        // 修改 FV 表：pop 出一个 maxFreq 对应的元素 v

        int v = freqToVals[maxFreq].top();

        freqToVals[maxFreq].pop();

        // 修改 VF 表：v 对应的 freq 减一

        valToFreq[v]--;

        // 更新 maxFreq

        if (freqToVals[maxFreq].empty()) {

            // 如果 maxFreq 对应的元素空了

            maxFreq--;

        }

        return v;

    }

};
```

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论(26)

Markdown

Ctrl+Enter 发表

?

匿名用户 12 天前

388 觉得自己的版本更简洁一些

```
function longestPathToFile(path) {

    if (!path) return 0;

    

    let pathArr = path.split('\n')

    let maxPath = ''

    let stack = []

    

    for(let el of pathArr) {

        // 计算当前层级（\t的数量）

        const level = el.lastIndexOf('\t') + 1    

        

        // 保持栈深度与层级一致

        while(stack.length > level) {

            stack.pop()

        }

        

        // 添加当前部分

        stack.push(el.slice(level))

        

        // 如果是文件，更新最长路径

        if(el.includes('.')) {

            let fullPath = stack.join('/')

            if (fullPath.length > maxPath.length) {

                maxPath = fullPath

            }

        }

    }

    

    return maxPath.length

}
```

Y

yali li 15 天前

只是理解题意就得都好几遍，还不一定懂

![pure](https://thirdwx.qlogo.cn/mmopen/vi_32/Jlg9Y3HQAzGunJur1AEicXEaOXWqXPGWUfXQK6AibWqdYXicXMH7rzbeabttibUzOEoQrpoT9bmZ2a9XEOWPgoMSc6uvibIaoDlanlZ9Gb0Za408/132)

pure 2 个月前

71题能否给出题目清晰易懂的解释,有时候算法确实简单,但是题目意思读不懂

L

Lu X 3 个月前

关于143题，我觉得结束条件写成 if p.next == lastNode or p == lastNode:更直观 更好理解一些，想给朋友们一个参考。

![阿飞](https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eobdib6tdOdf8NqV6Qo0EjMfMdp8uuKRd6Xoo06wH1Xe6myJleJQtHuLPVO9ZPFac74Ic7CHn1hLdg/132)

阿飞 大约 1 年前

作者大大，个位大佬，我有个问题，我做了 388 题，我先是没看答案的思路，先自己做的，没使用 split 函数处理，而是一个一个字符处理，debug了好久，终于做出来了，但是我感觉这样好难啊，这是为什么呢，有什么办法解决呢？主要是因为我担心面试官不让使用 split 函数，下边是我实现的代码：

```
class Solution {

    public int lengthLongestPath(String input) {

        /*

         分析：

         1.遇到 \ 要特殊处理

         2.记录当前有多少个 \t ,0个，1个，2个....

         3.随时记录长度，入栈一个记录一个长度，一遍后期相加

         4.只计算文件的绝对路径长度, 目录的不算

         5."每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成"

         1.这句话是有问题的，没有 / ，我在自己造测试用例的时候试过

         6.根据我对测试用例的测试，发现\只会出现在 n 或者 t 前边

         */

        Stack<String> stack = new Stack<>();

        int len = 0; // 随着入栈出栈的元素而不断变化的长度

        int maxLen = 0; // 最后要的最终的最长的长度

        int tabNum = 0;

        StringBuilder sb = new StringBuilder();

        boolean isFile = false; // 当前是否是文件

        int n = input.length();

        for (int i=0;i<n;i++) {

            char c = input.charAt(i);

            /*

             主要区分：

             1.\n

             2.\t

             3. .

             4.其他

             */

             if (c=='\n') {

                // 1.总结前边的, 但是这样的话，就可能会有最后一个没总结到

                // 还有一件事：当前目录层级如果没有之前那么深的话，得退栈

                while (stack.size()>tabNum) {

                    String str = stack.pop();

                    len -= str.length();

                }

                if (isFile) {

                    maxLen = Math.max(maxLen, len + sb.length());

                } else {

                    // 不是文件的话

                    // 最后还加一个 / 进去，主要是为了计算长度

                    sb.append('/');

                    stack.push(sb.toString());

                    len += sb.length();

                }

                // 1.1. 清理掉 sb

                sb.setLength(0);

                tabNum = 0;

                isFile = false;

                // 2.数后边有多少个 \t

                while (i+1<n && input.charAt(i+1)=='\t') {

                    tabNum++;

                    i++;

                }

            } else {

                // 其他就是数组字母空格啥的

                sb.append(c);

                 if (c=='.') {

                     isFile = true;

                 }

            }

        }

        // 最后还需要做一次，因为我是根据 \n 来做结算的

        while (stack.size()>tabNum) {

            String str = stack.pop();

            len -= str.length();

        }

        if (isFile) {

            maxLen = Math.max(maxLen, len+sb.length());

        }

        return maxLen;

    }

}
```

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 大约 1 年前

如果不让用 split，那么你可以单独实现一个自己的 split 函数，而不是把逻辑和算法题混在一起，这样会清晰一些。

![阿飞](https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eobdib6tdOdf8NqV6Qo0EjMfMdp8uuKRd6Xoo06wH1Xe6myJleJQtHuLPVO9ZPFac74Ic7CHn1hLdg/132)

阿飞 回复 @labuladong 大约 1 年前

ok，谢了哈，作者大大

![阿废](https://thirdwx.qlogo.cn/mmopen/vi_32/vu8RicH8mPsCC1EaZEXSm7iaicgcYKSCzibF4VF6ic5xmvuCHcPwncOBbqbk0ibxeIgn3WrEeicCN0qnDjXQSkHCbokIqccic7oEbxQnY0u6cbNOmn0/132)

阿废 10 个月前

最大频率栈主要是存储的结构想不出来，知道空间换时间也不知道数据结构怎么建立，还是能力不足，看着作者题解的数据结构，尝试写就很顺利a掉了，全称只要维护好三个属性就可以。

Y

Yunchen Liu 4 个月前

分享一点895的思路

## 理解需求

几乎可以确定，需要用 空间换时间，但具体怎么做呢？

使用 栈（stack） 来记录每一步的最高频元素（类似 155. 最小栈）是不够的。 因为它不是 FILO（先进后出） 的。例如序列 5,7,5,7,4,5 中，第二个 5 和 7 是比 4 先加入的，但它们却更容易被弹出。

从暴力法开始，看看如何计算

## \[解法 1 - 暴力法\]

每次操作，只要知道：

每个元素的 频率

每个元素的 索引

就可以计算出要弹出的元素：

首先找到 频率最大的值

然后在所有该频率的元素中，找到 索引最大的元素

这种方法时间复杂度是 O(n)，显然不够高效，但它显示了一个关键点：

结果可以理解为一个 排序问题：先按频率排序，再按索引排序。

所以，如果记录每个元素当前的 频率、索引和值，问题就变成了 动态地添加/删除元素、排序，并查询最大值。 这正是 PriorityQueue（优先队列） 可以解决的问题，于是出现了第二种解法。

## \[解法 2 - 优先队列 PQ\]

维护一个 优先队列 PQ，队列元素是 \[频率, 索引, 值\]

比较时先比频率，再比索引（不会出现两者同时相等的情况）

举例序列 5,7,5,7,4,5：

插入 PQ 的元素顺序是：

\[1,0,5\], \[1,1,7\], \[2,2,5\], \[2,3,7\], \[1,4,4\], \[3,5,5\]

弹出顺序：

pop \[3,5,5\] -> 剩下 \[1,0,5\],\[1,1,7\],\[2,2,5\],\[2,3,7\],\[1,4,4\] pop \[2,3,7\] -> 剩下 \[1,0,5\],\[1,1,7\],\[2,2,5\],\[1,4,4\] pop \[2,2,5\] -> 剩下 \[1,0,5\],\[1,1,7\],\[1,4,4\] pop \[1,4,4\] -> 剩下 \[1,0,5\],\[1,1,7\] pop \[1,1,7\] -> 剩下 \[1,0,5\]

这种方法可以通过 LeetCode，但时间复杂度是 O(log n)。 进一步优化可以发现，这不是随机排序的数据，数据有规律：

频率只能 +1 或 -1，如果某个频率 x 的所有元素被弹出，那么一定存在频率 x-1 的元素

对于每个频率，它的元素是 FILO 弹出的

对于每个数字，它的弹出顺序是 FILO

回到暴力法的思路

“先找到最大频率” → 可以维护一个 max\_freq，它只会 +1 或 -1，因此 O(1) 更新/获取

“在该频率下，索引最大的元素是谁” → 对每个频率维护一个列表（栈），下一个要弹出的元素总是列表的最后一个

于是出现第三种解法。

## \[解法 3 - 哈希表 + 栈\]

itemToFreq: 元素 → 频率

freqToItems: 频率 → 对应元素栈（FILO）

max\_freq: 当前最大频率

这是官方答案的思路，所有操作均可 O(1)

举例序列 5,7,5,7,4,5：

频率 1 -> \[5, 7, 4\] 频率 2 -> \[5, 7\] 频率 3 -> \[5\]

弹出顺序是：从右到左、从栈顶到底。

## 总结

实际上，从解法 1 可以直接跳到解法 3，如果结合解法 2 后面部分的思路。

## 附录 解法2的代码

```
class FreqStack {

    PriorityQueue<int[]> pq;

    Map<Integer, Integer> freq;

    int index = 0;

    public FreqStack() {

        pq = new PriorityQueue<>(

            (x, y) -> {

                if (x[0] != y[0]) return Integer.compare(y[0], x[0]); // a descending

                return Integer.compare(y[1], x[1]); // b descending

            }

        );

        freq = new HashMap<>();

    }

    

    public void push(int val) {

        freq.put(val, freq.getOrDefault(val, 0) + 1);

        pq.add(new int[]{freq.get(val), index, val});

        index += 1;

    }

    

    public int pop() {

        int[] result = pq.poll();

        int val = result[2];

        freq.put(val, freq.get(val) - 1);

        return val;

    }

}
```

![Enzo](https://thirdwx.qlogo.cn/mmopen/vi_32/49rOndNxDxib9DwM9lPvr7duN0RW7sQ2IY0vCdgR8mA6QgiaMyGGUKUKL8WM0BaSJry9RSnr1XwWiczULqdDGrA7GG1xk06HcQMhia6EmvIQxY8/132)

Enzo 4 个月前

这个理解成本蛮低的

![JJ](https://thirdwx.qlogo.cn/mmopen/vi_32/H3qZ0EcWw9jJNbvZHgF5Uic3hZFyPYuUkuKsBqoZSHl1z4fFYocXPaayaCknTnTEgAENbVYllWf3uKdFr3dt2iaiaibO1hujtwicwTFbY7S7SianU/132)

JJ 10 个月前

简短版本的C++答案

```
class Solution {

public:

        int lengthLongestPath(string input) {

            int res = 0;                     // 结果：最长文件路径长度

            stack<int> stk;                  // 存储每个层级的路径累计长度

            stk.push(-1);                    // 初始化栈顶值，用于计算根目录长度

    

            string line;                     // 临时存储每行内容

            stringstream ss(input);          // 按换行符分割输入字符串

    

            while (getline(ss, line, '\n')) { // 逐行处理

                    // 计算当前行的层级深度（\t的数量）

                    int depth = line.rfind('\t') + 1; // 无\t时depth=0，表示根层级

        

                    // 保持栈深度与当前层级一致

                    while (depth != stk.size() - 1) {

                        stk.pop();               // 弹出过深的层级

                    }

        

                    // 计算当前行累计路径长度 = 父级长度 + 当前内容长度 + 1 (分隔符/)

                    int currLen = line.size() - depth + stk.top() + 1;

        

                    // 如果是文件，更新最长路径；否则压栈供子目录使用

                    if (line.find('.') != string::npos) {

                       res = max(res, currLen); // 文件路径不需要末尾的/

                    } else {

                    stk.push(currLen);       // 目录压栈，后续层级基于此计算

                    }

               }

            return res; 

    }

};
```

![郑力鸣有点无敌🐯](https://thirdwx.qlogo.cn/mmopen/vi_32/bf5g1dEhZEOHpwxfsE4CYLkjRBPn0zgssiaInUeYj6cHupRF11AgYOK1ksXLne9ZI3tia4Y9yTa5siaxcGQricL37g/132)

郑力鸣有点无敌🐯 大约 1 年前

分享个单调栈做法思路（push操作多时会超时）：每次加入元素时对比栈顶元素的频率（while loop），直到找到栈顶元素的出现频次小于等于要加入的元素的频次时将其加入栈。这样我们栈顶永远是凭此出现最高的元素。这里频次我们用一个hashmap来映射。虽然这种方法pop是O（1）的时间，但是push却是O（n）的时间，当push数量多时消耗会比较大造成超时。 东哥能看看这个还能优化吗？

```
class FreqStack {

    Stack<Integer> stack;

    Stack<Integer> tempStack;

    Map<Integer, Integer> freq;

    public FreqStack() {

        stack = new Stack<>();

        tempStack = new Stack<>();

        freq = new HashMap<>();

    }

    public void push(int val) {

        freq.put(val, freq.getOrDefault(val, 0) + 1);

        if(stack.isEmpty()) {

            stack.push(val);

            return;

        }

        while(!stack.isEmpty() && freq.get(stack.peek()) > freq.get(val)) {

            int top = stack.pop();

            tempStack.push(top);

            freq.put(top, freq.get(top) - 1);

        }

        stack.push(val);

        while(!tempStack.isEmpty()) {

            int top = tempStack.pop();

            stack.push(top);

            freq.put(top, freq.get(top) + 1);

        }

    }

    public int pop() {

        int top = stack.pop();

        freq.put(top, freq.get(top) - 1);

        return top;

    }

}
```

![大大彭](https://thirdwx.qlogo.cn/mmopen/vi_32/lLMbKroZNib5CVrdaKUnk0icblb7iaNjskic7hZ9n2yIvAgx7zh3GWa0P7hht1EcIOEsscK3D8DmEicViaUPdz1R08Gvjrxic99Du0RlZfMaEQicvl4/132)

大大彭 大约 1 年前

```
// 分享一下我自己写的388题，思路和东哥的一样，但是简洁一些哈哈哈

int lengthLongestPath(string input) {

    int ans = 0;

    stack<int> stk;

    stk.push(-1);

    string part;

    stringstream ss(input);

    while (getline(ss, part, '\n')) {

        int cpos = part.rfind('\t') + 1;

        while (cpos != stk.size() - 1)

            stk.pop();

        int len = part.size() - cpos + stk.top() + 1;

        if (part.find('.') != string::npos)

            ans = max(ans, len);

        else

            stk.push(len);

    }

    return ans;

}
```

Z

Zhihan Xu 4 个月前

建议143题可以提一下用之前讲解过的的链表技巧（快慢指针，反转链表，合并链表）也可以解决，不需要额外的stack

B

Bryan Lin 6 个月前

打卡

![DB小左](https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibLyyr2ibj2Q2qBpCrMPSN441KVpgrY5Wr8mImCEFdUM9577nibSGkoYSjEh17m0WppUSDUgN4TFrg/132)

DB小左 7 个月前

388的一点拙见，没用split

```
class Solution {

public:

    int lengthLongestPath(string input) {

        int n = input.size();

        int maxsize = 0;

        int ind = 0;

        deque<int> stk;

        

        while(ind < n){

            //处理当前文件部分的字符，直到遇到换行，我们就得到了长度和层级

            int level = 0;

            int subsize = 0;

            bool isfile = false;

            while(ind < n && input[ind] != '\n'){

                if(input[ind] == '\t') level ++;

                else subsize ++;

                if(input[ind] == '.') isfile = true;

                ind ++;

            }

            //我们统计的是当前这个子树的长度，前面多余的枝条要回退,然后插入新的节点长度

            while(level < stk.size()){

                stk.pop_back();

            }

            stk.push_back(subsize);

            //做完这些之后，开始计算当前枝条长度,只计算文件

            if(isfile){

                int currentsize = 0;

                for(int len : stk){

                    currentsize += len;

                }

                currentsize += stk.size() - 1;

                maxsize = max(maxsize , currentsize);

            }

            

            //因为ind一定停在\n这个位置，所以跳一位

            ind ++;

        }

        return maxsize;

    }

};
```

![欢乐马](https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6cG1D6zeicmo5OrFgN1vldbWficJWt1qqkXNcQke25330VQcpak4icpvzqs8nicblKHTC3Jz9ia4LzAvw/132)

欢乐马 大约 1 年前

逆波兰表达式求值超时

J

Justin 大约 1 年前

```
class Solution {

public int lengthLongestPath(String input) {

    Stack<Integer> stk = new Stack<>();

    stk.push(0);

    int maxLen = 0;

    String[] entries = input.split("\n");

    for (String entry : entries) {

        int depth = entry.lastIndexOf("\t") + 1;

        while (stk.size() > depth + 1) {

            stk.pop();

        }

        int currLen = stk.peek() + entry.length() - depth + 1;

        stk.push(currLen);

        if (entry.contains(".")) {

            maxLen = Math.max(maxLen, currLen - 1);

        }

    }

    return maxLen;

}
```

}

N

Nightglow8088 大约 1 年前

388我看leetcode有个哥们的优化回答挺好的 分享给大家

Luke Chang: 稍长一点的版本。但我认为更容易理解。

1. 仅当位于根目录时才需要 -1。
2. 仅当它不是可执行文件时才添加到堆栈。

public static int lengthLongestPath(String input) { Stack<Integer> stack = new Stack<>(); stack.push(0); // Layer 0, dummy head int maxLen = 0; for(String s: input.split("\\n")) { int layer = s.lastIndexOf("\\t") + 1; // e.g. Layer 2 s: "\\t\\tsubsubdir1" while(layer < stack.size() - 1) stack.pop(); int length = stack.peek() + s.length() - layer + 1; // remove "\\t\\t..." add "" if(layer == 0) // dir has no "\\t" in the front length--; if(s.contains(".")) maxLen = Math.max(maxLen, length); else stack.push(length); } return maxLen; }

![Huuuuuu🌙](https://thirdwx.qlogo.cn/mmopen/vi_32/GHTvVB8wPbQ5uiaOMdepcKH8PfQMqLfTSlyoiblk2A2h48mau3RLmWejKppV6tcsEiaxG2VBgFiadbibrYZ9icJ3tytg/132)

Huuuuuu🌙 超过 1 年前

【根据我们之前亲自动手实现的栈】 中的超链接 链错了。

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 超过 1 年前

感谢指出，已修复

该评论已被折叠

该评论已被折叠

该评论已被折叠