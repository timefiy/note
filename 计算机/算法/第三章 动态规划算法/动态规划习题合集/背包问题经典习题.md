---
title: 背包问题经典习题
source: https://labuladong.online/zh/algo/problem-set/knapsack/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上所有 背包问题 的习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
背包问题是一类经典的动态规划问题，主要是在某个限制内，选择最优的元素组合。

其特点在于 `dp` 数组的定义方式，第一个维度的定义是「仅使用前 `i` 个物品」，之后的维度用来定义限制条件。

比如经典的 0-1 背包问题， `dp` 数组定义如下：

```
// 定义：dp[i][j] 表示使用前 i 个物品，背包容量为 j 的情况下，可以获得的最大价值

int[][] dp = new int[N + 1][W + 1];
```

下面列举几道和背包问题相关的题目，帮助大家加深理解。

### 1049\. 最后一块石头的重量 II

有一堆石头，用整数数组 `stones` 表示。其中  `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出 **任意两块石头** ，然后将它们一起粉碎。假设石头的重量分别为 `x` 和  `y` ，且  `x <= y` 。那么粉碎的可能结果如下：

- 如果 `x == y` ，那么两块石头都会被完全粉碎；
- 如果 `x != y` ，那么重量为  `x`  的石头将会完全粉碎，而重量为  `y`  的石头新重量为  `y-x` 。

最后， **最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0` 。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

题目来源： [力扣 1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) 。

#### 基本思路

这题的难点在于，如何看出它是一个背包问题。不过你看过 [子集背包问题](https://labuladong.online/zh/algo/dynamic-programming/knapsack2/) ，可能可以想到把这题转化成背包问题的方法。

任意两个石头会互相抵消，问你最后留下的石头重量，相当于是把 `stones` 数组分成两个子集，使得两个子集的重量差最小。

想要两个子集的重量差最小，那么两个子集的重量和应该尽可能接近 `sum/2` 。那么问题就转化为了背包问题：

给定一个容量为 `sum/2` 的背包和若干石头 `stones` ，请问这个背包能够装下的最大重量是多少？

这就是标准的 0-1 背包问题，我们可以这样定义 `dp` 数组：

```
int n = stones.length;

int sum = sum(stones);

// 定义：仅使用前 i 个石头，背包容量为 j 时，能够装下的最大重量为 dp[i][j]

int[][] dp = new int[n + 1][sum / 2 + 1];
```

对于第 `i` 个石头，我们有两种选择：装入背包或不装入背包。有如下状态转移方程：

```
if (j >= curStone) {

    // 可以装下第 i 个石头，则两种选择中取最大值

    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - curStone] + curStone);

} else {

    // 装不下第 i 个石头，则只能选择不装

    dp[i][j] = dp[i - 1][j];

}
```

最后， `dp[n][sum/2]` 就是背包容量为 `sum/2` 时，能够装下的最大重量，我们根据这个最大重量，就能推导出另一个子集的重量，进而求出两个子集的重量差。

#### 解法代码

```
class Solution {

public:

    int lastStoneWeightII(vector<int>& stones) {

        int sum = 0;

        for (int stone : stones) {

            sum += stone;

        }

        // 背包问题状态转移方程

        // 定义：仅使用前 i 个元素，背包容量为 j 时，能够装的最大重量为 dp[i][j]

        vector<vector<int>> dp(stones.size() + 1, vector<int>(sum / 2 + 1, 0));

        for (int i = 1; i <= stones.size(); i++) {

            // 当前石头重量，注意下标从 1 开始

            int curStone = stones[i - 1];

            for (int j = 0; j <= sum / 2; j++) {

                // 对于第 i 个物品，有两种情况：

                // 1. 不选第 i 个物品，则 dp[i][j] = dp[i - 1][j]

                // 2. 选第 i 个物品，则 dp[i][j] = dp[i - 1][j - curStone] + curStone

                if (j >= curStone) {

                    // 可以装下第 i 个物品，则两种选择中取最大值

                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - curStone] + curStone);

                } else {

                    // 装不下第 i 个物品，则只能选择不装

                    dp[i][j] = dp[i - 1][j];

                }

            }

        }

        // 背包容量为 sum/2 时，能够装的最大重量

        int maxWeight = dp[stones.size()][sum / 2];

        // 两个子集的重量差

        return sum - maxWeight - maxWeight;

    }

};
```

#### 算法可视化

算法可视化

### 474\. 一和零

**474\. 一和零** | [力扣](https://leetcode.cn/problems/ones-and-zeroes/) | [LeetCode](https://leetcode.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`

题目来源： [力扣 474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/) 。

#### 基本思路

既然他问到子集了，那我最直接的想法当然就是回溯算法计算子集，但是看下数据规模比较大，回溯肯定不行。而且题目又不是让你计算具体的子集，而仅仅问最大长度，这种场景一般都存在重叠子问题，应该用动态规划。

那么我的进一步想法就是背包问题了：标准的 0-1 背包问题，是在有限的背包容量下，计算物品的最大价值；这道题相当于背包有两个容量（0 和 1 的个数），然后计算最多能装多少个物品。

如果你没看过 [0-1 背包问题](https://labuladong.online/zh/algo/dynamic-programming/knapsack1/) 的讲解，务必先看一下，因为这道题的解法是基于 0-1 背包问题拓展出来的。

标准 0-1 背包问题的 `dp` 数组的定义是这样：

```
// dp[i][w] 的定义：

// 如果只使用前 i 个物品，背包的容量限制为 w，可以装的最大价值是 dp[i][w]。

int[][] dp = new int[N + 1][W + 1];
```

这道题可以给 `dp` 数组加一个维度，这样来定义：

```
// dp[i][j][k] 的定义：

// 如果只使用前 i 个字符串，0 和 1 的限制分别为 j 和 k，可以装的最大字符串数量是 dp[i][j][k]

int[][][] dp = new int[strs.length + 1][m + 1][n + 1];
```

状态转移方程：

```
if (j >= zeroCount && k >= oneCount) {

    dp[i][j][k] = Math.max(

        dp[i - 1][j - zeroCount][k - oneCount] + 1,

        dp[i - 1][j][k]

    );

} else {

    dp[i][j][k] = dp[i - 1][j][k];

}
```

具体看代码注释吧。

#### 解法代码

```
class Solution {

public:

    int findMaxForm(vector<string>& strs, int m, int n) {

        // 定义：

        // 如果只使用前 i 个字符串，0 和 1 的限制分别为 j 和 k

        // 可以装的最大字符串数量是 dp[i][j][k]

        vector<vector<vector<int>>> dp(strs.size() + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));

        // base case:

        // dp[0][..][..] = 0

        // 如果没有任何字符串，那么可以装的最大字符串数量就是 0

        // 从 base case 开始状态转移

        for (int i = 1; i <= strs.size(); i++) {

            // 注意有一位索引偏移

            string curStr = strs[i - 1];

            // 遍历每个字符串的 0 和 1 的个数

            int zeroCount = 0;

            int oneCount = 0;

            for (char c : curStr) {

                if (c == '0') zeroCount++;

                else oneCount++;

            }

            for (int j = 0; j <= m; j++) {

                for (int k = 0; k <= n; k++) {

                    if (j >= zeroCount && k >= oneCount) {

                        // 有足够的空间把当前字符串装进背包

                        // 可以选择装或者不装，都计算一下，取最大值

                        dp[i][j][k] = max(

                            // 选择装当前字符串

                            dp[i - 1][j - zeroCount][k - oneCount] + 1,

                            // 不装当前字符串

                            dp[i - 1][j][k]

                        );

                    } else {

                        // 没有足够的空间把当前字符串装进背包

                        // 只能选择不装

                        dp[i][j][k] = dp[i - 1][j][k];

                    }

                }

            }

        }

        // 按照定义，返回结果

        return dp[strs.size()][m][n];

    }

};
```

#### 算法可视化

算法可视化

### 3180\. 执行操作可获得的最大总奖励 I

给你一个整数数组 `rewardValues` ，长度为 `n` ，代表奖励的值。

最初，你的总奖励 `x` 为 0，所有下标都是 **未标记** 的。你可以执行以下操作 **任意次** ：

- 从区间 `[0, n - 1]` 中选择一个 **未标记** 的下标 `i` 。
- 如果 `rewardValues[i]` **大于** 你当前的总奖励 `x` ，则将 `rewardValues[i]` 加到 `x` 上（即 `x = x + rewardValues[i]` ），并 **标记** 下标 `i` 。

以整数形式返回执行最优操作能够获得的 **最大** 总奖励。

**示例 1：**

**输入：** rewardValues = \[1,1,3,3\]

**输出：** 4

**解释：**

依次标记下标 0 和 2，总奖励为 4，这是可获得的最大值。

**示例 2：**

**输入：** rewardValues = \[1,6,4,3,2\]

**输出：** 11

**解释：**

依次标记下标 0、2 和 1。总奖励为 11，这是可获得的最大值。

**提示：**

- `1 <= rewardValues.length <= 2000`
- `1 <= rewardValues[i] <= 2000`

题目来源： [力扣 3180. 执行操作可获得的最大总奖励 I](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/) 。

#### 基本思路

这个题有点意思，但是里面的一些细节有些难理解，初学读者可以跳过。

首先看数据规模，数组长度是 2000 的规模，那么你的算法复杂度大概不能超过 `O(N^2)` 的级别，所以回溯这种暴力穷举算法肯定不考虑。

再看题目求的是最值，那么大概率是动态规划了，我感觉这个题是 [0-1 背包问题](https://labuladong.online/zh/algo/dynamic-programming/knapsack1/) 的变体：

0-1 背包问题是在背包容量的限制下最大化物品的价值，物品不可以重复选择。

这个题的 `rewardValues` 就相当于是物品列表， `rewardValues[i]` 就相当于是第 `i` 个物品的价值，也是让你选择物品，使得物品的价值最大。

**唯一的区别是，这道题并没有给一个固定的背包最大容量作为限制，而是把当前背包中的总价值 `x` 作为限制，你仅可以选择价值大于 `x` 的物品装进背包** 。

背包中的总价值 `x` 最多能有多少呢？答案是最多为 `max(rewardValues) * 2 - 1` 。

假设 `rewardValues` 中的最大元素是 `rewardValues[i_max]` ，首先证明索引 `rewardValues[i_max]` 的这个元素一定会被装进背包来构成最大总价值，用反证法：

如果 `rewardValues[i_max]` 不装进背包，那么总是可以把背包中的最大元素替换成 `rewardValues[i_max]` 这个元素，获得一个更大的总价值。所以 `rewardValues[i_max]` 一定会被装进背包来构成最大总价值。

既然 `rewardValues[i_max]` 一定在背包中，那么其他元素之和必然小于 `rewardValues[i_max]` 。否则，如果其他元素和大于等于 `rewardValues[i_max]` 的话，按照题目要求 `rewardValues[i_max]` 这个元素就无法装进背包。

综上可知，背包中的总价值 `x < max(rewardValues) * 2` ，或者说 `x <= max(rewardValues) * 2 - 1` 。

最后，只需基于标准的 0-1 背包问题，改一改状态转移部分的逻辑，就可以解决这道题了。我们可以这样定义 `dp` 数组：

```
int n = rewardValues.length;

int maxVal = max(rewardValues);

// dp[i][x] 的定义：

// 如果只使用前 i 个物品，是否存在一种选择方案，使得背包中的价值达到 x

boolean[][] dp = new boolean[n + 1][maxVal * 2];
```

另外注意，这道题在进行状态转移之前需要对 `rewardValues` 进行排序。我做这道题时也卡在这个点了，按照一般的背包问题，不需要对物品做排序的，但这里就要做。

简单解释一下，因为一般的背包问题给定了一个固定的背包容量，而这道题相当于你背包里的物品价值用来限制你的选择了，所以这个题要尽可能先装小价值的物品，如果你直接装一个大价值的物品进去，会导致后面的小价值物品装不进去，最终的结果偏小。

具体看代码吧。

#### 解法代码

```
class Solution {

public:

    int maxTotalReward(vector<int>& rewardValues) {

        int n = rewardValues.size();

        // 注意，这里要对 rewardValues 从小到大排序

        sort(rewardValues.begin(), rewardValues.end());

        int maxVal = rewardValues[n - 1];

        // 定义：dp[i][x] 表示仅使用前 i 个物品，是否能凑出总价值为 x

        vector<vector<bool>> dp(n + 1, vector<bool>(maxVal * 2, false));

        // 基本情况

        dp[0][0] = true;

        // 状态转移

        for (int i = 1; i <= n; i++) {

            // 有一位索引偏移

            int curVal = rewardValues[i - 1];

            for (int x = 0; x < maxVal * 2; x++) {

                if (x >= curVal && curVal > x - curVal) {

                    // 当前物品可以装进背包

                    // 如果装进背包，就要看看在前 i-1 个物品中，背包容量为 x-curVal 时，是否存在一种选择方案

                    bool add = dp[i - 1][x - curVal];

                    // 如果不装进背包，那么就要看看前 i-1 个物品中，背包容量为 x 时，是否存在一种选择方案

                    bool notAdd = dp[i - 1][x];

                    dp[i][x] = add || notAdd;

                } else {

                    // 当前物品不能装进背包

                    // 那么就要看看前 i-1 个物品中，背包容量为 x 时，是否存在一种选择方案

                    dp[i][x] = dp[i - 1][x];

                }

            }

        }

        // 返回最大价值

        for (int j = maxVal * 2 - 1; j >= 0; j--) {

            if (dp[n][j]) {

                return j;

            }

        }

        return 0;

    }

};
```

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表