---
title: 打家劫舍问题模式
source: https://labuladong.online/zh/algo/problem-set/rob-house/
author:
  - "[[../../../../author/labuladong]]"
published:
created: 2026-02-17
description: 本文汇总了 力扣/LeetCode 上的抢房子问题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。
tags:
  - clippings
---
前置知识

阅读本文前，你需要先学习：

- [动态规划核心框架](https://labuladong.online/zh/algo/essential-technique/dynamic-programming-framework/)
- [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/)

对于动态规划类型的问题，读者总是说不知道如何设置 `dp` 函数/数组的定义。其实也不要畏惧，想办法往已知的题目、算法框架上靠，步步为营，总能找到一些突破口。

那么本文列举一些题目，它们的解法思路和 [打家劫舍系列问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) 有些类似，可以帮助大家强化这类题目的求解能力。

### 2140\. 解决智力问题

**2140\. 解决智力问题** | [力扣](https://leetcode.cn/problems/solving-questions-with-brainpower/) | [LeetCode](https://leetcode.com/problems/solving-questions-with-brainpower/)

给你一个下标从 **0**  开始的二维整数数组  `questions`  ，其中  `questions[i] = [points<sub>i</sub>, brainpower<sub>i</sub>]` 。

这个数组表示一场考试里的一系列题目，你需要 **按顺序** （也就是从问题 `0` 开始依次解决），针对每个问题选择 **解决** 或者 **跳过** 操作。解决问题 `i` 将让你 **获得** `points<sub>i</sub>` 的分数，但是你将 **无法** 解决接下来的 `brainpower<sub>i</sub>`  个问题（即只能跳过接下来的 `brainpower<sub>i</sub>` 个问题）。如果你跳过问题 `i` ，你可以对下一个问题决定使用哪种操作。

- 比方说，给你 `questions = [[3, 2], [4, 3], [4, 4], [2, 5]]` ：
	- 如果问题 `0`  被解决了， 那么你可以获得  `3`  分，但你不能解决问题  `1` 和  `2` 。
	- 如果你跳过问题 `0`  ，且解决问题  `1`  ，你将获得 `4` 分但是不能解决问题  `2` 和  `3` 。

请你返回这场考试里你能获得的 **最高** 分数。

**示例 1：**

```
输入：questions = [[3,2],[4,3],[4,4],[2,5]]
输出：5
解释：解决问题 0 和 3 得到最高分。
- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。
- 不能解决问题 1 和 2
- 解决问题 3 ：获得 2 分
总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。
```

**示例 2：**

```
输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
输出：7
解释：解决问题 1 和 4 得到最高分。
- 跳过问题 0
- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。
- 不能解决问题 2 和 3
- 解决问题 4 ：获得 5 分
总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。
```

**提示：**

- `1 <= questions.length <= 10<sup>5</sup>`
- `questions[i].length == 2`
- `1 <= points<sub>i</sub>, brainpower<sub>i</sub> <= 10<sup>5</sup>`

题目来源： [力扣 2140. 解决智力问题](https://leetcode.cn/problems/solving-questions-with-brainpower/) 。

#### 基本思路

这道题其实就是 [198\. 打家劫舍](https://leetcode.cn/problems/house-robber/description/) 问题，只不过换了个说法，改了下条件。

198 题是不能同时选择相邻的元素，求能够得到的最大元素和。

这道题是你选择了第 `i` 个元素后，就不能选择后面的 `questions[i][1]` 个元素了，求能够得到的最大元素和。

所以只需要定义这样一个 `dp` 函数：

```
// 定义：dp(i) 计算从 questions[i] 开始做题，所能获得的最大分数

int dp(int i)
```

那么对于每一道题 `questions[i]` ，我们可以选择做或者不做，也就获得了状态转移方程：

```
dp(i) = Math.max(

    // 选择做第 i 道题

    // 获得分数 questions[i][0]，然后跳过 questions[i][1] 道题

    questions[i][0] + dp(i + questions[i][1] + 1),

    // 选择不做第 i 道题

    // 直接跳过这道题，去看第 i + 1 道题

    dp(i + 1)

);
```

接下来就是动态规划标准步骤，这里给出带备忘录的递归解法。

改为迭代形式、优化 `dp` 数组等优化步骤，可以参见 [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) ，这里就不细说了。

#### 解法代码

```
class Solution {

    vector<long> memo;

public:

    long mostPoints(vector<vector<int>>& questions) {

        memo.resize(questions.size(), -1);

        return dp(questions, 0);

    }

    // 定义：dp(i) 计算从第 i 道题开始，所能获得的最大分数

    long dp(vector<vector<int>>& questions, int i) {

        if (i >= questions.size()) {

            return 0;

        }

        if (memo[i] != -1) {

            return memo[i];

        }

        memo[i] = max(

            // 选择做第 i 道题

            questions[i][0] + dp(questions, i + questions[i][1] + 1),

            // 选择不做第 i 道题

            dp(questions, i + 1)

        );

        return memo[i];

    }

};
```

#### 算法可视化

算法可视化

### 2320\. 统计放置房子的方式数

**2320\. 统计放置房子的方式数** | [力扣](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/) | [LeetCode](https://leetcode.com/problems/count-number-of-ways-to-place-houses/)

一条街道上共有 `n * 2` 个 **地块** ，街道的两侧各有 `n` 个地块。每一边的地块都按从 `1` 到 `n` 编号。每个地块上都可以放置一所房子。

现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 `10<sup>9</sup> + 7` 取余后再返回。

注意，如果一所房子放置在这条街某一侧上的第 `i` 个地块，不影响在另一侧的第 `i` 个地块放置房子。

**示例 1：**

```
输入：n = 1
输出：4
解释：
可能的放置方式：
1. 所有地块都不放置房子。
2. 一所房子放在街道的某一侧。
3. 一所房子放在街道的另一侧。
4. 放置两所房子，街道两侧各放置一所。
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2022/05/12/arrangements.png)
```
输入：n = 2
输出：9
解释：如上图所示，共有 9 种可能的放置方式。
```

**提示：**

- `1 <= n <= 10<sup>4</sup>`

题目来源： [力扣 2320. 统计放置房子的方式数](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/) 。

#### 基本思路

这道题也是 [198\. 打家劫舍](https://leetcode.cn/problems/house-robber/description/) 问题的拓展，只不过条件稍微复杂了一点。

我们其实不需要同时考虑街道两侧，只需要考虑一侧就行了，因为两侧的房屋互不影响，所以另一侧的方案数是一样的，总的方案数就是两侧方案数的乘积。

只看一侧的话，198 题和这道题都是不能选择相邻的元素，不过这道题求的是方案总数，198 题求的是最大收益。

那我们只需要基于 198 题的思路修改 `dp` 函数的定义和状态转移的逻辑即可完成这道题。

本题我们可以定义这样一个 `dp` 函数：

```
// 定义：dp(i) 计算从第 i 个地块到第 n 个地块，所能放置房子的方式数

int dp(int i)
```

对于第 `i` 个地块，我们可以选择放置房子或者不放，如果放的话，接下来只能去 `i + 2` 个地块进行选择；如果选择不放，那么接下来可以去第 `i + 1` 个地块进行选择。

因为题目问的是放置方案的总数，所以两种选择的方案总数应该相加。根据这个逻辑，我们就可以得到状态转移方程：

```
dp(i) = dp(i + 1) + dp(i + 2)
```

接下来就是动态规划标准步骤，这里仅给出带备忘录的递归解法，方便大家理解。

改为迭代形式、优化 `dp` 数组等优化步骤，可以参见 [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) ，这里就不细说了。

#### 解法代码

```
class Solution {

    const int MOD = 1000000007;

    std::vector<int> memo;

public:

    int countHousePlacements(int n) {

        memo = std::vector<int>(n + 1, -1);

        int res = dp(0, n);

        return static_cast<int>((static_cast<long long>(res) * res) % MOD);

    }

    // 定义：dp(i, n) 计算从第 i 个地块到第 n 个地块，所能放置房子的方式数

    int dp(int i, int n) {

        if (i >= n) {

            return 1;

        }

        if (memo[i] != -1) {

            return memo[i];

        }

        // 状态转移方程

        int res = (

            // 选择在第 i 个地块放置房子

            dp(i + 1, n) +

            // 选择在第 i 个地块不放置房子

            dp(i + 2, n)

        ) % MOD;

        memo[i] = res;

        return res;

    }

};
```

#### 算法可视化

算法可视化

### 983\. 最低票价

**983\. 最低票价** | [力扣](https://leetcode.cn/problems/minimum-cost-for-tickets/) | [LeetCode](https://leetcode.com/problems/minimum-cost-for-tickets/)

在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days`  的数组给出。每一项是一个从  `1`  到  `365` 的整数。

火车票有 **三种不同的销售方式** ：

- 一张 **为期一天** 的通行证售价为 `costs[0]` 美元；
- 一张 **为期七天** 的通行证售价为 `costs[1]` 美元；
- 一张 **为期三十天** 的通行证售价为 `costs[2]` 美元。

通行证允许数天无限制的旅行。 例如，如果我们在第 `2` 天获得一张 **为期 7 天** 的通行证，那么我们可以连着旅行 7 天：第 `2` 天、第 `3` 天、第 `4` 天、第 `5` 天、第 `6` 天、第 `7` 天和第 `8` 天。

返回 *你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费* 。

**示例 1：**

```
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```

**示例 2：**

```
输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
输出：17
解释：
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
你总共花了 $17，并完成了你计划的每一天旅行。
```

**提示：**

- `1 <= days.length <= 365`
- `1 <= days[i] <= 365`
- `days` 按顺序严格递增
- `costs.length == 3`
- `1 <= costs[i] <= 1000`

题目来源： [力扣 983. 最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/) 。

#### 基本思路

其实这个题还是 [198\. 打家劫舍](https://leetcode.cn/problems/house-robber/description/) 的变种。

198 题是让你在 `nums[i]` 做两种选择，抢或者不抢，且抢了之后不能再抢相邻的位置，最后求最大收益。

这道题是让你在 `days[i]` 做三种选择，买一天的、七天的或三十天的，且买了之后，在这段时间内不用再买，最后求最小花费。

所以几乎可以套用 198 题的动态规划思路，区别是用 `nextDayIndex` 来计算下一个可选的索引，然后对三种选择求最小值。

这里我就用带备忘录的递归解法吧，请看代码注释。

#### 解法代码

```
class Solution {

public:

    vector<int> memo;

    int mincostTickets(vector<int>& days, vector<int>& costs) {

        memo.resize(days.size(), -1);

        return dp(days, costs, 0);

    }

    // dp(start) 计算 days[start..] 的最小花费

    int dp(vector<int>& days, vector<int>& costs, int start) {

        // base case

        if (start >= days.size()) {

            return 0;

        }

        if (memo[start] != -1) {

            return memo[start];

        }

        int res = INT_MAX;

        // 选择买一天的票

        int currentDay = days[start];

        int nextDayIndex = start;

        while (nextDayIndex < days.size() && days[nextDayIndex] < currentDay + 1) {

            nextDayIndex++;

        }

        int day1Cost = dp(days, costs, nextDayIndex) + costs[0];

        // 选择买七天的票

        while (nextDayIndex < days.size() && days[nextDayIndex] < currentDay + 7) {

            nextDayIndex++;

        }

        int day7Cost = dp(days, costs, nextDayIndex) + costs[1];

        // 选择买三十天的票

        while (nextDayIndex < days.size() && days[nextDayIndex] < currentDay + 30) {

            nextDayIndex++;

        }

        int day30Cost = dp(days, costs, nextDayIndex) + costs[2];

        // 计算最便宜的票

        res = min(day1Cost, min(day7Cost, day30Cost));

        memo[start] = res;

        return res;

    }

};
```

#### 算法可视化

算法可视化

### 740\. 删除并获得点数

**740\. 删除并获得点数** | [力扣](https://leetcode.cn/problems/delete-and-earn/) | [LeetCode](https://leetcode.com/problems/delete-and-earn/)

给你一个整数数组 `nums` ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除 **所有** 等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。

开始你拥有 `0` 个点数。返回你能通过这些操作获得的最大点数。

**示例 1：**

```
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
```

**示例 2：**

```
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
```

**提示：**

- `1 <= nums.length <= 2 * 10<sup>4</sup>`
- `1 <= nums[i] <= 10<sup>4</sup>`

题目来源： [力扣 740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/) 。

#### 基本思路

首先，第一步肯定是要把每个数字，以及整个数组中该数字的和映射起来，方便进行处理。

比如输入 `nums = [2,2,3,3,3,4]` ，我们可以得到一个映射表：

```
2 -> 4

3 -> 9

4 -> 4
```

然后就可以暴力穷举了，对每个数字，有两种选择：要或者不要。

如果我选择要 `2` ，我就获得了 4 分，但是 `3` 就不能要了，继续去 `4` 那里做选择；

如果我选择不要 `2` ，那就获得 0 分，继续去 `3` 那里做选择。

这两种选择都要穷举一遍，然后取分数最大的选择，就得到了题目想要的答案。

因为题目说 `1 <= nums[i] <= 10000` ，所以我们可以用一个大小为 10001 的 `points` 数组来存储这个映射表。

题目转化为：在 `points` 数组中选择一些元素，使得元素之和最大，但是每当你选择了一个元素 `points[i]` ，就不能选择它的相邻元素 `points[i-1]` 和 `points[i+1]` 。

其实到这里，这道题已经转化成了 [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) 中讲解的 [198\. 打家劫舍](https://leetcode.cn/problems/house-robber/description/) 问题。

那么我就直接复制 198 题的动态规划解法了，具体讲解请参见 [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) 。

#### 解法代码

```
class Solution {

public:

    int deleteAndEarn(vector<int>& nums) {

        vector<int> points(10001, 0);

        for (int num : nums) {

            points[num] += num;

        }

        return rob(points);

    }

    int rob(vector<int>& nums) {

        int n = nums.size();

        // 记录 dp[i+1] 和 dp[i+2]

        int dp_i_1 = 0, dp_i_2 = 0;

        // 记录 dp[i]

        int dp_i = 0;

        for (int i = n - 1; i >= 0; i--) {

            dp_i = max(dp_i_1, nums[i] + dp_i_2);

            dp_i_2 = dp_i_1;

            dp_i_1 = dp_i;

        }

        return dp_i;

    }

};
```

#### 算法可视化

算法可视化

### 2611\. 老鼠和奶酪

**2611\. 老鼠和奶酪** | [力扣](https://leetcode.cn/problems/mice-and-cheese/) | [LeetCode](https://leetcode.com/problems/mice-and-cheese/)

有两只老鼠和 `n` 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。

下标为 `i` 处的奶酪被吃掉的得分为：

- 如果第一只老鼠吃掉，则得分为 `reward1[i]` 。
- 如果第二只老鼠吃掉，则得分为 `reward2[i]` 。

给你一个正整数数组 `reward1`  ，一个正整数数组  `reward2`  ，和一个非负整数  `k` 。

请你返回第一只老鼠恰好吃掉 `k` 块奶酪的情况下， **最大** 得分为多少。

**示例 1：**

```
输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
输出：15
解释：这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。
总得分为 4 + 4 + 3 + 4 = 15 。
15 是最高得分。
```

**示例 2：**

```
输入：reward1 = [1,1], reward2 = [1,1], k = 2
输出：2
解释：这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。
总得分为 1 + 1 = 2 。
2 是最高得分。
```

**提示：**

- `1 <= n == reward1.length == reward2.length <= 10<sup>5</sup>`
- `1 <= reward1[i], reward2[i] <= 1000`
- `0 <= k <= n`

题目来源： [力扣 2611. 老鼠和奶酪](https://leetcode.cn/problems/mice-and-cheese/) 。

#### 基本思路

这道题问「一只老鼠恰好吃掉 k 块奶酪」时，能够获得的最大得分。

如果没有那个 `k` 的限制就很简单了，只需逐个对比 `reward1[i]` 和 `reward2[i]` 的元素，选择较大的即可。

但是现在有 `k` 的限制，那么就相当于让第一只老鼠做若干次选择：

对于第 `i` 块奶酪，到底是我来吃，还是让给第二只老鼠吃？我必须吃 `k` 块奶酪，并且让总的得分尽可能大。

这么看来，这道题其实就是 [198\. 打家劫舍](https://leetcode.cn/problems/house-robber/description/) 问题，只不过换了个说法，改了下条件。

我们可以定义这样一个 `dp` 函数：

```
// 定义：dp(i, k) 计算从第 i 块奶酪开始，选择 k 块奶酪，所能获得的最大得分

int dp(int i, int k)
```

那么从第一只老鼠的视角开始穷举：

对于第 `i` 块奶酪，如果它选择吃掉，那么它接下来就要从 `i + 1` 块奶酪开始，选择 `k - 1` 块奶酪。

如果它选择不吃，那么它接下来就要从 `i + 1` 块奶酪开始，选择 `k` 块奶酪。

根据这个逻辑，我们就可以得到状态转移方程：

```
dp(i, k) = Math.max(

    // 选择吃掉第 i 块奶酪

    reward1[i] + dp(i + 1, k - 1),

    // 选择不吃第 i 块奶酪，让第二只老鼠来吃

    reward2[i] + dp(i + 1, k)

);
```

综上，就可以写出动态规划解法了。我这里给出带备忘录的递归解法，方便大家理解。改为迭代形式、优化 `dp` 数组等优化步骤，可以参见 [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) 。

**但是！这道题用动态规划解法超时了** ，看下数据规模， `n, k` 都在 `10^5` 动态规划的复杂度是 `O(n * k)` ，在 `10^10` 量级，确实很容易超时。

我们动态规划是无遗漏、无冗余地穷举了所有可能的解，依然超时， **那就说明这道题大概率要用贪心的思路，找出一些巧妙的方法，避免穷举所有可行解来计算最优解** 。

我们尝试换个思路，这道题相当于就是让你在 `reward1` 中选 `k` 个元素，在 `reward2` 中选 `n - k` 个元素，使得元素之和最大。

想要让总的元素之和最大，可以让 `reward1` 中选择的 `k` 个元素尽可能「占便宜」，即选择 `reward1[i] - reward2[i]` 最大的 `k` 个元素。

那么有一个思路，就是把 `reward1` 和 `reward2` 的差值进行排序，然后选择前 `k` 个最大的差值作为从 `reward1` 中选择的元素，剩下的从 `reward2` 中选择。

这个思路需要确保排序后依然知道排序前的索引，所以需要用一个 `int[]` 来存储 `reward1[i] - reward2[i]` 和索引 `i` 的对应关系。具体看代码吧。

#### 解法代码

```
// 标准动态规划解法，超时

class DPSolution {

    // 备忘录

    vector<vector<int>> memo;

public:

    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {

        int n = reward1.size();

        memo = vector<vector<int>>(n, vector<int>(k + 1, -1));

        return dp(0, k, reward1, reward2);

    }

    // 定义：dp(i, k) 计算第一只老鼠从第 i 块奶酪开始，选择 k 块奶酪，所能获得的最大得分

    int dp(int i, int k, vector<int>& reward1, vector<int>& reward2) {

        // base case

        // 如果已经没有奶酪可以吃了，那么得分就是 0

        if (i >= reward1.size()) {

            if (k == 0) {

                return 0;

            }

            return INT_MIN;

        }

        if (k == 0) {

            // 第一只老鼠不能再吃了

            // 只能让第二只老鼠吃掉剩下所有奶酪

            int sum = 0;

            while (i < reward2.size()) {

                sum += reward2[i];

                i++;

            }

            return sum;

        }

        // 如果之前计算过，直接返回

        if (memo[i][k] != -1) {

            return memo[i][k];

        }

        // 对第 i 块奶酪进行选择

        int res = max(

            // 第一只老鼠吃掉第 i 块奶酪

            reward1[i] + dp(i + 1, k - 1, reward1, reward2),

            // 不吃，让第二只老鼠吃掉第 i 块奶酪

            reward2[i] + dp(i + 1, k, reward1, reward2)

        );

        memo[i][k] = res;

        return res;

    }

};

// 贪心解法，提交成功

class Solution {

public:

    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {

        int n = reward1.size();

        // diff[i][0] 存储 reward1[i] - reward2[i]

        // diff[i][1] 存储索引 i

        vector<pair<int, int>> diff(n);

        for (int i = 0; i < n; i++) {

            diff[i] = {reward1[i] - reward2[i], i};

        }

        // 按照差值从大到小排序

        sort(diff.begin(), diff.end(),  {

            return a.first > b.first;

        });

        // 差值最大的 k 块奶酪，从 reward1 中选择

        int sum = 0;

        for (int i = 0; i < k; i++) {

            sum += reward1[diff[i].second];

        }

        // 其他的 n - k 块奶酪，从 reward2 中选择

        for (int i = k; i < n; i++) {

            sum += reward2[diff[i].second];

        }

        return sum;

    }

};
```

#### 算法可视化

算法可视化

### 2789\. 合并后数组中的最大元素

**2789\. 合并后数组中的最大元素** | [力扣](https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/) | [LeetCode](https://leetcode.com/problems/largest-element-in-an-array-after-merge-operations/)

给你一个下标从 **0** 开始、由正整数组成的数组 `nums` 。

你可以在数组上执行下述操作 **任意** 次：

- 选中一个同时满足 `0 <= i < nums.length - 1` 和 `nums[i] <= nums[i + 1]` 的整数 `i` 。将元素 `nums[i + 1]` 替换为 `nums[i] + nums[i + 1]` ，并从数组中删除元素 `nums[i]` 。

返回你可以从最终数组中获得的 **最大** 元素的值。

**示例 1：**

```
输入：nums = [2,3,7,9,3]
输出：21
解释：我们可以在数组上执行下述操作：
- 选中 i = 0 ，得到数组 nums = [5,7,9,3] 。
- 选中 i = 1 ，得到数组 nums = [5,16,3] 。
- 选中 i = 0 ，得到数组 nums = [21,3] 。
最终数组中的最大元素是 21 。可以证明我们无法获得更大的元素。
```

**示例 2：**

```
输入：nums = [5,3,3]
输出：11
解释：我们可以在数组上执行下述操作：
- 选中 i = 1 ，得到数组 nums = [5,6] 。
- 选中 i = 0 ，得到数组 nums = [11] 。
最终数组中只有一个元素，即 11 。
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `1 <= nums[i] <= 10<sup>6</sup>`

题目来源： [力扣 2789. 合并后数组中的最大元素](https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/) 。

#### 基本思路

我看到这道题，首先想到的就是 [团灭打家劫舍问题](https://labuladong.online/zh/algo/dynamic-programming/house-robber/) 中讲的 [198\. 打家劫舍](https://leetcode.cn/problems/house-robber/description/) 。

几乎就是一模一样嘛，用动态规划暴力穷举：对于 `nums[i]` 可以有两种选择，和后面的元素合并，那么接下来就跳到 `nums[i+2]` 继续穷举；如果不合并，那么就继续走到 `nums[i+1]` 做选择。

但是仔细想想，这个思路不太行， **因为一个元素可以参与多次合并** 。

比如 `nums[i]` 和 `nums[i+1]` 合并后， `nums[i+1]` 消失了，那么 `nums[i]` 还可以继续尝试和 `nums[i+2]` 合并。这个场景是 198 题没有的。

所以需要换个思路，我们再仔细观察一下这个和并的过程，相当于要把所有非递减的相邻元素合并。

肯定要先对靠后的元素进行合并，因为这样不会破坏已有的非递减关系，而且由于合并的关系，还可能创造新的非递减关系，使合并的非递减元素对尽可能多。

只要合并尽可能多的元素对，最后剩下的元素肯定包含最大的结果。具体看代码吧。

#### 解法代码

```
class Solution {

public:

    long long maxArrayValue(vector<int>& nums) {

        long long res = 0;

        int i = nums.size() - 1;

        // 从后往前遍历，把所有非递减的相邻元素合并

        while (i >= 0) {

            long long blockSum = nums[i];

            // 把所有非递减的相邻元素合并

            while (i > 0 && blockSum >= nums[i - 1]) {

                blockSum += nums[i - 1];

                i--;

            }

            // 记录合并后的最大值

            res = std::max(res, blockSum);

            i--;

        }

        return res;

    }

};
```

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论(3)

Markdown

Ctrl+Enter 发表

D

Dora Ren 7 个月前

1. 解决智力问题

```
def mostPoints(self, questions):
```

```
m = len(questions)

    #dp[i]表示0到i题最多能得多少分

    dp = [0] * m

    dp[0] = questions[0][0]

    #当前题要么是第一次做，要么做完前面的又做到当前题

    for i in range(1, m):

        for j in range(i):

            if questions[j][1] + j == i - 1:

                dp[i] = max(dp[i], dp[j] + questions[i][0])

        #前i道题目只做了这一道题目

        dp[i] = max(dp[i], questions[i][0])

    return dp[m - 1] 

感觉那里不对劲，但是能AC，有点晕........
```

![围城](https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIeZI8BgHiabVfjicDaqC2IL1libTMzpRqPEb2KOl82D55lvM1TqIYiaJRT1x1dJ9pAVibqaXaCL2BFBM7aoCzvXErVHibribsSlTyt3o1gYkfVFRxEw/132)

围城 9 个月前

删除并获得点数中的Python解法是上一个题目的解法

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 8 个月前

收到，我修复一下~