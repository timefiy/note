# E1. 交互式 RBS（简单版本）<https://codeforces.com/contest/2130/problem/E1>

**时间限制：** 每个测试用例2秒  
**内存限制：** 每个测试用例256MB  

这是一个交互式问题。

这是该问题的简单版本。唯一的区别是查询次数的限制。只有当所有版本的问题都被解决时，您才能进行hack。

## 问题描述

有一个长度为 n 的隐藏括号序列 s，其中 s 只包含 '(' 和 ')'。保证 s 至少包含一个 '(' 和一个 ')'。

为了找到这个括号序列，您可以进行查询。每个查询的形式如下：您选择一个整数 k 和任意索引 i₁, i₂, ..., iₖ（1 ≤ k ≤ 1000，1 ≤ i₁, i₂, ..., iₖ ≤ n）。注意索引可以相等。然后，您会收到一个由评判系统计算的整数 f(sᵢ₁sᵢ₂...sᵢₖ)。

对于括号序列 t，f(t) 是 t 中非空正则括号子串的数量（子串必须是连续的）。例如，f("()())")=3。

## 正则括号序列定义

括号序列被称为正则的，如果它可以通过以下方式构造：

1. 空序列 ∅ 是正则的。
2. 如果括号序列 A 是正则的，那么 (A) 也是正则的。
3. 如果括号序列 A 和 B 都是正则的，那么连接序列 AB 也是正则的。

例如，序列 "(())()" 和 "()" 是正则的，而 "(()" 和 "())(" 不是正则的。

## 任务

使用不超过 550 次查询找到序列 s。

## 输入格式

每个测试包含多个测试用例。第一行包含测试用例数 t（1 ≤ t ≤ 20）。测试用例的描述如下。

## 交互格式

每个测试用例的第一行包含一个整数 n（2 ≤ n ≤ 1000）。此时，括号序列 s 已被选定。此任务中的交互器不是自适应的。换句话说，括号序列 s 在每个测试用例中都是固定的，在交互过程中不会改变。

要进行查询，您需要选择一个整数 k 和任意索引 i₁, i₂...iₖ（1 ≤ k ≤ 1000，1 ≤ i₁, i₂, ..., iₖ ≤ n）并打印以下格式的行（不带引号）：

```text
? k i₁ i₂...iₖ
```

之后，您会收到一个整数 f(sᵢ₁sᵢ₂...sᵢₖ)。

您最多可以进行 550 次此类查询。

接下来，如果您的程序找到了括号序列 s，请打印以下格式的行（不带引号）：

```text
! s₁s₂...sₙ
```

注意，此行不被视为查询，在计算查询次数时不予考虑。

之后，继续下一个测试用例。

## 注意事项

如果您在交互过程中进行了超过 550 次查询，您的程序必须立即终止，您将收到 Wrong Answer 判决。否则，您可能会收到任意判决，因为您的解决方案将继续从已关闭的流中读取。

在打印查询或测试用例的答案后，不要忘记输出行尾并刷新输出。否则，您将收到 Idleness Limit Exceeded 判决。要做到这一点，请使用：

- C++ 中的 `fflush(stdout)` 或 `cout.flush()`
- Java 中的 `System.out.flush()`
- Pascal 中的 `flush(output)`
- Python 中的 `stdout.flush()`
- 其他语言请参见文档

## Hack 格式

要进行 hack，请遵循以下测试格式。

第一行包含测试用例数 t（1 ≤ t ≤ 20）。测试用例的描述如下。

每个测试用例的第一行包含一个整数 n（2 ≤ n ≤ 1000）。

每个测试用例的第二行包含一个括号序列 s₁s₂...sₙ，其中 sᵢ='(' 或 ')'。

括号序列 s 必须至少包含一个 '(' 和一个 ')'。

## 示例

**输入：**
```
2
3

0

1

1

2

3
```

**输出：**
```


? 4 1 2 3 3

? 2 2 1

? 2 3 1

! )((

? 4 1 2 1 2

! ()
```

## 说明

在第一个测试用例中，隐藏的括号序列是 s=")((。

- 对于查询 "? 4 1 2 3 3"，评判系统返回 0，因为 f(s₁s₂s₃s₃)=f(")(((")=0。
- 对于查询 "? 2 2 1"，评判系统返回 1，因为 f(s₂s₁)=f("()")=1。
- 对于查询 "? 2 3 1"，评判系统返回 1，因为 f(s₃s₁)=f("()")=1。

在第二个测试用例中，隐藏的括号序列是 s="()"。

- 对于查询 "? 4 1 2 1 2"，评判系统返回 3，因为 f(s₁s₂s₁s₂)=f("()()")=3。

注意，示例仅用于理解题目陈述，并不保证能找到唯一的括号序列 s。
