---
title: "优化：实现懒更新线段树"
source: "https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "滑动窗口是一种快慢指针技巧，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组。本文介绍滑动窗口算法核心框架，总结了力扣/LeetCode 上所有滑动窗口问题的通用解题思路和代码模板。"
tags:
  - "clippings"
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [307\. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) | [307\. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) |  |

前置知识

阅读本文前，你需要先学习：

- [线段树基本实现](https://labuladong.online/zh/algo/data-structure/segment-tree-implement/)
- [优化：动态线段树](https://labuladong.online/zh/algo/data-structure/segment-tree-dynamic/)

[线段树基本实现](https://labuladong.online/zh/algo/data-structure/segment-tree-implement/) 中用数组和链表分别实现了线段树，文末留了两个优化点，分别是区间更新问题和稀疏数据的内存优化问题。

[优化：动态线段树](https://labuladong.online/zh/algo/data-structure/segment-tree-dynamic/) 解决了稀疏数据的内存优化问题， **本文将基于 `DynamicSegmentTree` 的链式实现，使用「懒更新」技术，为线段树新增 `rangeAdd/rangeUpdate` 方法，在 $O(\log N)$ 时间复杂度内完成任意长度的区间更新** 。

本文实现的区间更新线段树和之前的单点更新线段树有几点区别：

1、因为单点更新可以看作是长度为 1 的区间更新，复杂度还是 $O(\log N)$ ，所以我们不需要单独实现单点更新了。

2、我们不接受 `merge` 聚合函数了，因为涉及区间懒更新，如果同时考虑不同的聚合函数，会引入一些编程语言层面的细节问题，对于算法的学习没有什么意义，所以本文仅给出 **求和线段树** 的实现。如果你需要求最值等其他场景，可以自行修改代码中的聚合计算逻辑，或者使用文末提供的 `AllInOneSegmentTree` 万能模板。

3、线段树的区间更新可以是区间赋值（Assign），也可以区间累加（Increment）。

比方 `[1, 2, 3, 4, 5]` 这个数组，将索引区间 `[1, 3]` 内的元素都赋值为 10 叫做区间赋值，结果是 `[1, 10, 10, 10, 5]` ；将索引区间 `[1, 3]` 内的元素都增加 1 叫做区间累加，结果是 `[1, 3, 4, 5, 5]` 。

这两种场景都是算法题中常见的，本文会同时给出这两种实现。

我们之前实现的线段树主要 API 如下：

```
class SegmentTree {

    // 初始化线段树

    public SegmentTree(int[] nums, Function<Integer, Integer> merge) {}

    // 查询闭区间 [qL, qR] 的聚合值，时间复杂度 O(logN)

    public int query(int qL, int qR) {}

    

    // 单点更新，设置 nums[i] = val，时间复杂度 O(logN)

    public void update(int i, int val) {}

}
```

本文将实现以下两种线段树：

```
// 区间累加线段树

class IncrSegmentTree {

    // 初始化动态线段树

    public IncrSegmentTree(int start, int end, int defaultValue) {}

    // 将闭区间 [qL, qR] 增加 delta（可以是负数），时间复杂度 O(logN)

    public void rangeAdd(int qL, int qR, int delta) {}

    // 查询闭区间 [qL, qR] 的元素和，时间复杂度 O(logN)

    public int query(int qL, int qR) {}

}

// 区间赋值线段树

class AssignSegmentTree {

    // 初始化动态线段树

    public AssignSegmentTree(int start, int end, int defaultValue) {}

    // 将闭区间 [qL, qR] 赋值为 val，时间复杂度 O(logN)

    public void rangeUpdate(int qL, int qR, int val) {}

    // 查询闭区间 [qL, qR] 的元素和，时间复杂度 O(logN)

    public int query(int qL, int qR) {}

}
```

`rangeAdd` 和 `rangeUpdate` 的实现逻辑非常类似，理论上可以同时实现到一个类上，但是两个逻辑混在一起代码会更复杂，徒增理解成本，而且实际的算法题中，一般只会用到区间累加或区间赋值中的一种，不会同时用到，所以本文还是把它们拆到两个类分别实现，方便大家理解其原理。

本文的最后会给出一个万能线段树模板 `AllInOneSegmentTree` ，同时包含上述所有 API 和线段树的所有优化，笔试时可以直接拿来使用。

## 懒更新的核心原理

我们对比一下单点更新的 `update` 方法和区间更新的 `rangeUpdate` 方法，就能直观地感受到懒更新的原理，以及为什么懒更新可以让区间更新的时间复杂度依然保持在 $O(\log N)$ 。

对于区间更新的场景，如果使用 `update` 方法单点更新，我们只能用一个 for 循环去更新区间内的每个元素。

请你点开下面的可视化面板，多次点击 `sumTree.update` 这一行代码，可以看到每次 `update` 都要从根节点遍历到叶子节点：

算法可视化

所以区间更新的时间复杂度是 $O(M \log N)$ ， $M$ 是区间中的元素个数， $\log N$ 是线段树的高度， $N$ 是数组中的元素个数。

优化思路及难点

**懒更新的思路是，没必要上来就去更新区间的所有叶子节点，而是先把更新记录到非叶子节点（懒标记）。等到之后的操作经过懒标记节点时，再顺手把懒标记逐渐更新到叶子节点（懒标记下推）** 。

它的难点在于，你要正确处理懒标记，保证在懒标记存在时，线段树的查询、更新操作依然能返回正确的结果。

可视化面板对懒更新线段树有特殊的支持，带有「懒标记」的线段树节点会显示为半透明，而且节点上的显示值会有一个 `*` 前缀，你把鼠标移动到对应的节点上，会显示懒标记的值。下面来结合可视化面板看看 `rangeUpdate` 方法是如何工作的。

请你点开下面的可视化面板，点击 `sumTree.rangeUpdate` 这一行代码，可以看到代码并没有真的更新了叶子节点，而是只更新了 `[0, 4]` 节点的元素和，并且打了一个 `lazyAssign = 2` 的标记。

点击 `console.log(sumTree.query(0, 4))` 这一行代码，可以看到直接命中了 `[0, 4]` 节点，返回元素和 `10` 。

当查询 `[0, 4]` 节点的子节点时，会将这个懒标记向下传递。请你点击 `console.log(sumTree.query(0, 1))` 这一行代码，可以看到查询到了正确的元素和，并将懒标记下推到了 `[0, 1]` 节点和 `[3, 4]` 节点。

算法可视化

你可以自行修改可视化面板中的代码，尝试修改 `rangeUpdate` 和 `query` 方法的参数，看看懒标记的下推过程。

根据上面的可视化展示可以直观地看出来：

1、 `rangeUpdate` 方法不需要遍历更新区间的所有叶子节点，遍历的节点总数是树高 $O(\log N)$ 的常数倍，与区间的长度无关，所以时间复杂度是 $O(\log N)$ 。

2、 `query` 方法在查询时，虽然会额外做一些懒标记下推的工作，但遍历的节点总数依然是树高 $O(\log N)$ 的常数倍，与区间的长度无关，所以时间复杂度是 $O(\log N)$ 。

有了这些直观的认识，我们就可以开始实现懒更新线段树了。

## 实现区间赋值线段树

基于 [动态线段树](https://labuladong.online/zh/algo/data-structure/segment-tree-dynamic/) 实现的动态线段树，只需改动少量代码即可实现懒更新线段树。

首先是给 `SegmentNode` 添加 `hasLazyAssign` 和 `lazyAssign` 字段，记录当前节点是否存在懒标记，以及懒标记的值。

然后是多了一个 `pushDown` 方法用来下推懒标记，在调用 `query` 和 `updateRange` 方法时调用一次就行了。

具体看代码吧，注释非常详细了。

## 实现区间累加线段树

区间累加线段树和上面实现的区间赋值线段树是类似的，只不过懒标记的值变成了 `lazyAdd` 表示累加的值，然后稍微修改 `pushDown` 方法的逻辑即可。

具体看代码吧，注释非常详细了：

## 万能线段树模板

上面的代码为了方便大家理解，把 `updateRange` 和 `addRange` 分别放到了 `AssignSegmentTree` 和 `IncrSegmentTree` 两个类中实现。

而且上面实现的 `AssignSegmentTree` 和 `IncrSegmentTree` 都是用于区间求和场景的，算法题中一般会出现求和、求最大值、求最小值这三种场景。

下面实现一个万能的线段树类 `AllInOneSegmentTree` ，具有以下特点：

1、同时实现 `updateRange` 和 `addRange` 方法，支持区间赋值和区间累加的混合调用。

2、在创建线段树时，可以指定线段树来计算区间和、区间最大值或区间最小值。

把这些功能都混合在一起，代码会显得复杂臃肿，但好处是开箱即用。 **所以这个万能实现不太适合用来学习理解，仅适合存为模板，在实战中直接使用** 。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表