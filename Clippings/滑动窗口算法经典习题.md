---
title: "滑动窗口算法经典习题"
source: "https://labuladong.online/zh/algo/problem-set/sliding-window/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有滑动窗口算法的经典习题，包含 labuladong 思路讲解和算法可视化，教会读者如何套用滑动窗口代码框架。支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [滑动窗口算法框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/)

滑动窗口的应用非常广泛，但我们的框架可以套用所有需要滑动窗口算法的题目中，下面就来举例一些最经典的题目，我会反复强调 [滑动窗口算法框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 中的思考方式，以强化你对这个算法的理解和记忆。

Tip

首先，看看如何把题目转化成子数组问题，从而使用滑动窗口来解决。

### 1658\. 将 x 减到 0 的最小操作数

**1658\. 将 x 减到 0 的最小操作数** | [力扣](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) | [LeetCode](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)

给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。

如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。

**示例 1：**

```
输入：nums = [1,1,4,2,3], x = 5
输出：2
解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
```

**示例 2：**

```
输入：nums = [5,6,7,8,9], x = 4
输出：-1
```

**示例 3：**

```
输入：nums = [3,2,20,1,1,3], x = 10
输出：5
解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `1 <= nums[i] <= 10<sup>4</sup>`
- `1 <= x <= 10<sup>9</sup>`

题目来源： [力扣 1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) 。

#### 基本思路

很多读者第一眼看到这个题，可能就想到了递归算法来穷举所有可能的操作方法对吧？每次我可以选择移除最左边或最右边的元素，然后对剩下的数组递归调用，直到 `x` 减到 0，肯定可以算出最小的操作数。

这很好，说明大家已经理解并运用了「算法本质是穷举」的思想，对于容易穷举的，用 for 循环遍历；对于每次选择之间互相关联的，用递归算法借助递归树穷举。

但是这里可以用到我在 [时空复杂度分析实用指南](https://labuladong.online/zh/algo/essential-technique/complexity-analysis/) 中分享的小技巧，你看完题就知道这题不能用递归：就是看数据规模预估反推算法思路。

这道题的数据规模是 `1 <= nums.length <= 10^5` ，这就意味着递归算法的时间复杂度不能达到 `O(2^n)` 这个级别，因为 10^5 的平方就是 10^10，这个数量级，在任何判题平台都是不能被接受的。

你如果用递归算法，且不说指数级复杂度的回溯算法了，即便你能用动态规划算法消除重叠子问题，那你至少也要用两个状态，也就是数组两端 `i, j` 的索引位置。那么时空复杂度最起码都要 `O(2^n)` ，所以这道题不适合用递归算法。

有了上面的分析，你必须再观察观察，转换一下思路。题目让你从边缘删除掉和为 `x` 的元素，那剩下来的是什么？剩下来的是不是就是 `nums` 中的一个子数组？让你尽可能少地从边缘删除元素说明什么？是不是就是说剩下来的这个子数组大小尽可能的大？

**所以，这道题等价于让你寻找 `nums` 中元素和为 `sum(nums) - x` 的最长子数组** 。

寻找子数组就是考察滑动窗口技巧。前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

针对本题，以上三个问题的答案是：

1、当窗口内元素之和小于目标和 `target` 时，扩大窗口，让窗口内元素和增加。

2、当窗口内元素之和大于目标和 `target` 时，缩小窗口，让窗口内元素和减小。

3、当窗口内元素之和等于目标和 `target` 时，找到一个符合条件的子数组，我们想找的是最长的子数组长度。

> 注意：类似 [713\. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/) ，之所以本题可以用滑动窗口，关键是题目说了 `nums` 中的元素都是正数，这就保证了只要有元素加入窗口，和一定变大，只要有元素离开窗口，和一定变小。
> 
> 你想想如果存在负数的话就没有这个性质了，也就不能确定什么时候扩大和缩小窗口，也就不能使用滑动窗口算法，而应该使用 [前缀和 + 哈希表的方式](https://labuladong.online/zh/algo/problem-set/perfix-sum/) 解决，参见 [560\. 和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/) 。

#### 解法代码

```
#include <vector>

#include <climits>

using namespace std;

class Solution {

public:

    int minOperations(vector<int>& nums, int x) {

        int n = nums.size(), sum = 0;

        for (int i = 0; i < n; i++) {

            sum += nums[i];

        }

        // 滑动窗口需要寻找的子数组目标和

        int target = sum - x;

        int left = 0, right = 0;

        // 记录窗口内所有元素和

        int windowSum = 0;

        // 记录目标子数组的最大长度

        int maxLen = INT_MIN;

        // 开始执行滑动窗口框架

        while (right < nums.size()) {

            // 扩大窗口

            windowSum += nums[right];

            right++;

            while (windowSum > target && left < right) {

                // 缩小窗口

                windowSum -= nums[left];

                left++;

            }

            // 寻找目标子数组

            if (windowSum == target) {

                maxLen = max(maxLen, right - left);

            }

        }

        // 目标子数组的最大长度可以推导出需要删除的字符数量

        return maxLen == INT_MIN ? -1 : n - maxLen;

    }

};
```

#### 算法可视化

算法可视化

Tip

上道题把题目变形成滑动窗口计算子数组和的问题，下面这道题来计算子数组的乘积。

### 713\. 乘积小于 K 的子数组

**713\. 乘积小于 K 的子数组** | [力扣](https://leetcode.cn/problems/subarray-product-less-than-k/) | [LeetCode](https://leetcode.com/problems/subarray-product-less-than-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。

**示例 1：**

```
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2]、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
```

**示例 2：**

```
输入：nums = [1,2,3], k = 0
输出：0
```

**提示:**

- `1 <= nums.length <= 3 * 10<sup>4</sup>`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 10<sup>6</sup>`

题目来源： [力扣 713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/) 。

#### 基本思路

这题考察滑动窗口技巧，你维护一个窗口在 `nums` 上滑动，然后计算那些元素之积小于 `k` 的窗口个数即可。

前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

针对本题，以上三个问题的答案是：

1、当窗口元素之积小于 `k` 时，扩大窗口，让积更大一些。

2、当窗口元素之积大于 `k` 时，缩小窗口，让积更小一些。

3、当窗口元素之积小于 `k` 时，窗口内元素的所有子数组都是合法子数组。

注意：之所以本题可以用滑动窗口，关键是题目说了 `nums` 中的元素都是正数，这就保证了只要有元素加入窗口，积一定变大，只要有元素离开窗口，积一定变小。

你想想如果存在负数的话就没有这个性质了，也就不能确定什么时候扩大和缩小窗口，也就不能使用滑动窗口算法，而应该使用前缀积 + 哈希表的算法，类似的题目参见 [560\. 和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/) 。

#### 解法代码

```
class Solution {

public:

    int numSubarrayProductLessThanK(vector<int>& nums, int k) {

        int left = 0, right = 0;

        // 滑动窗口，初始化为乘法单位元

        int windowProduct = 1;

        // 记录符合条件的子数组个数

        int count = 0;

        while (right < nums.size()) {

            // 扩大窗口，并更新窗口数据

            windowProduct *= nums[right];

            right++;

            while (left < right && windowProduct >= k) {

                // 缩小窗口，并更新窗口数据

                windowProduct /= nums[left];

                left++;

            }

            // 现在必然是一个合法的窗口，但注意思考这个窗口中的子数组个数怎么计算：

            // 比方说 left = 1, right = 4 划定了 [1, 2, 3] 这个窗口（right 是开区间）

            // 但不止 [left..right] 是合法的子数组，[left+1..right], [left+2..right] 等都是合法子数组

            // 所以我们需要把 [3], [2,3], [1,2,3] 这 right - left 个子数组都加上

            count += right - left;

        }

        return count;

    }

};
```

#### 算法可视化

算法可视化

Tip

在可以修改字符的条件下寻找符合条件的子数组，也可以用滑动窗口算法，以下是几道例题。

### 1004\. 最大连续1的个数 III

给定一个二进制数组 `nums`  和一个整数 `k` ，如果可以翻转最多 `k` 个 `0` ，则返回 *数组中连续 `1` 的最大个数* 。

**示例 1：**

```
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

**示例 2：**

```
输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `nums[i]` 不是 `0`  就是  `1`
- `0 <= k <= nums.length`

题目来源： [力扣 1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) 。

#### 基本思路

这题考察滑动窗口技巧，你维护一个窗口在 `nums` 上滑动，保证 `nums` 中的所有数字都被替换成 1，那么窗口可以达到的最大长度就是题目要的答案。

前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

针对本题，以上三个问题的答案是：

1、当可替换次数大于等于 0 时，扩大窗口，让进入窗口的 0 都变成 1，使得连续的 1 的长度尽可能大。

2、当可替换次数小于 0 时，缩小窗口，空余出可替换次数，以便继续扩大窗口。

3、只要可替换次数大于等于 0，窗口中的元素都会被替换成 1，也就是连续为 1 的子数组，我们想求的就是最大窗口长度。

有了这个思路，直接看代码吧。

#### 解法代码

```
class Solution {

public:

    int longestOnes(vector<int>& nums, int k) {

        int left = 0, right = 0;

        // 记录窗口中 1 的出现次数

        int windowOneCount = 0;

        // 记录结果长度

        int res = 0;

        // 开始滑动窗口模板

        while (right < nums.size()) {

            // 扩大窗口

            if (nums[right] == 1) {

                windowOneCount++;

            }

            right++;

            while (right - left - windowOneCount > k) {

                // 当窗口中需要替换的 0 的数量大于 k，缩小窗口

                if (nums[left] == 1) {

                    windowOneCount--;

                }

                left++;

            }

            // 此时一定是一个合法的窗口，求最大窗口长度

            res = max(res, right - left);

        }

        return res;

    }

};
```

#### 算法可视化

算法可视化

### 424\. 替换后的最长重复字符

**424\. 替换后的最长重复字符** | [力扣](https://leetcode.cn/problems/longest-repeating-character-replacement/) | [LeetCode](https://leetcode.com/problems/longest-repeating-character-replacement/)

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回 *包含相同字母的最长子字符串的长度。*

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

**示例 2：**

```
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
```

**提示：**

- `1 <= s.length <= 10<sup>5</sup>`
- `s` 仅由大写英文字母组成
- `0 <= k <= s.length`

题目来源： [力扣 424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/) 。

#### 基本思路

这题考察滑动窗口技巧，可以认为是上一道题 [1004\. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/description/) 的进阶版，建议你先去做一下上一道题。

你维护一个窗口在 `s` 上滑动，保证 `s` 中的所有字符都被替换成一样的，那么窗口的最大长度就是题目要的答案。

我们可以记录窗口中出现次数最多的字符（假设为字符 `x` ，出现次数为 `windowMaxCount` ），滑动窗口中的字符数量是 `right - left` ，所以把所有字符都替换成 `x` 所需的替换次数就是 `right - left - windowMaxCount` 。

当 `right - left - windowMaxCount <= k` 时，在可控范围内，整个窗口内的字符都可以替换成相同的；反之 `right - left - windowMaxCount > k` 时说明 `k` 次替换机会不足以使窗口内的字符全部相同，此时必须缩小窗口。

前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

针对本题，以上三个问题的答案是：

1、 `right - left - windowMaxCount <= k` 时，所有进入窗口的字符都可以被替换成出现次数最多的字符 `x` ，使得窗口内的所有元素都是重复的。

2、当 `right - left - windowMaxCount > k` 时，必须缩小窗口。因为此时窗口已经不合法，用尽 `k` 次替换机会也会有一个字符无法替换成 `x` 。

3、只要可替换次数 `k` 大于等于 0，窗口中的字符串都可以全部替换成相同的，我们想求的是一个最大窗口长度。

可以套模板，直接看代码吧。

#### 解法代码

```
class Solution {

public:

    int characterReplacement(string s, int k) {

        int left = 0, right = 0;

        // 统计窗口中每个字符的出现次数

        vector<int> windowCharCount(26, 0);

        // 记录窗口中字符的最多重复次数

        // 记录这个值的意义在于，最划算的替换方法肯定是把其他字符替换成出现次数最多的那个字符

        int windowMaxCount = 0;

        // 记录结果长度

        int res = 0;

        // 开始滑动窗口模板

        while (right < s.length()) {

            // 扩大窗口

            int c = s[right] - 'A';

            windowCharCount[c]++;

            windowMaxCount = max(windowMaxCount, windowCharCount[c]);

            right++;

            // 这个 while 换成 if 也可以

            while (right - left - windowMaxCount > k) {

                // 杂牌字符数量 right - left - windowMaxCount 多于 k

                // 此时，k 次替换已经无法把窗口内的字符都替换成相同字符了

                // 必须缩小窗口

                windowCharCount[s[left] - 'A']--;

                left++;

            }

            // 经过收缩后，此时一定是一个合法的窗口

            res = max(res, right - left);

        }

        return res;

    }

};
```

#### 算法可视化

算法可视化

Tip

在指定大小的子数组中寻找符合条件的元素，也可以用到滑动窗口算法，以下是几道例题。

### 219\. 存在重复元素 II

给你一个整数数组 `nums` 和一个整数  `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3
输出：true
```

**示例 2：**

```
输入：nums = [1,0,1,1], k = 1
输出：true
```

**示例 3：**

```
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
- `0 <= k <= 10<sup>5</sup>`

题目来源： [力扣 219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/) 。

#### 基本思路

这题考察滑动窗口技巧，你维护一个大小为 `k` 的滑动窗口滑过整个数组，滑动的过程中计算窗口中是否存在重复元素。

前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

本题很简单直接，以上三个问题的答案是：

1、当窗口大小小于 `k` 时，扩大窗口。

2、当窗口大小大于 `k` 时，缩小窗口。

3、当窗口大小等于 `k` 且发现窗口中存在重复元素时，返回 true。

直接看代码吧。

#### 解法代码

```
#include <vector>

#include <unordered_set>

using namespace std;

class Solution {

public:

    bool containsNearbyDuplicate(vector<int>& nums, int k) {

        int left = 0, right = 0;

        unordered_set<int> window;

        // 滑动窗口算法框架，维护一个大小为 k 的窗口

        while (right < nums.size()) {

            // 扩大窗口

            if (window.find(nums[right]) != window.end()) {

                return true;

            }

            window.insert(nums[right]);

            right++;

            if (right - left > k) {

                // 当窗口的大小大于 k 时，缩小窗口

                window.erase(nums[left]);

                left++;

            }

        }

        return false;

    }

};
```

#### 算法可视化

算法可视化

### 220\. 存在重复元素 III

给你一个整数数组 `nums` 和两个整数 `indexDiff` 和 `valueDiff` 。

找出满足下述条件的下标对 `(i, j)` ：

- `i != j`,
- `abs(i - j) <= indexDiff`
- `abs(nums[i] - nums[j]) <= valueDiff`

如果存在，返回 `true` *；* 否则，返回 `false` 。

**示例 1：**

```
输入：nums = [1,2,3,1], indexDiff = 3, valueDiff = 0
输出：true
解释：可以找出 (i, j) = (0, 3) 。
满足下述 3 个条件：
i != j --> 0 != 3
abs(i - j) <= indexDiff --> abs(0 - 3) <= 3
abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0
```

**示例 2：**

```
输入：nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3
输出：false
解释：尝试所有可能的下标对 (i, j) ，均无法满足这 3 个条件，因此返回 false 。
```

**提示：**

- `2 <= nums.length <= 10<sup>5</sup>`
- `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
- `1 <= indexDiff <= nums.length`
- `0 <= valueDiff <= 10<sup>9</sup>`

题目来源： [力扣 220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/) 。

#### 基本思路

这题考察滑动窗口技巧。前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

针对本题，以上三个问题的答案是：

1、当窗口大小小于等于 `k` 时，扩大窗口，包含更多元素。

2、当窗口大小大于 `k` 时，缩小窗口，减少窗口元素。

3、窗口大小小于等于 `k` ，且窗口中存在两个不同元素之差小于 `t` 时，找到一个答案。

那么我如何在窗口 `[left, right)` 中快速判断是否有元素之差小于 `t` 的两个元素呢？这就需要使用到 `TreeSet` 利用二叉搜索树结构寻找「地板元素」和「天花板元素」的特性了。

#### 解法代码

```
#include <set>

#include <vector>

class Solution {

public:

    bool containsNearbyAlmostDuplicate(std::vector<int>& nums, int indexDiff, int valueDiff) {

        std::set<long> window;

        int left = 0, right = 0;

        while (right < nums.size()) {

            // 为了防止 i == j，所以在扩大窗口之前先判断是否有符合题意的索引对 (i, j)

            // 查找略大于 nums[right] 的那个元素

            auto ceiling = window.lower_bound((long)nums[right]);

            if (ceiling != window.end() && *ceiling - nums[right] <= valueDiff) {

                return true;

            }

            // 查找略小于 nums[right] 的那个元素

            auto floor = ceiling;

            if (floor != window.begin()) {

                --floor;

                if (nums[right] - *floor <= valueDiff) {

                    return true;

                }

            }

            // 扩大窗口

            window.insert(nums[right]);

            right++;

            if (right - left > indexDiff) {

                // 缩小窗口

                window.erase(nums[left]);

                left++;

            }

        }

        return false;

    }

};
```

#### 算法可视化

算法可视化

### 209\. 长度最小的子数组

**209\. 长度最小的子数组** | [力扣](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [LeetCode](https://leetcode.com/problems/minimum-size-subarray-sum/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]` ，并返回其长度 **。** 如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 10<sup>9</sup>`
- `1 <= nums.length <= 10<sup>5</sup>`
- `1 <= nums[i] <= 10<sup>5</sup>`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

题目来源： [力扣 209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) 。

#### 基本思路

这题是标准的滑动窗口算法，你只要看过前文 [滑动窗口算法框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 就能轻松搞定。

不过需要强调的是， **题目说了 `nums` 数组中的元素都是正数，有了这个前提才能使用滑动窗口算法** ，因为窗口扩大时窗口内元素之和必然增大，窗口缩小时窗口内元素之和必然减小。

如果 `nums` 数组中包含负数，则窗口扩大时元素和不见得就增大，窗口缩小时元素和不见得就减小，这种情况就不能单纯使用滑动窗口技巧了，可能需要混合动态规划和单调队列来做。

比如你可以去试试 [1425\. 带限制的子序列和](https://leetcode.cn/problems/constrained-subsequence-sum/description/) ， [862\. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/description/) ， [53\. 最大子序和](https://leetcode.cn/problems/maximum-subarray/description/) 。

#### 解法代码

```
class Solution {

public:

    int minSubArrayLen(int target, vector<int>& nums) {

        int left = 0, right = 0;

        // 维护窗口内元素之和

        int windowSum = 0;

        int res = INT_MAX;

        while (right < nums.size()) {

            // 扩大窗口

            windowSum += nums[right];

            right++;

            while (windowSum >= target && left < right) {

                // 已经达到 target，缩小窗口，同时更新答案

                res = min(res, right - left);

                windowSum -= nums[left];

                left++;

            }

        }

        return res == INT_MAX ? 0 : res;

    }

};
```

#### 算法可视化

算法可视化

Tip

最后，如果你不能直接回答滑动窗口算法的灵魂三问，理论上不能再使用滑动窗口算法了，但有时候可以尝试自己添加一些约束，从而能够使用滑动窗口算法来解决，下面是一道例题。

### 395\. 至少有 K 个重复字符的最长子串

**395\. 至少有 K 个重复字符的最长子串** | [力扣](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/) | [LeetCode](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/)

给你一个字符串 `s` 和一个整数 `k` ，请你找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

如果不存在这样的子字符串，则返回 0。

**示例 1：**

```
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

**示例 2：**

```
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

**提示：**

- `1 <= s.length <= 10<sup>4</sup>`
- `s` 仅由小写英文字母组成
- `1 <= k <= 10<sup>5</sup>`

题目来源： [力扣 395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/) 。

#### 基本思路

这道题难度还是挺大的，不过用 [滑动窗口算法框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 讲的代码框架，稍微修改下就能做这道题。

前文 [滑动窗口框架](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 说过，使用滑动窗口算法需要搞清楚以下几个问题：

1、什么时候应该扩大窗口？

2、什么时候应该缩小窗口？

3、什么时候得到一个合法的答案？

在本题的场景中，我们想尽可能多地装字符，即扩大窗口，但不知道什么时候应该开始收缩窗口。

为什么呢？比如窗口中有些字符出现次数不满足 `k` ，但有可能再扩大扩大窗口就能满足 `k` 了呀？但要这么说的话，你干脆一直扩大窗口算了，所以你说不准啥时候应该收缩窗口。

**理论上讲，这种情况就不能用滑动窗口模板了，但有时候我们可以自己添加一些约束，来进行窗口的收缩** 。

题目说让我们求每个字符都出现至少 `k` 次的子串，我们可以再添加一个约束条件：求每个字符都出现至少 `k` 次，仅包含 `count` 种不同字符的最长子串。

即实现一个函数签名如下的算法：

```
// 在 s 中寻找仅含有 count 种字符，且每种字符出现次数都大于 k 的最长子串

int logestKLetterSubstr(String s, int k, int count) {
```

添加了字符种类的限制，我们就可以回答滑动窗口算法的三个灵魂问题了：

1、什么时候应该扩大窗口？窗口中字符种类小于 `count` 时扩大窗口。

2、什么时候应该缩小窗口？窗口中字符种类大于 `count` 时缩小窗口。

3、什么时候得到一个合法的答案？窗口中所有字符出现的次数都大于等于 `k` 时，得到一个合法的子串。

然后就可以套用滑动窗口算法模板实现 `logestKLetterSubstr` 函数了。

当然，题目没有 `count` 的约束，那没关系呀， `count` 能有几种取值？因为 `s` 中只包含小写字母，所以 `count` 的取值也就是 `1~26` ，所以最后用一个 for 循环把这些值都输入 `logestKLetterSubstr` 计算一遍，求最大值就是题目想要的答案了。这充分体现了前文 [我的刷题经验总结](https://labuladong.online/zh/algo/essential-technique/algorithm-summary/) 中所说：算法的本质是穷举。

滑动窗口算法的时间复杂度是 `O(N)` ，循环 26 次依然是 `O(26N) = O(N)` 。

#### 解法代码

```
class Solution {

public:

    int longestSubstring(string s, int k) {

        int len = 0;

        for (int i = 1; i <= 26; i++) {

            // 限制窗口中只能有 i 种不同字符

            len = max(len, logestKLetterSubstr(s, k, i));

        }

        return len;

    }

    // 寻找 s 中含有 count 种字符，且每种字符出现次数都大于 k 的子串

    int logestKLetterSubstr(string s, int k, int count) {

        // 记录答案

        int res = 0;

        // 快慢指针维护滑动窗口，左闭右开区间

        int left = 0, right = 0;

        // 题目说 s 中只有小写字母，所以用大小 26 的数组记录窗口中字符出现的次数

        int windowCount[26] = {0};

        // 记录窗口中存在几种不同的字符（字符种类）

        int windowUniqueCount = 0;

        // 记录窗口中有几种字符的出现次数达标（大于等于 k）

        int windowValidCount = 0;

        // 滑动窗口代码模板

        while (right < s.length()) {

            // 移入字符，扩大窗口

            char c = s[right];

            if (windowCount[c - 'a'] == 0) {

                // 窗口中新增了一种字符

                windowUniqueCount++;

            }

            windowCount[c - 'a']++;

            if (windowCount[c - 'a'] == k) {

                // 窗口中新增了一种达标的字符

                windowValidCount++;

            }

            right++;

            // 当窗口中字符种类大于 count 时，缩小窗口

            while (windowUniqueCount > count) {

                // 移出字符，缩小窗口

                char d = s[left];

                if (windowCount[d - 'a'] == k) {

                    // 窗口中减少了一种达标的字符

                    windowValidCount--;

                }

                windowCount[d - 'a']--;

                if (windowCount[d - 'a'] == 0) {

                    // 窗口中减少了一种字符

                    windowUniqueCount--;

                }

                left++;

            }

            // 当窗口中字符种类为 count 且每个字符出现次数都满足 k 时，更新答案

            if (windowValidCount == count) {

                res = max(res, right - left);

            }

        }

        return res;

    }

};
```

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论(39)

Markdown

Ctrl+Enter 发表

![。](https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIKslJXialWZsia0nVLFtCrlrk09bFlSsm7ibvqND2gybvwB3PhWYm4JSK45Z8xooM5NJNIFT73UkFw11A5aHWEhL0YEaqvvGuN7FMRIEia2ETfDA/132)

。 大约 1 年前

424题为什么缩小窗口时不需要更新windowMaxCount

![君幸酒](https://thirdwx.qlogo.cn/mmopen/vi_32/nz6JdOicibKBfa3DceXVuDQiahgibxMU44z9jEGhIlT7iaeV5NXicCLG1aKYgvetkvkKplrs5vCDcC7xKA8Cf5sSQTbOS6sDp65oHVRTSUE0p8ETk/132)

君幸酒 大约 1 年前

貌似是因为left右移后窗口变小，虽然可能判断错误这个窗口是否合法但就没管它，因为必定对最终res没有影响。只有在maxcount有更大的值时才会更新res，而maxcount有更大的值的时候可以保证是合法的窗口。

![Chao](https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM74dEXQOesFnI5ldI2yc67H4vUgEopfrcyeoIIhl1E7hhIVvJFyYYwdQ2yrYsHp0TqZYRYcCa7wor4icZoDE6QNm/132)

Chao 回复 @君幸酒 大约 1 年前

我也不是很明白缩小窗口时为什么不改变windowMaxCount，在step by step的演示里我看到了这个现象，“对最终res没有影响”， 但是像是从现象推导原因，我还是不理解。希望有人能解释一下原理，或者证明一下？我尝试写了更新windowMaxcount的写法，抛砖引玉。

'''

class Solution:

```
def characterReplacement(self, s: str, k: int) -> int:

    left, right = 0, 0

    window = [0] * 26

    x, windowCount = 0, 0

    res = 0

    while right < len(s):

        cur = s[right]

        right += 1

        window[ord(cur) - 65] += 1

        if window[ord(cur) -65] > windowCount:

            windowCount = window[ord(cur) - 65]

            

        while right - left - windowCount - k > 0:

            p = s[left]

            window[ord(p) - 65] -= 1

            for i in range(26):

                if windowCount < window[i]:

                    windowCount = window[i]

            left += 1

        res = max(res, right - left)

    return res
```

![-](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJFKEib2ia165iaGFtdd830TUJd3whOzvoHcXC2hibBYJSr4RLwB7ZOAXhtv1Cib36ZTn1kyoID4wXvcVA/132)

\- 12 个月前

我也有同样的疑惑 我认为 maxCount 记录的是历史最大频数，所以存在 maxCount + k 这样一个 result 举个例子 AABABBA k=1，当窗口为 AABAB 时会进入 while 缩小窗口，此时的 maxCount=3，缩小窗口后此值失真，但是result 记录的是4，这个值会被 AABA 的情况覆盖。 所以即是 maxCount 失真，也不影响结果，因为历史最值已经记录下来了

![LLUN](https://thirdwx.qlogo.cn/mmopen/vi_32/YGwPHmib9XgYQdlvKZL9HZEUKiaVc0f3mWL7Mrp5Ldc0GJskgD996zlfXr6mchiawxv1OibLJeVYCAy3tzicBc4z9QHBhBickKNPbAX1AVM0lzyxA/132)

LLUN 2 个月前

395的这个 2、什么时候应该缩小窗口？窗口中字符种类大于 count 时扩大窗口。有误 应该是 2、什么时候应该缩小窗口？窗口中字符种类大于 count 时缩小窗口。

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 21 天前

感谢指出，已修正~

![haoqi6677](https://avatars.githubusercontent.com/u/49672871?v=4)

haoqi6677 超过 1 年前

纠正：395题，38行应为 `当窗口中字符种类大于 count时，缩小窗口`

![湘伦](https://thirdwx.qlogo.cn/mmopen/vi_32/JqgqPT0njgpf9ZsMmBqtDOXNyuTcWuEU8IdruLJtAFhicJcjXO86x9yx9QzFbDu8mKt7ib8qSsLK7VBktsPl9CLh2ErUkMrD9st0YEeKibWciaY/132)

湘伦 5 个月前

nums = \[1, 2, 10, 1, 2, 3\], k = 8 按题目描述，这个用例下，连续子数组应该是6个吧？ 而不考虑子数组被一个大于k的数断连的情况下，会算出来9个

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 21 天前

你跑跑试试？

![你想屁屁吃](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6KBwbL9ib95MibcygHWLAPPiceZozdJuUiaa95k3jEzgqzaE0Dp04TEQicJQst9ma4bMBD7ORrTJtJWA/132)

你想屁屁吃 6 个月前

“用合适的数据结构记录窗口中的数据，根据具体场景变通Object window =...” 在练习这几题的时候一直在思考这个问题，目前反而滑动窗口算法三问有些门路，但是对于具体开局如何定义window类型似乎有点难到我了，有时候想着是int，结果是TreeSet，有时候又是HashSet，想问问东哥有没有具体根据题目要求来寻找类型的方式呢

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 21 天前

关键看你窗口里面的要存什么，只存一个计数器的话就用 int，要去重的话就用 HashSet，如果需要排序就用 TreeSet。

![nicely](https://thirdwx.qlogo.cn/mmopen/vi_32/0GsLic79O0NchHVkCS9a4oudbrNjJPmbVGUrlHKc1d6mImrkRCesvcBEwAXkgXYONjrNF0ckTFIViaaHWOaCboVw/132)

nicely 超过 1 年前

713 题中的注释 但不止 \[left..right\] 是合法的子数组，\[left+1..right\], \[left+2..right\] 等都是合法子数组 // 所以我们需要把 \[3\], \[2,3\], \[1,2,3\] 这 right - left 个子数组都加上 那\[1\], \[2\],\[1,2\] 也是合法子数组 为啥不也加上 ？

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 超过 1 年前

在前面的窗口加过了

![githubshopper-cloud](https://avatars.githubusercontent.com/u/180778516?v=4)

githubshopper-cloud

githubshopper-cloud 回复 @labuladong 超过 1 年前

怎麼能保證前面都加過了，還是沒有很懂，能否用更嚴謹一點的解釋，謝謝

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 回复 @githubshopper-cloud 超过 1 年前

说白了还是穷举。定住尾部元素，然后穷举开头元素。这样就刚刚好全部穷举，不会多也不会少。

![FrozenForest](https://thirdwx.qlogo.cn/mmopen/vi_32/dQkxU4V3QqfDOPsh9d39NG9EeeWqEyGh7HX2S70ciauplibCMzib2K2q2RIEy9L3qUDCsjvM5IBdtx1ibKOLB6Y11u8ATp0rNXUQEYEQaibamEpM/132)

FrozenForest

FrozenForest 2 个月前

关于219题比较容易理解的写法：

1. 按照题目要求， `abs(i-j) <= k` ，应该保证窗口大小不超过 k+1
2. 在左边界收缩完成后，再进行答案的判断。

```
from collections import defaultdict

class Solution:

    def containsNearbyDuplicate(self, nums, k):

        # window 记录窗口中每个元素出现的次数

        window = defaultdict(int)

        left, right = 0, 0

        while right < len(nums):

            # c 是将移入窗口的元素

            c = nums[right]

            window[c] += 1

            # 增大窗口

            right += 1

            # 保持窗口不大于k+1

            while right - left > k + 1:

                # d 是将移出窗口的元素

                d = nums[left]

                window[d] -= 1

                # 缩小窗口

                left += 1

            # 找到合法窗口后检测是否有重复

            if window[c] > 1:

                return True

        return False
```

![瑾](https://thirdwx.qlogo.cn/mmopen/vi_32/LW9EvuISaNGmW45AK0PfFqPGRHGHXV4wPdbmmAPhSvmmSMqPz3FMntDymYT6uLjCCWo7m3eS66qJN5TTficYOAA/132)

瑾 3 个月前

题目1004，以0为计数求解：

```
class Solution {

    public int longestOnes(int[] nums, int k) {

        int left = 0, right = 0;

        int res = 0;

        int temp = 0;

        while(right < nums.length) {

            if(nums[right] == 0) {

                temp = temp + 1;

            }

            right++;

            while(temp > k) {

                if(nums[left] == 0) {

                    temp = temp - 1;

                }

                left++;

            }

            if(temp == k || right == nums.length) {

                res = Math.max(res, right - left);

            }

        }

        return res;

    }

}
```

![地狱漫游](https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIdSSl01U7FLff9Rr80Q034RTkD8PwTibL7ZUD0D0ibLh7LJMBiaUz83S05Jeicvw6WZpd8QCPTvALqtyYDsUR2ouRhcf0JcBoJar4By0RB0j6gibQ/132)

地狱漫游 大约 1 年前

关于练习中的 [219](https://labuladong.online/algo/problem-set/sliding-window/#slug_contains-duplicate-ii) 和 [220](https://labuladong.online/algo/problem-set/sliding-window/#slug_contains-duplicate-iii) 题的一些疑惑和补充。首先就是由于题目的理解而导致写法的问题，两个题目对于窗口的限制都有类似于 `abs(i-j) <= k` 的描述。由于 `i` 和 `j` 都是下标，那么实际上题目允许的窗口大小，也就是窗口中元素的个数，实际上是 `k+1` 个。而东哥给的代码（包括我自己写的）实际上仅维护了大小为 `k` 的窗口，这也是为什么在外层循环的最开始就可以毫无顾忌地使用 `nums[right]` 的原因，即使它还没有被添加到窗口中。也就是说将这个元素添加到窗口中再判断也是 OK，以下是我 219 题的代码：

```
class Solution {

public:

    bool containsNearbyDuplicate(vector<int>& nums, int k) {

        unordered_map<int, int> record;

        int left = 0, right = 0;

        while (right < nums.size()) {

            int num = nums[right++];

            if (++record[num] > 1) {

                return true;

            }

            while (right - left > k) {

                int del = nums[left++];

                record[del]--;

            }

        }

        return false;

    }

};
```

而 220 题的难点其实就是第三个条件，其它都和 219 题是一样的。我自己的理解其实就是参考经典题目两数之和那样的思路，差别就在于这次寻找的是有绝对值的不等式，也就是将条件从

`abs(nums[i] - nums[j]) <= valueDiff`

转换为

`nums[i] - valueDiff <= nums[j] <= nums[i] + valueDiff`

所以代码就可以简单许多：

```
class Solution {

public:

    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {

        set<int> record;

        int left = 0, right = 0;

        while (right < nums.size()) {

            int num = nums[right++];  // 待添加的元素就是 nums[i]

            auto it = record.lower_bound(num - valueDiff);

            if (it != record.end() && *it <= num + valueDiff) {

                // 我们从窗口移动过程的记录中找到了满足条件的 nums[j]

                return true;

            }

            record.insert(num);

            while (right - left > indexDiff) {

                record.erase(nums[left++]);

            }

        }

        return false;

    }

};
```

![玊尔](https://thirdwx.qlogo.cn/mmopen/vi_32/EFUtJYJA7XxbYc3obSN7jFVMJLiccYPHdlr8iaA481elxORF0G0xAwKjvbojmrfA4cYSynY6ibxMFzudzdhARXShat69ySltS55xFTupjJQ75c/132)

玊尔 4 个月前

我比较好奇 缩容的时候，为啥是 record.erase(nums\[left\]); 这个时候难道不会有重复的元素在 window 中吗?

![zhouqr2000](https://avatars.githubusercontent.com/u/15925711?v=4)

zhouqr2000

zhouqr2000 超过 1 年前

对于 1004. 最大连续1的个数 III， 以zeros做为计数器更直观一些：

```
public int longestOnes(int[] nums, int k) {

        int result = 0;

        int left = 0, right = 0;

        int zeros = 0;

        while(right < nums.length) {

            int in = nums[right];

            right++;

            if(in == 0) zeros++;

            while(zeros>k && left<right) {

                int out = nums[left];

                left++;

                if(out == 0) zeros--;

            }

            result = Math.max(result, right-left);

        }

        return result;

    }
```

![捉月](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlJWibJZnnAWdaNrlC1Fu3MlvJyrwmSnIunOTJyicfN14IwGibrbjYYRHibPhorDqZNb5t9uBSLEjX0g/132)

捉月 大约 1 年前

确实，感觉东哥老了，以前写的都不记得了，拿以前的模板直接秒了

```
class Solution:

    def longestOnes(self, nums: List[int], k: int) -> int:

        left,right = 0,0

        res = 0

        count=0

        # start the sliding window template

        while right <(len(nums)):

            # expand the window

            if nums[right] == 0:

                count += 1

            right+=1

            # when the number of 0s that need to be replaced in the window is greater than k, shrink the window

            while count > k:

                if nums[left] == 0:

                    count -= 1

                left += 1

            # at this point, it is a valid window, calculate the maximum window length

            res = max(res, right - left)

        return res
```

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 回复 @捉月 大约 1 年前

哈哈，是有点老了。可能是有些过时的内容忘记更新了，我仔细看看哈

![qswde4](https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJM72x1Bnyhsd0y0q6yKOW8KvlSoic6W0PEDx0Cejo9htrOnYjd9Y6aWIEibic6uVYELENze5zZLDRJg/132)

qswde4 4 个月前

1004题Python代码的注释是英文的，希望改进一下

![labuladong](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUUrMeBCJjuvHKjkDGparuRmYns8MHsWeCZza0OZerEZqUmazBMQrNKb942Tmmiad0svicOiadib8eicQ/132)

labuladong

labuladong 东哥 4 个月前

ok，我会修复一下

![捉月](https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlJWibJZnnAWdaNrlC1Fu3MlvJyrwmSnIunOTJyicfN14IwGibrbjYYRHibPhorDqZNb5t9uBSLEjX0g/132)

捉月 大约 1 年前

确实，拿以前的模板直接秒了

```
class Solution:

    def longestOnes(self, nums: List[int], k: int) -> int:

        left,right = 0,0

        res = 0

        count=0

        # start the sliding window template

        while right <(len(nums)):

            # expand the window

            if nums[right] == 0:

                count += 1

            right+=1

            # when the number of 0s that need to be replaced in the window is greater than k, shrink the window

            while count > k:

                if nums[left] == 0:

                    count -= 1

                left += 1

            # at this point, it is a valid window, calculate the maximum window length

            res = max(res, right - left)

        return res
```

![raysry](https://avatars.githubusercontent.com/u/5345679?v=4)

raysry 4 个月前

1. 的 go语言版本，实际逻辑是使用了分桶的思维，这部分没解释，第一次看理解挺费劲的，建议补充说明

![玊尔](https://thirdwx.qlogo.cn/mmopen/vi_32/EFUtJYJA7XxbYc3obSN7jFVMJLiccYPHdlr8iaA481elxORF0G0xAwKjvbojmrfA4cYSynY6ibxMFzudzdhARXShat69ySltS55xFTupjJQ75c/132)

玊尔 5 个月前

第一个题 if 在 while 外面了 ，就感觉模板不是很通用？其实换个问题就是 边界如何自然而然的处理，这个有大佬解释的吗

![zdcat](https://avatars.githubusercontent.com/u/108457097?v=4)

zdcat 超过 1 年前

1658那道题的dp做法，复杂度应该算n^2,不过超时 dp\[i\]\[j\]对应的是数字x，那么dp\[i+1\]\[j\]对应的数字是x-nums\[i\]，dp\[i\]\[j-1\]对应的数字是x-nums\[j\]，对于dp\[i+1\]\[j-1\]对应的数字应该是两个，一个是dp\[i\]\[j-1\]-nums\[i\]，另一个是dp\[i+1\]\[j\]-nums\[j\]，大致是这个关系 dp数组求完之后，遍历所有dp格子，找值为0的情况，此时知道对应的i，j，然后就知道是哪个区间了，然后就知道从原来的数组删除了几步。

```
class Solution {

    public int minOperations(int[] nums, int x) {

        int len = nums.length;

        int dp[][][] = new int[len][len][2];

        dp[0][len - 1][0] = x;

        dp[0][len - 1][1] = x;

        for (int i = 1; i < len; i++) {

            dp[i][len - 1][1] = dp[i - 1][len - 1][1] - nums[i - 1];

            dp[i][len - 1][0] = dp[i][len - 1][1];

        }

        for (int j = len - 2; j >= 0; j--) {

            dp[0][j][0] = dp[0][j + 1][0] - nums[j + 1];

            dp[0][j][1] = dp[0][j][0];

        }

        for (int i = 1; i < len; i++) {

            for (int j = len - 2; j >= 0; j--) {

                dp[i][j][0] = dp[i][j + 1][0] - nums[j + 1];

                dp[i][j][1] = dp[i - 1][j][1] - nums[i - 1];

            }

        }

        int ans = Integer.MAX_VALUE;

        for (int i = 0; i < len; i++) {

            for (int j = 0; j < len; j++) {

                for (int k = 0; k < 2; k++) {

                    if (dp[i][j][k] == 0) {

                        ans = Math.min(ans, i + (len - j));

                    }

                }

            }

        }

        return ans == Integer.MAX_VALUE ? -1 : ans - 1;

    }

    public static void main(String[] args) {

        new Solution().minOperations(new int[]{5, 6, 7, 8, 9}, 4);

    }

}
```

![从来都没有什么救世主](https://thirdwx.qlogo.cn/mmopen/vi_32/j1LWSvM7xTyFVpia1QTMrf5CKV7cwSJtfo4mKZOomJSTtQ5jpiaVibdXqEo0dcVUvOfrNTaMt4icFrWOebORSiak0bQ/132)

从来都没有什么救世主

从来都没有什么救世主 超过 1 年前

713.乘积小于 K 的子数组

代码那里第25行 “# 所以我们需要记录 \[3\], \[2,3\], \[1,2,3\] 这 right - left 个子数组都加上”，这里有错误，java原版和c++是对的，python、go、js里AI转换的代码变成了 “# 所以我们需要记录 \[1\], \[1,2\], \[1,2,3\] 这 right - left 个子数组都加上”

![H](https://thirdwx.qlogo.cn/mmopen/vi_32/gicGSWjejo8ReB2sHO58NJvfEcvicSnmI5AiaIE0ufeXnxrgWnuP5ETL98qddLwT9M18hAUneGr3jaIQqzLoT8yJQ/132)

H 将近 2 年前

22年看过一次，考完研现在在来刷发现多了好多内容，不错不错