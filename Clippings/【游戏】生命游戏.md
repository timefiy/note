---
title: "【游戏】生命游戏"
source: "https://labuladong.online/zh/algo/game/life-game/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "使用算法求解生命游戏。"
tags:
  - "clippings"
---
生命游戏（Conway's Game of Life）是一个非常经典的 **零玩家** 游戏，由英国数学家约翰·何顿·康威在1970年发明。

说它是「零玩家」游戏，是因为它只需要简单的规则，就可以自动演化出极其复杂的模式。

游戏在一个二维网格上进行，每个格子代表一个细胞，细胞有两种状态：存活或死亡。

每个细胞的状态由其周围八个邻居（上下左右及四个对角线）的状态决定，规则如下：

1. **孤独死** ：如果一个活细胞的邻居少于 2 个，它会因为过于孤独而死亡。
2. **稳定存活** ：如果一个活细胞有 2 个或 3 个邻居，它能继续存活到下一代。
3. **拥挤死** ：如果一个活细胞的邻居多于 3 个，它会因为资源过度拥挤而死亡。
4. **繁殖复活** ：如果一个死细胞正好有 3 个邻居，它会「繁殖」出一个新的活细胞。

基于这些简单的规则，给出一个初始状态，游戏就可以不断地自我演化，棋盘中的细胞生生灭灭，最终可能进入一个稳定态（存活细胞数量不再变化），也可能变成永动机（无限地产生新的细胞）。

在网站配套的游戏面板中，你需要完成生命游戏中最关键的部分：写一个算法，按照上述规则计算每次演化的结果。

生命游戏

提交正确的代码后，游戏应该就能自动演化了。游戏中预设了几种经典的初始状态，你可以点击下拉框选择不同的预设，点击开始按钮，查看它们的演化过程。

## 讲解

这个问题比较简单，遍历二维数组，根据周围细胞的状态计算当前细胞的生死状态就可以了。参考解法如下：

```
// 游戏面板仅支持提交 JavaScript 代码

// 其他语言代码的作用是帮助大家理解算法逻辑

#include <vector>

std::vector<std::vector<int>> nextGeneration(const std::vector<std::vector<int>>& grid) {

    int height = grid.size();

    int width = grid[0].size();

    std::vector<std::vector<int>> nextGrid(height, std::vector<int>(width, 0));

    // 计算 grid[row][col] 的活邻居数量

    auto countLiveNeighbors = [&](int row, int col) -> int {

        int count = 0;

        // 检查8个方向的邻居

        for (int i = -1; i <= 1; i++) {

            for (int j = -1; j <= 1; j++) {

                // 跳过自己

                if (i == 0 && j == 0) continue;

                int newRow = row + i;

                int newCol = col + j;

                // 检查边界

                if (newRow >= 0 && newRow < height && newCol >= 0 && newCol < width) {

                    count += grid[newRow][newCol];

                }

            }

        }

        return count;

    };

    // 遍历每个细胞，应用游戏规则

    for (int row = 0; row < height; row++) {

        for (int col = 0; col < width; col++) {

            int currentCell = grid[row][col];

            int liveNeighbors = countLiveNeighbors(row, col);

            if (currentCell == 1) {

                // 活细胞的规则

                if (liveNeighbors < 2) {

                    // 规则 1: 邻居少于 2 个，死于孤独

                    nextGrid[row][col] = 0;

                } else if (liveNeighbors == 2 || liveNeighbors == 3) {

                    // 规则 2: 有 2 个或 3 个邻居，继续存活

                    nextGrid[row][col] = 1;

                } else {

                    // 规则 3: 邻居超过 3 个，死于过度拥挤

                    nextGrid[row][col] = 0;

                }

            } else {

                // 死细胞的规则

                if (liveNeighbors == 3) {

                    // 规则 4: 恰好 3 个活邻居，因繁殖而复活

                    nextGrid[row][col] = 1;

                }

            }

        }

    }

    return nextGrid;

}
```

上述解法可以有一个 follow up：

你是否能够 **原地** 生成结果，而不是创建一个新的二维数组存储演化结果？

核心思路是利用位运算：

为了原地修改（in-place）棋盘，我们不能直接将细胞的下一代状态写入原数组，因为这会影响后续其他细胞的邻居状态计算。

一个聪明的技巧是利用 `int` 类型的额外比特位。一个 `int` 类型通常有 32 个比特位，而我们表示细胞死活状态（0 或 1）只需要 1 个比特位。

所以，我们可以用最低的比特位（第一位）存储细胞的 **当前状态** ：

```
0b000001

       ^
```

用次低的比特位（第二位）存储细胞的 **下一代状态** ：

```
0b000001

      ^
```

这样， `grid[row][col]` 的值可以表示为：

- `0` (`0b000`)：当前是死细胞，下一代还是死细胞。
- `1` (`0b001`)：当前是活细胞，下一代是死细胞。
- `2` (`0b010`)：当前是死细胞，下一代是活细胞。
- `3` (`0b011`)：当前是活细胞，下一代还是活细胞。

算法可以分两步：

1. 遍历整个棋盘，对于每个细胞，根据其周围八个邻居的 **当前状态** （也就是每个邻居值的最低位 `& 1` ）计算出它在下一代是死是活。然后将下一代的状态信息存储到该细胞的第二个比特位上。
2. 再次遍历整个棋盘，每个细胞的值都右移一位（ `>>= 1` ），这样一来，之前存储在第二位的下一代状态就移动到了第一位，成为新的当前状态，原地更新完成。

具体的实现代码如下，你可以提交到游戏面板中，查看原地算法的演化效果。

```
// 游戏面板仅支持提交 JavaScript 代码

// 其他语言代码的作用是帮助大家理解算法逻辑

#include <vector>

std::vector<std::vector<int>>& nextGeneration(std::vector<std::vector<int>>& grid) {

    int height = grid.size();

    int width = grid[0].size();

    // 计算 grid[row][col] 的活邻居数量

    auto countLiveNeighbors = [&](int row, int col) -> int {

        int count = 0;

        // 检查8个方向的邻居

        for (int i = -1; i <= 1; i++) {

            for (int j = -1; j <= 1; j++) {

                // 跳过自己

                if (i == 0 && j == 0) continue;

                int newRow = row + i;

                int newCol = col + j;

                // 检查边界

                if (newRow >= 0 && newRow < height && newCol >= 0 && newCol < width) {

                    // 只关心当前状态（最低位）

                    count += grid[newRow][newCol] & 1;

                }

            }

        }

        return count;

    };

    // 遍历每个细胞，计算下一代状态并存储到第二位

    for (int row = 0; row < height; row++) {

        for (int col = 0; col < width; col++) {

            int currentCell = grid[row][col] & 1; // 获取当前状态

            int liveNeighbors = countLiveNeighbors(row, col);

            if (currentCell == 1) {

                // 活细胞的规则

                if (liveNeighbors == 2 || liveNeighbors == 3) {

                    // 规则 2: 有 2 个或 3 个邻居，继续存活

                    // 将第二位设为 1 (0b10)，表示下一代是活细胞

                    grid[row][col] |= 2;

                }

                // 其他情况（邻居 < 2 或 > 3）默认死亡，第二位保持 0

            } else {

                // 死细胞的规则

                if (liveNeighbors == 3) {

                    // 规则 4: 恰好 3 个活邻居，因繁殖而复活

                    // 将第二位设为 1 (0b10)，表示下一代是活细胞

                    grid[row][col] |= 2;

                }

            }

        }

    }

    // 遍历每个细胞，将下一代状态移到当前位

    for (int row = 0; row < height; row++) {

        for (int col = 0; col < width; col++) {

            // 右移一位，下一代状态变成当前状态

            grid[row][col] >>= 1;

        }

    }

    return grid;

}
```

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表