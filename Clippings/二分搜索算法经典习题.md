---
title: "二分搜索算法经典习题"
source: "https://labuladong.online/zh/algo/problem-set/binary-search/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有二分搜索相关的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [二分搜索算法核心代码模板](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/)
- [实际运用二分搜索时的思维框架](https://labuladong.online/zh/algo/frequency-interview/binary-search-in-action/)

**二分搜索的精髓在于快速收缩搜索区间** 。本文带大家看一看二分搜索算法在数组中的经典运用场景。

## 二维数组中的二分搜索

前文 [二分搜索框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 讲的二分搜索都是在一维数组中的，在二维矩阵中如何施展二分搜索呢？

### 566\. 重塑矩阵

**566\. 重塑矩阵** | [力扣](https://leetcode.cn/problems/reshape-the-matrix/) | [LeetCode](https://leetcode.com/problems/reshape-the-matrix/)

在 MATLAB 中，有一个非常有用的函数 `reshape` ，它可以将一个  `m x n` 矩阵重塑为另一个大小不同（ `r x c` ）的新矩阵，但保留其原始数据。

给你一个由二维数组 `mat` 表示的  `m x n` 矩阵，以及两个正整数 `r` 和 `c` ，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的 **行遍历顺序** 填充。

如果具有给定参数的 `reshape` 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2021/04/24/reshape1-grid.jpg)
```
输入：mat = [[1,2],[3,4]], r = 1, c = 4
输出：[[1,2,3,4]]
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2021/04/24/reshape2-grid.jpg)
```
输入：mat = [[1,2],[3,4]], r = 2, c = 4
输出：[[1,2],[3,4]]
```

**提示：**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 100`
- `-1000 <= mat[i][j] <= 1000`
- `1 <= r, c <= 300`

题目来源： [力扣 566. 重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/) 。

#### 基本思路

这题不难，但指出了一个必知必会的算法技巧： **多维坐标之间的映射转换** 。

我直接说结论： **任何多维数组都可以被映射到一维，所以甭管几维数组，你统一把多维的坐标转化成一维，然后再从一维坐标转化到多维** 。

所以这道题，我们先把二维坐标转化成一维，然后再转化成不同 shape 的二维坐标即可。我这里实现了通用的 `get/set` 函数。

#### 解法代码

```
#include <vector>

using namespace std;

class Solution {

public:

    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {

        int m = mat.size(), n = mat[0].size();

        // 如果想成功 reshape，元素个数应该相同

        if (r * c != m * n) {

            return mat;

        }

        vector<vector<int>> res(r, vector<int>(c));

        for (int i = 0; i < m * n; i++) {

            set(res, i, get(mat, i));

        }

        return res;

    }

    // 通过一维坐标访问二维数组中的元素

    int get(vector<vector<int>>& matrix, int index) {

        int m = matrix.size(), n = matrix[0].size();

        // 计算二维中的横纵坐标

        int i = index / n, j = index % n;

        return matrix[i][j];

    }

    // 通过一维坐标设置二维数组中的元素

    void set(vector<vector<int>>& matrix, int index, int value) {

        int m = matrix.size(), n = matrix[0].size();

        // 计算二维中的横纵坐标

        int i = index / n, j = index % n;

        matrix[i][j] = value;

    }

};
```

#### 算法可视化

算法可视化

**74\. 搜索二维矩阵** | [力扣](https://leetcode.cn/problems/search-a-2d-matrix/) | [LeetCode](https://leetcode.com/problems/search-a-2d-matrix/)

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2020/10/05/mat.jpg)
```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)
```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup>`

题目来源： [力扣 74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) 。

#### 基本思路

只要知道二维数组的的行数 `m` 和列数 `n` ，二维数组的坐标 `(i, j)` 可以映射成一维的 `index = i * n + j` ；反过来也可以通过一维 `index` 反解出二维坐标 `i = index / n, j = index % n` 。

我们在前文 [二分搜索框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 详细讲解了二分搜索的几种框架，本题可以实现一个 `get` 函数把二维数组 `matrix` 的元素访问抽象成在一维数组中访问元素，然后直接施展最基本的二分搜索即可。

#### 解法代码

```
#include <vector>

using namespace std;

class Solution {

public:

    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size(), n = matrix[0].size();

        // 把二维数组映射到一维

        int left = 0, right = m * n - 1;

        // 前文讲的标准的二分搜索框架

        while(left <= right) {

            int mid = left + (right - left) / 2;

            if(get(matrix, mid) == target)

                return true;

            else if (get(matrix, mid) < target)

                left = mid + 1;

            else if (get(matrix, mid) > target)

                right = mid - 1;

        }

        return false;

    }

    // 通过一维坐标访问二维数组中的元素

    int get(vector<vector<int>>& matrix, int index) {

        int m = matrix.size(), n = matrix[0].size();

        // 计算二维中的横纵坐标

        int i = index / n, j = index % n;

        return matrix[i][j];

    }

};
```

#### 算法可视化

编写一个高效的算法来搜索 `*m* x *n*`  矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例 1：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)
```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)
```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup>`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-10<sup>9</sup> <= target <= 10<sup>9</sup>`

题目来源： [力扣 240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/) 。

#### 基本思路

作为 [74\. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/description/) 的进阶题目，这道题不算 [二分搜索算法](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) ，更像 [一个方法秒杀所有 N 数之和问题](https://labuladong.online/zh/algo/practice-in-action/nsum/) ，因为它们的思想上有些类似。

这道题说 `matrix` 从上到下递增，从左到右递增，显然左上角是最小元素，右下角是最大元素。 **我们如果想高效在 `matrix` 中搜索一个元素，肯定需要从某个角开始** ，比如说从左上角开始，然后每次只能向右或向下移动，不要走回头路。

如果真从左上角开始的话，就会发现无论向右还是向下走，元素大小都会增加，那么到底向右还是向下？不确定，那只好用类似 [动态规划算法](https://labuladong.online/zh/algo/essential-technique/dynamic-programming-framework/) 的思路穷举了。

但实际上不用这么麻烦，我们不要从左上角开始，而是从右上角开始，规定只能向左或向下移动。

你注意，如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前位置的元素和 `target` 的相对大小来判断应该往哪移动，不断接近从而找到 `target` 的位置。

当然，如果你想从左下角开始，规定只能向右或向上移动也可以，具体看代码吧。

#### 解法代码

```
class Solution {

public:

    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size(), n = matrix[0].size();

        // 初始化在右上角

        int i = 0, j = n - 1;

        while (i < m && j >= 0) {

            if (matrix[i][j] == target) {

                return true;

            }

            if (matrix[i][j] < target) {

                // 需要大一点，往下移动

                i++;

            } else {

                // 需要小一点，往左移动

                j--;

            }

        }

        // while 循环中没有找到，则 target 不存在

        return false;

    }

};
```

#### 算法可视化

## 二分搜索判定子序列

没想到吧，二分搜索可以用来高效解决子序列的判定问题。

### 392\. 判断子序列

**392\. 判断子序列** | [力扣](https://leetcode.cn/problems/is-subsequence/) | [LeetCode](https://leetcode.com/problems/is-subsequence/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如， `"ace"` 是 `"abcde"` 的一个子序列，而 `"aec"` 不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2,..., Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**致谢：**

特别感谢 [@pbrother](https://leetcode.com/pbrother/) 添加此问题并且创建所有测试用例。

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**示例 2：**

```
输入：s = "axc", t = "ahbgdc"
输出：false
```

**提示：**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成。

题目来源： [力扣 392. 判断子序列](https://leetcode.cn/problems/is-subsequence/) 。

#### 基本思路

力扣上的这道题很简单，利用双指针 `i, j` 分别指向 `s, t` ，一边前进一边匹配子序列。

![](https://labuladong.online/images/algo/subsequence/1.gif)

但这题的进阶版 [792\. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/description/) 比较有难度，如果有很多 `s` ，你每次都这样用 for 循环判断子序列，效率就比较低了，需要利用二分搜索技巧来判断子序列。

#### 解法代码

```
class Solution {

public:

    bool isSubsequence(string s, string t) {

        int i = 0, j = 0;

        while (i < s.size() && j < t.size()) {

            if (s[i] == t[j]) {

                i++;

            }

            j++;

        }

        return i == s.size();

    }

};
```

#### 算法可视化

算法可视化

### 792\. 匹配子序列的单词数

**792\. 匹配子序列的单词数** | [力扣](https://leetcode.cn/problems/number-of-matching-subsequences/) | [LeetCode](https://leetcode.com/problems/number-of-matching-subsequences/)

给定字符串 `s`  和字符串数组  `words`, 返回 *`words[i]` 中是 `s` 的子序列的单词个数* 。

字符串的 **子序列** 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。

- 例如， `“ace”` 是 `“abcde”` 的子序列。

**示例 1:**

```
输入: s = "abcde", words = ["a","bb","acd","ace"]
输出: 3
解释: 有三个是 s 的子序列的单词: "a", "acd", "ace"。
```

**Example 2:**

```
输入: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
输出: 2
```

**提示:**

- `1 <= s.length <= 5 * 10<sup>4</sup>`
- `1 <= words.length <= 5000`
- `1 <= words[i].length <= 50`
- `words[i]` 和 s 都只由小写字母组成。

题目来源： [力扣 792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/) 。

#### 基本思路

现在输入了多个 `word[i]` 让你来判断是否是 `s` 的子序列，这道题的暴力解法就是像 [392\. 判断子序列](https://leetcode.cn/problems/is-subsequence/description/) 那样，直接用嵌套 for 循环一个个比较 `s` 和 `word[i]` 的字符比较来判断子序列，事件复杂度是平方级别。

这个暴力解法中，对于每个 `word[i]` ，都要重复遍历一遍 `s` ，这是比较傻的，或许我们可以优化一下这个过程？

答案是用二分搜索，先把 `s` 中的字符预处理一下，把每个字符出现的的索引列表算出来：

![](https://labuladong.online/images/algo/subsequence/2.jpg)

然后就可以用二分搜索优化了，比如下面这个情况，匹配了 `"ab"` ，应该匹配 `"c"` 了：

![](https://labuladong.online/images/algo/subsequence/1.jpg)

如果按照暴力解法，我们需要 `j` 向前线性扫描寻找 `s[j] == "c"` ，但借助这个 `index` 映射中记录的信息， **可以二分搜索 `index[c]` 中比 `j` 大的那个索引** ，在上图的例子中，就是在 `[0,2,6]` 中搜索大于等于 4 的那个索引：

![](https://labuladong.online/images/algo/subsequence/3.jpg)

这样就可以直接得到下一个 `"c"` 的索引。可以想象，如果字符串 `s` 非常长的时候，二分搜索可以节约很多线性遍历的时间。

现在的问题就是，如何用二分查找计算那个大于等于 4 的索引呢？答案是，寻找左侧边界的二分搜索就可以做到，具体的原因和代码框架我在 [二分搜索算法框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 写过，这里就不展开了。

#### 解法代码

```
class Solution {

public:

    int numMatchingSubseq(string s, vector<string>& words) {

        // 对 s 进行预处理，记录 char -> 该 char 的索引列表

        vector<vector<int>> charToIndexes(26);

        for (int i = 0; i < s.length(); i++) {

            char c = s[i];

            charToIndexes[c - 'a'].push_back(i);

        }

        int res = 0;

        for (string& word : words) {

            // 字符串 word 上的指针 i

            int i = 0;

            // 字符串 s 上的指针 j

            int j = 0;

            // 现在判断 word 是否是 s 的子序列

            // 借助 charToIndexes 查找 word 中每个字符在 s 中的索引

            while (i < word.length()) {

                char c = word[i];

                // 整个 s 压根儿没有字符 word[i]

                if (charToIndexes[c - 'a'].empty()) {

                    break;

                }

                // 二分搜索大于等于 j 的最小索引

                // 即在 s[j..] 中搜索等于 word[i] 的最小索引

                int pos = left_bound(charToIndexes[c - 'a'], j);

                if (pos == charToIndexes[c - 'a'].size()) {

                    break;

                }

                j = charToIndexes[c - 'a'][pos];

                // 如果找到，即 word[i] == s[j]，继续往后匹配

                j++;

                i++;

            }

            // 如果 word 完成匹配，则是 s 的子序列

            if (i == word.length()) {

                res++;

            }

        }

        return res;

    }

    // 查找左侧边界的二分查找

    int left_bound(vector<int>& arr, int target) {

        int left = 0, right = arr.size();

        while (left < right) {

            int mid = left + (right - left) / 2;

            if (target > arr[mid]) {

                left = mid + 1;

            } else {

                right = mid;

            }

        }

        return left;

    }

};
```

#### 算法可视化

算法可视化

## 二分搜索 + 数组双指针

二分搜索结合数组双指针技巧，可以解决「最接近元素」相关的问题。

### 658\. 找到 K 个最接近的元素

**658\. 找到 K 个最接近的元素** | [力扣](https://leetcode.cn/problems/find-k-closest-elements/) | [LeetCode](https://leetcode.com/problems/find-k-closest-elements/)

给定一个 **排序好** 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x` （两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。

整数 `a` 比整数 `b` 更接近 `x` 需要满足：

- `|a - x| < |b - x|` 或者
- `|a - x| == |b - x|` 且 `a < b`

**示例 1：**

```
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
```

**示例 2：**

```
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
```

**提示：**

- `1 <= k <= arr.length`
- `1 <= arr.length <= 10<sup>4</sup>`
- `arr` 按 **升序** 排列
- `-10<sup>4</sup> <= arr[i], x <= 10<sup>4</sup>`

题目来源： [力扣 658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/) 。

#### 基本思路

我们就说一个最简单直接的方式：用 [二分查找算法详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 中介绍的搜索左侧边界的二分查找算法找到 `x` 的位置，然后用 [数组双指针技巧汇总](https://labuladong.online/zh/algo/essential-technique/array-two-pointers-summary/) 中解决 [5\. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/) 的从中间向两端的双指针算法找到这 `k` 个元素。

为什么是搜索左侧边界的二分搜索？可以仔细看下前文 [二分查找算法详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) ，有提到左侧边界二分搜索的几种理解方式。

另外，因为题目要求返回的结果必须按升序排序，所以我们必须用 `LinkedList` 来从两端添加结果，使得结果有序。

#### 解法代码

```
class Solution {

public:

    vector<int> findClosestElements(vector<int>& arr, int k, int x) {

        // 二分搜索找到 x 的位置

        int p = left_bound(arr, x);

        // 两端都开的区间 (left, right)

        int left = p - 1, right = p;

        vector<int> res;

        // 扩展区间，直到区间内包含 k 个元素

        while (right - left - 1 < k) {

            if (left == -1) {

                right++;

            } else if (right == arr.size()) {

                left--;

            } else if (x - arr[left] > arr[right] - x) {

                right++;

            } else {

                left--;

            }

        }

        for (int i = left + 1; i < right; i++) {

            res.push_back(arr[i]);

        }

        return res;

    }

    // 搜索左侧边界的二分搜索

    int left_bound(vector<int>& nums, int target) {

        int left = 0;

        int right = nums.size();

        while (left < right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {

                right = mid;

            } else if (nums[mid] < target) {

                left = mid + 1;

            } else if (nums[mid] > target) {

                right = mid;

            }

        }

        return left;

    }

};
```

#### 算法可视化

算法可视化

## 寻找峰值

**二分搜索的精髓在于快速收缩搜索区间** ，寻找数组中的「峰值」是经典的二分搜索考题，请仔细体会本题是如何快速收缩搜索区间的。

**35\. 搜索插入位置** | [力扣](https://leetcode.cn/problems/search-insert-position/) | [LeetCode](https://leetcode.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示:**

- `1 <= nums.length <= 10<sup>4</sup>`
- `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-10<sup>4</sup> <= target <= 10<sup>4</sup>`

题目来源： [力扣 35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/) 。

#### 基本思路

这道题就是考察搜索左侧边界的二分算法的细节理解，前文 [二分搜索详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 着重讲了数组中存在目标元素重复的情况，没仔细讲目标元素不存在的情况。

**当目标元素 `target` 不存在数组 `nums` 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读** ：

1、返回的这个值是 `nums` 中大于等于 `target` 的最小元素索引。

2、返回的这个值是 `target` 应该插入在 `nums` 中的索引位置。

3、返回的这个值是 `nums` 中小于 `target` 的元素个数。

比如在有序数组 `nums = [2,3,5,7]` 中搜索 `target = 4` ，搜索左边界的二分算法会返回 2，你带入上面的说法，都是对的。

所以以上三种解读都是等价的，可以根据具体题目场景灵活运用，显然这里我们需要的是第二种。

#### 解法代码

```
class Solution {

public:

    int searchInsert(vector<int>& nums, int target) {

        return left_bound(nums, target);

    }

    // 搜索左侧边界的二分算法

    int left_bound(vector<int>& nums, int target) {

        if (nums.size() == 0) return -1;

        int left = 0;

        // 注意

        int right = nums.size();

        // 注意

        while (left < right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {

                right = mid;

            } else if (nums[mid] < target) {

                left = mid + 1;

            } else if (nums[mid] > target) {

                // 注意

                right = mid;

            }

        }

        return left;

    }

};
```

#### 算法可视化

### 162\. 寻找峰值

**162\. 寻找峰值** | [力扣](https://leetcode.cn/problems/find-peak-element/) | [LeetCode](https://leetcode.com/problems/find-peak-element/)

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums` ，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

**提示：**

- `1 <= nums.length <= 1000`
- `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

题目来源： [力扣 162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) 。

#### 基本思路

本题让你求「峰值」元素索引，要是线性遍历的话没什么难度，所以题目要求你必须用二分搜索算法来做。前文 [二分搜索框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 详细探讨了几种常见的二分搜索形式以及其细节，这里就不赘述了。

一般的二分搜索题目要根据 `left, right` 和 `mid` 的大小关系来判断到底应该搜索左侧还是右侧边界，而这道题如果考察 `left, right` 和 `mid` 之间的相对大小会比较麻烦，你可能需要分很多种情况讨论，比如 `nums[mid] < nums[left] < nums[right]` 、 `nums[mid] > nums[left] > nums[right]` 等等，写起来比较繁琐。

这道题更好的思路是不要考虑 `left` 和 `right` ，单纯考虑 `mid` 周边的情况。具体来说，我们计算 `nums[mid]` 和 `nums[mid+1]` 这两个元素的相对大小，即可得到 `mid` 附近的元素走势：

如果走势下行（ `nums[mid] > nums[mid+1]` ），说明 `mid` **本身就是峰值或其左侧有一个峰值** ，所以需要收缩右边界（ `right = mid` ）；

如果走势上行（ `nums[mid] < nums[mid+1]` ），则说明 `mid` **右侧有一个峰值** ，需要收缩左边界（ `left = mid + 1` ）。

因为题目说了 `nums` 中不存在相等的相邻元素，所以不用考虑 `nums[mid] == nums[mid+1]` 的情况，依据以上分析即可写出代码。

#### 解法代码

```
class Solution {

public:

    int findPeakElement(vector<int>& nums) {

        // 取两端都闭的二分搜索

        int left = 0, right = nums.size() - 1;

        // 因为题目必然有解，所以设置 left == right 为结束条件

        while (left < right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] > nums[mid + 1]) {

                // mid 本身就是峰值或其左侧有一个峰值

                right = mid;

            } else {

                // mid 右侧有一个峰值

                left = mid + 1;

            }

        }

        return left;

    }

};
```

#### 算法可视化

算法可视化

### 852\. 山脉数组的峰顶索引

**852\. 山脉数组的峰顶索引** | [力扣](https://leetcode.cn/problems/peak-index-in-a-mountain-array/) | [LeetCode](https://leetcode.com/problems/peak-index-in-a-mountain-array/)

给定一个长度为 `n` 的整数 **山脉** 数组 `arr` ，其中的值递增到一个 **峰值元素** 然后递减。

返回峰值元素的下标。

你必须设计并实现时间复杂度为 `O(log(n))` 的解决方案。

**示例 1：**

```
输入：arr = [0,1,0]
输出：1
```

**示例 2：**

```
输入：arr = [0,2,1,0]
输出：1
```

**示例 3：**

```
输入：arr = [0,10,5,2]
输出：1
```

**提示：**

- `3 <= arr.length <= 10<sup>5</sup>`
- `0 <= arr[i] <= 10<sup>6</sup>`
- 题目数据 **保证** `arr` 是一个山脉数组

题目来源： [力扣 852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/) 。

#### 基本思路

[二分搜索框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 的经典应用，不过这道题和 [162\. 寻找峰值](https://leetcode.cn/problems/find-peak-element/description/) 差不多，直接把 162 题的解法复制过来即可通过。

#### 解法代码

```
#include <vector>

using namespace std;

class Solution {

public:

    int peakIndexInMountainArray(vector<int>& nums) {

        // 取两端都闭的二分搜索

        int left = 0, right = nums.size() - 1;

        // 因为题目必然有解，所以设置 left == right 为结束条件

        while (left < right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] > nums[mid + 1]) {

                // mid 本身就是峰值或其左侧有一个峰值

                right = mid;

            } else {

                // mid 右侧有一个峰值

                left = mid + 1;

            }

        }

        return left;

    }

};
```

#### 算法可视化

算法可视化

## 特殊数组上的二分搜索

二分搜索算法不仅能应用在排好序的数组，如果这个数组不是一个标准的有序数组，只要稍微修改算法逻辑，也能使用二分搜索。 **还是那句话，二分思想的核心在于快速收缩搜索区间** 。

**33\. 搜索旋转排序数组** | [力扣](https://leetcode.cn/problems/search-in-rotated-sorted-array/) | [LeetCode](https://leetcode.com/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前， `nums` 在预先未知的某个下标 `k` （ `0 <= k < nums.length` ）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` （下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

**提示：**

- `1 <= nums.length <= 5000`
- `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10<sup>4</sup> <= target <= 10<sup>4</sup>`

题目来源： [力扣 33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 。

#### 基本思路

这是一道经典的二分搜索题目，只要把图画出来并且正确理解了前文 [二分搜索框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) ，难度不算大。

把一个排好序的数组就好比一段斜向上的山坡，沿着一个元素旋转数组，相当于将山坡切断并旋转，在原本平滑的山坡上产生一个「断崖」：

![](https://labuladong.online/images/algo/brief-extra/33_1.jpeg)

注意「断崖」左侧的所有元素比右侧所有元素都大，我们是可以在这样一个存在断崖的山坡上用二分搜索算法搜索元素的，主要分成两步：

**1、确定 `mid` 中点落在「断崖」左侧还是右侧** 。

**2、在第 1 步确定的结果之上，根据 `target` 和 `nums[left], nums[right], nums[mid]` 的相对大小收缩搜索区间** 。

具体来说，我们首先可以根据 `nums[mid]` 和 `nums[left]` 的相对大小确定 `mid` 和「断崖」的相对位置：

```
if (nums[mid] >= nums[left]) {

    // mid 落在断崖左边，此时 nums[left..mid] 有序

} else {

    // mid 落在断崖右边，此时 nums[mid..right] 有序

}
```

![](https://labuladong.online/images/algo/brief-extra/33_2.jpeg)

假设 `mid` 在「断崖」左侧，那么可以肯定 `nums[left..mid]` 是连续且有序的，所以如果 `nums[left] <= target < nums[mid]` ，则可以收缩右边界，否则应该收缩左边界。

假设 `mid` 在「断崖」右侧，那么可以肯定 `nums[mid..right]` 是连续且有序的，所以如果 `nums[mid] < target <= nums[right]` ，则可以收缩左边界，否则应该收缩右边界。

有了这个思路，即可写出正确的代码，更多细节问题见注释。

#### 解法代码

```
#include <vector>

using namespace std;

class Solution {

public:

    int search(vector<int>& nums, int target) {

        // 左右都闭的搜索区间

        int left = 0, right = nums.size() - 1;

        // 因为是闭区间，所以结束条件为 left > right

        while (left <= right) {

            int mid = left + (right - left) / 2;

            // 首先检查 nums[mid]，是否找到 target

            if (nums[mid] == target) {

                return mid;

            }

            if (nums[mid] >= nums[left]) {

                // mid 落在断崖左边，此时 nums[left..mid] 有序

                if (target >= nums[left] && target < nums[mid]) {

                    // target 落在 [left..mid-1] 中

                    right = mid - 1;

                } else {

                    // target 落在 [mid+1..right] 中

                    left = mid + 1;

                }

            } else {

                // mid 落在断崖右边，此时 nums[mid..right] 有序

                if (target <= nums[right] && target > nums[mid]) {

                    // target 落在 [mid+1..right] 中

                    left = mid + 1;

                } else {

                    // target 落在 [left..mid-1] 中

                    right = mid - 1;

                }

            }

        }

        // while 结束还没找到，说明 target 不存在

        return -1;

    }

};
```

#### 算法可视化

已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。

在传递给函数之前， `nums` 在预先未知的某个下标 `k` （ `0 <= k < nums.length` ）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` （下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

你必须尽可能减少整个操作步骤。

**示例 1：**

```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```

**示例 2：**

```
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```

**提示：**

- `1 <= nums.length <= 5000`
- `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10<sup>4</sup> <= target <= 10<sup>4</sup>`

**进阶：**

- 此题与 [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/) 相似，但本题中的 `nums` 可能包含 **重复** 元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

题目来源： [力扣 81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) 。

#### 基本思路

做这道题，需要你学习 前文 [二分搜索框架详解](https://labuladong.online/zh/algo/essential-technique/binary-search-framework/) 并完成 [33\. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/) 题，本题和 33 题很类似，不过本题的关键在于题目说数组中可能存在重复元素。

我在第 33 题的解法中说过，在一个存在「断崖」的山坡上用二分搜索算法搜索元素主要分成两步：

**1、确定 `mid` 中点落在「断崖」左侧还是右侧** 。

**2、在第 1 步确定的结果之上，根据 `target` 和 `nums[left], nums[right], nums[mid]` 的相对大小收缩搜索区间** 。

而对于这道题， `nums` 中存在重复元素，会影响到第 1 步，你比如说输入旋转后的数组 `nums = [2,2,2,2,0,1,2]` ，画成图就是这样：

![](https://labuladong.online/images/algo/brief-extra/81_1.jpeg)

如上图， `mid` 将会落到左侧的直线上，此时 `nums[left] == nums[mid] == nums[right]` ，无法根据它们的相对大小判断「断崖」到底在 `mid` 的左边还是右边，从而无法进入第 2 步。

我们的解决方案就是：不要出现 `nums[left] == nums[mid] == nums[right]` 的情况， **即在计算 `mid` 之前收缩 `left, right` 边界，提前消除重复元素** ：

![](https://labuladong.online/images/algo/brief-extra/81_2.jpeg)

这样 `mid` 必然出现在山坡上，不会和 `nums[left], nums[right]` 相等，然后就可以正常执行第 2 步逻辑，和第 33 题的解法完全相同了，具体看解法代码。

#### 解法代码

```
class Solution {

public:

    bool search(vector<int>& nums, int target) {

        int left = 0, right = nums.size() - 1;

        while (left <= right) {

            // 本题需要在计算 mid 之前收缩左右边界去重

            while (left < right && nums[left] == nums[left + 1]) {

                left++;

            }

            while (left < right && nums[right] == nums[right - 1]) {

                right--;

            }

            // 其余逻辑和第 33 题完全相同

            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {

                return true;

            }

            if (nums[mid] >= nums[left]) {

                // mid 落在断崖左边，此时 nums[left..mid] 有序

                if (target >= nums[left] && target < nums[mid]) {

                    // target 落在 [left..mid-1] 中

                    right = mid - 1;

                } else {

                    // target 落在 [mid+1..right] 中

                    left = mid + 1;

                }

            } else {

                // mid 落在断崖右边，此时 nums[mid..right] 有序

                if (target <= nums[right] && target > nums[mid]) {

                    // target 落在 [mid+1..right] 中

                    left = mid + 1;

                } else {

                    // target 落在 [left..mid-1] 中

                    right = mid - 1;

                }

            }

        }

        // while 结束还没找到，说明 target 不存在

        return false;

    }

};
```

#### 算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表