---
title: "位图原理及实现"
source: "https://labuladong.online/zh/algo/data-structure-basic/bitmap/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-06
description: "本文讲解位图（Bitmap）数据结构的原理，并从零实现一个位图，帮你理解其高效利用内存的底层原理。"
tags:
  - "clippings"
---
一句话总结

位图（BitMap）是一种非常节省空间的数据结构，它用一个比特位（bit）的 0 和 1 来标记某个元素是否存在。

在后面做算法题时，我们会经常用到类似 `boolean[] visited` 这样的布尔数组，来记录数组中那些元素已经被访问过。

```
// 假设 nums 是一个包含 1000 个整数的数组

int[] nums = {...}

// 我们在写算法时

// 可能会用一个布尔数组来记录 nums 中那些元素已经被访问过

boolean[] visited = new boolean[nums.length];

visited[10] = true;

visited[100] = true;
```

我们来仔细观察这个场景，是否存在优化空间？

布尔类型只有 `true` 和 `false` 两种状态，理论上只需要 1 个比特位（bit）的 `0` 和 `1` 就可以表示。

但在大部分编程语言中，由于内存寻址等原因，一个布尔元素通常会占用 1 字节（byte），也就是 8 个比特位的内存。

这就意味着，编程语言内置的布尔数组 `boolean[]` 实际上浪费了 7/8 的内存空间。

那么我们是否可以优化？答案是肯定的。

提示

在实际开发和求解算法题的过程中，我们使用编程语言提供的布尔数组就够了， **除非需要处理的数据规模非常大，否则没必要为了节省这一点内存空间而引入位图这种结构** 。

比如后文介绍的 [布隆过滤器](https://labuladong.online/zh/algo/data-structure-basic/bloom-filter/) ，专门为了处理超大规模数据而设计，才需要使用位图这种结构进行优化。

## 位图的原理与实现

优化内存的思路很简单，就是要充分利用每个比特位。

我们可以用 `long[] words` 来作为底层存储。不过索引的计算规则需要稍微改造一下，以便我们精确地控制每个比特位。

一个 `long` 类型数据是 8 byte，也就是 64 bit，假设我们想访问第 135 个比特位，那么：

1. `135 / 64 = 2` ，所以目标比特位在 `words` 数组的索引 2 的位置，即 `words[2]` 。
2. `135 % 64 = 7` ，所以目标比特位在 `words[2]` 元素的第 7 个比特位（从 0 开始数）。

如果你绕不过来，可以想象 `long[] words` 是一个二维数组， `words[i]` 就是访问二维数组的第 `i` 行，每一行有 64 个比特位。你想访问第 `k` 个比特位，就是访问二维数组的第 `k / 64` 行，第 `k % 64` 列。

了解了索引转化规则之后就简单了，我们暴露几个方法，让用户操作位图：

- `boolean get(int bitIndex)` ：判断第 `bitIndex` 个比特位是否为 1。
- `void set(int bitIndex)` ：将第 `bitIndex` 个比特位设置为 1。
- `void clear(int bitIndex)` ：将第 `bitIndex` 个比特位设置为 0。

```
#include <iostream>

#include <vector>

#include <stdexcept>

using namespace std;

class MyBitSet {

private:

    // 使用 unsigned long 数组作为位图的底层存储

    vector<unsigned long> words;

    // 位图能够存储的最大元素值 + 1

    int size;

public:

    MyBitSet(int size) : size(size) {

        // 根据 size 计算需要多少个 unsigned long long 来存储

        int arraySize = size / 64 + 1;

        words.resize(arraySize, 0);

    }

    // 判断指定比特位是否为 1

    bool get(int bitIndex) {

        if (bitIndex < 0 || bitIndex >= size) {

            throw out_of_range("bitIndex must be between 0 and " + to_string(size - 1));

        }

        // 找到 bitIndex 在 words 数组中的索引

        int wordIndex = bitIndex / 64;

        // 找到 bitIndex 在 unsigned long long 值中的具体 bit 位

        int bitOffset = bitIndex % 64;

        // 使用 & 操作判断该位是否为 1

        return (words[wordIndex] & (1ULL << bitOffset)) != 0;

    }

    // 将指定比特位设置为 1

    void set(int bitIndex) {

        if (bitIndex < 0 || bitIndex >= size) {

            throw out_of_range("bitIndex must be between 0 and " + to_string(size - 1));

        }

        // 找到 bitIndex 在 words 数组中的索引

        int wordIndex = bitIndex / 64;

        // 找到 bitIndex 在 unsigned long long 值中的具体 bit 位

        int bitOffset = bitIndex % 64;

        // 使用 | 操作将该位置 1

        words[wordIndex] |= (1ULL << bitOffset);

    }

    // 将指定比特位设置为 0

    void clear(int bitIndex) {

        if (bitIndex < 0 || bitIndex >= size) {

            throw out_of_range("bitIndex must be between 0 and " + to_string(size - 1));

        }

        int wordIndex = bitIndex / 64;

        int bitOffset = bitIndex % 64;

        // 使用 & 和 ~ 操作将该位置 0

        words[wordIndex] &= ~(1ULL << bitOffset);

    }

};

int main() {

    MyBitSet bitSet(1000);

    bitSet.set(10);

    bitSet.set(100);

    bitSet.set(500);

    cout << "Get 10: " << (bitSet.get(10) ? "true" : "false") << endl;     // true

    cout << "Get 100: " << (bitSet.get(100) ? "true" : "false") << endl;   // true

    cout << "Get 200: " << (bitSet.get(200) ? "true" : "false") << endl;   // false

    bitSet.clear(100);

    cout << "Get 100 after clear: " << (bitSet.get(100) ? "true" : "false") << endl; // false

    return 0;

}
```

上面的代码就实现了位图的核心功能。不过其中的运算可以有一些小优化：

- `bitIndex / 64` 可以优化为 `bitIndex >> 6` ，因为 $2^6 = 64$ 。
- `bitIndex % 64` 可以优化为 `bitIndex & 63` ，因为当除数是 2 的整数次幂（比如 $64 = 2^6$ ）时，取模运算 `% 64` 等价于位运算 `& (64 - 1)` 。

位运算的效率比普通运算的效率高得多，所以优化后的代码性能会更好一些。这几个位运算技巧你可以先记住，原理会在 [常用的位操作](https://labuladong.online/zh/algo/frequency-interview/bitwise-operation/) 中介绍，这里不展开讲了。

更新时间：2026/02/05 12:53

## 评论

Markdown

Ctrl+Enter 发表