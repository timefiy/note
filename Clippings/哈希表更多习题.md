---
title: "哈希表更多习题"
source: "https://labuladong.online/zh/algo/problem-set/hash-table/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有哈希表结构的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [哈希表原理](https://labuladong.online/zh/algo/data-structure-basic/hashmap-basic/)
- [拉链法实现哈希表](https://labuladong.online/zh/algo/data-structure-basic/hashtable-chaining/)

哈希表在算法题中是常考的数据结构，主要出现在数据结构的设计题，或者配合数组、字符串等结构进行考察（比如之前的 [前缀和习题](https://labuladong.online/zh/algo/problem-set/perfix-sum/) ），这里列出一些常见的哈希表考题。

Tip

首先，哈希表的常见作用就是空间换时间，提高算法效率，下面看几道相关题目。

### 1\. 两数之和

**1\. 两数之和** | [力扣](https://leetcode.cn/problems/two-sum/) | [LeetCode](https://leetcode.com/problems/two-sum/)

给定一个整数数组 `nums`  和一个整数目标值 `target` ，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 10<sup>4</sup>`
- `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
- `-10<sup>9</sup> <= target <= 10<sup>9</sup>`
- **只会存在一个有效答案**

**进阶：** 你可以想出一个时间复杂度小于 `O(n<sup>2</sup>)` 的算法吗？

题目来源： [力扣 1. 两数之和](https://leetcode.cn/problems/two-sum/) 。

#### 基本思路

大家都喜欢幽默的人，如果你想调侃自己经常拖延，可以这样调侃下自己（手动狗头）：

背单词背了半年还是 abandon, abandon，刷题刷了半年还是 two sum, two sum...

言归正传，这道题不难，但由于它是 LeetCode 第一题，所以名气比较大，解决这道题也可以有多种思路，我这里说两种最常见的思路。

第一种思路就是靠排序，把 `nums` 排序之后就可以用 [数组双指针技巧汇总](https://labuladong.online/zh/algo/essential-technique/array-two-pointers-summary/) 中讲到的左右指针来求出和为 `target` 的两个数。

不过因为题目要求我们返回元素的索引，而排序会破坏元素的原始索引，所以要记录值和原始索引的映射。

进一步，如果题目拓展延伸一下，让你求三数之和、四数之和，你依然可以用双指针技巧，我在 [一个函数秒杀 nSum 问题](https://labuladong.online/zh/algo/practice-in-action/nsum/) 中写一个函数来解决所有 N 数之和问题。

第二种思路是用哈希表辅助判断。对于一个元素 `nums[i]` ，你想知道有没有另一个元素 `nums[j]` 的值为 `target - nums[i]` ，这很简单，我们用一个哈希表记录每个元素的值到索引的映射，这样就能快速判断数组中是否有一个值为 `target - nums[i]` 的元素了。

简单说，数组其实可以理解为一个「索引 -> 值」的哈希表映射，而我们又建立一个「值 -> 索引」的映射即可完成此题。

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [一个方法团灭 nSum 问题](https://labuladong.online/zh/algo/practice-in-action/nsum/)
- [编程语言刷题实践](https://labuladong.online/zh/algo/programming-language-basic/lc-practice/)

### 128\. 最长连续序列

**128\. 最长连续序列** | [力扣](https://leetcode.cn/problems/longest-consecutive-sequence/) | [LeetCode](https://leetcode.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

- `0 <= nums.length <= 10<sup>5</sup>`
- `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`

题目来源： [力扣 128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) 。

#### 基本思路

这道题最直接的想法就是排序，排序之后连续的序列就很容易找到了。不过排序的时间复杂度是 `O(NlogN)` ，而题目要求我们时间复杂度为 `O(N)` ，这就得另想办法了。

想找连续序列，首先要找到这个连续序列的开头元素，然后递增，看看之后有多少个元素还在 `nums` 中，即可得到最长连续序列的长度了。

我们可以用空间换时间的思路，把数组元素放到哈希集合里面，然后去寻找连续序列的第一个元素，即可在 `O(N)` 时间找到答案。

比方说 `nums = [8,4,9,1,3,2]` ，我们先找到 1，然后递增，找到了 2, 3, 4，这就是一个长度为 4 的序列。又找到 8，往上递增直到找到了 9，这是一个长度为 2 的序列。

具体逻辑看代码吧，虽然 for 循环嵌套 while 循环，但是每个元素只会被遍历到最多两次，所以均摊时间复杂度依然为 `O(N)` ，具体分析方法见 [算法时空复杂度分析实用指南](https://labuladong.online/zh/algo/essential-technique/complexity-analysis/) 。

#### 解法代码

#### 算法可视化

算法可视化

### 290\. 单词规律

**290\. 单词规律** | [力扣](https://leetcode.cn/problems/word-pattern/) | [LeetCode](https://leetcode.com/problems/word-pattern/)

给定一种规律 `pattern`  和一个字符串  `s`  ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern`  里的每个字母和字符串  `s` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", s = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", s = "dog cat cat dog"
输出: false
```

**提示:**

- `1 <= pattern.length <= 300`
- `pattern` 只包含小写英文字母
- `1 <= s.length <= 3000`
- `s` 只包含小写英文字母和 `' '`
- `s` **不包含** 任何前导或尾随对空格
- `s` 中每个单词都被 **单个空格** 分隔

题目来源： [力扣 290. 单词规律](https://leetcode.cn/problems/word-pattern/) 。

#### 基本思路

原谅我一开始都没理解这题啥意思，原来就是类似我们小学学的叠词，比方说 AABB -> 大大方方，ABAB -> 打听打听。题目其实就是问你 `s` 是否符合 `pattern` 的叠词模式。

那思路就很简单了，利用哈希表，把 `pattern` 中的每个叠词模式字符在 `s` 中的对应单词记录下来，就能判断 `s` 是否匹配 `pattern` 的模式了，比较简单。

另外，这道题的进阶题目 [291\. 单词规律 II](https://leetcode.cn/problems/word-pattern-ii/description/) 比较有意思，考察暴力穷举算法。

#### 解法代码

#### 算法可视化

算法可视化

### 519\. 随机翻转矩阵

**519\. 随机翻转矩阵** | [力扣](https://leetcode.cn/problems/random-flip-matrix/) | [LeetCode](https://leetcode.com/problems/random-flip-matrix/)

给你一个 `m x n` 的二元矩阵 `matrix` ，且所有值被初始化为 `0` 。请你设计一个算法，随机选取一个满足  `matrix[i][j] == 0` 的下标 `(i, j)` ，并将它的值变为 `1` 。所有满足 `matrix[i][j] == 0` 的下标 `(i, j)` 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 `Solution` 类：

- `Solution(int m, int n)` 使用二元矩阵的大小 `m` 和 `n` 初始化该对象
- `int[] flip()` 返回一个满足 `matrix[i][j] == 0` 的随机下标 `[i, j]` ，并将其对应格子中的值变为 `1`
- `void reset()` 将矩阵中所有的值重置为 `0`

**示例：**

```
输入
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
```

**提示：**

- `1 <= m, n <= 10<sup>4</sup>`
- 每次调用 `flip` 时，矩阵中至少存在一个值为 0 的格子。
- 最多调用 `1000` 次 `flip` 和 `reset` 方法。

题目来源： [力扣 519. 随机翻转矩阵](https://leetcode.cn/problems/random-flip-matrix/) 。

#### 基本思路

这道题的需求看起来很简单，但说实话这题并不是初学者能够高效解决的，下面我来一步步拆解这道题。

首先，你需要直到对多维坐标进行「降维」的技巧，把二维坐标映射到一维，因为我们生成的随机数可以认为是一维坐标。这个技巧不难，可以参考 [566\. 重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/description/) 。

其次，你需要看过我的这篇文章 [给我常数时间，我可以删除/查找数组中的任意元素](https://labuladong.online/zh/algo/data-structure/random-set/) 并跟着做了 [380\. 常数时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/description/) ，题目说要尽可能减少调用随机函数，就是在考你把数组元素换到尾部的技巧。

**本题其实面对的是相同的问题，相当于是给你一个长度为 `m * n` 的数组，请你每次取出一个随机数并删除它** 。

所以解决本题也使用同样的思路，抽象出一个长度为 `m * n` 的数组，每次取出一个随机元素之后把这个元素置换到数组尾部删掉，同时用一个哈希表记录被置换元素的映射，保证每次随机不会得到重复元素。

具体的实现看代码吧，本质上其实和 380 是一模一样的。

#### 解法代码

#### 算法可视化

算法可视化

Tip

如果然你复制一个比较复杂的数据结构，那边哈希表可以帮你存储原始结构到克隆结构的映射：

### 138\. 随机链表的复制

**138\. 随机链表的复制** | [力扣](https://leetcode.cn/problems/copy-list-with-random-pointer/) | [LeetCode](https://leetcode.com/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)** 。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。 **复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val` ：一个表示  `Node.val` 的整数。
- `random_index` ：随机指针指向的节点索引（范围从  `0`  到  `n-1` ）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**提示：**

- `0 <= n <= 1000`
- `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`
- `Node.random`  为  `null` 或指向链表中的节点。

题目来源： [力扣 138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/) 。

#### 基本思路

这道题目，就属于会者不难，难者不会的那类题，后面他还可以给你变出更多花样，比如克隆带随机指针的二叉树，你会不会？那再让你克隆图，你会不会？

**对于数据结构复制，甭管他怎么变，你就记住最简单的方式：一个哈希表 + 两次遍历** 。

第一次遍历专门克隆节点，借助哈希表把原始节点和克隆节点的映射存储起来；第二次专门组装节点，照着原数据结构的样子，把克隆节点的指针组装起来。

题目如果让你克隆带随机指针的二叉树，或者克隆图，都是一样的，只不过是遍历的方式从 for 循环迭代遍历变成 `traverse` 递归函数遍历罢了。

#### 解法代码

#### 算法可视化

算法可视化

### 133\. 克隆图

**133\. 克隆图** | [力扣](https://leetcode.cn/problems/clone-graph/) | [LeetCode](https://leetcode.com/problems/clone-graph/)

给你无向 **[连通](https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin) （克隆）。

图中的每个节点都包含它的值 `val` （ `int` ） 和其邻居的列表（ `list[Node]` ）。

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

**测试用例格式：**

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（ `val = 1` ），第二个节点值为 2（ `val = 2` ），以此类推。该图在测试用例中使用邻接列表表示。

**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。

**示例 1：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)

```
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

**示例 2：**

![](https://labuladong.online/images/lc/aliyun-lc-upload/uploads/2020/02/01/graph.png)

```
输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
```

**示例 3：**

```
输入：adjList = []
输出：[]
解释：这个图是空的，它不含任何节点。
```

**提示：**

- 这张图中的节点数在 `[0, 100]` 之间。
- `1 <= Node.val <= 100`
- 每个节点值 `Node.val` 都是唯一的，
- 图中没有重复的边，也没有自环。
- 图是连通图，你可以从给定节点访问到所有节点。

题目来源： [力扣 133. 克隆图](https://leetcode.cn/problems/clone-graph/) 。

#### 基本思路

这种递归数据结构的克隆问题，一般套路就是要用一个哈希表把原节点和克隆节点映射起来，剩下的就是遍历，把克隆节点组装起来。

这道题可以认为是 [1490\. 克隆 N 叉树](https://leetcode.cn/problems/clone-n-ary-tree/description/) 的进阶版，可以有多种解法，我决定用 [图结构的遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/) 来做。

我们用 DFS 遍历框架遍历原图，遍历的过程中在后序位置顺便构建克隆图，同时用一个哈希表存储原图和克隆图中的节点映射，这样就能得到克隆图了。

为了清晰起见，我这个解法使用了 `visited` 集合标记访问过的节点，其实你想想， `originToClone` 这个映射的键就可以替代 `visited` 的作用，你可以自行省去 `visited` 集合，提升效率。

如果你觉得我这种利用后序位置的写法有点难理解，你可以遍历两次图结构，第一次遍历的时候专门填充 `originToClone` 把克隆节点创建出来，第二次遍历拿着这个 `originToClone` 把图结构组装起来。具体参考我在 1490 题写的代码。

另外，参考 1490 题，你也可以尝试分解问题的思路来克隆图，和二叉树是差不多的。

#### 解法代码

#### 算法可视化

算法可视化

Tip

单词的「异位词」也可以用到哈希表，因为哈希表经常用来当做计数器使用。需要注意的是，哈希表在实际应用中不一定是 `HashMap` ，有时候键的数量有限（比如说键只有 26 个小写字母），可以用数组来模拟哈希表的作用。虽然从复杂度上讲这样并没有本质上的优化，但实际运行效率确实会更高一些。

### 242\. 有效的字母异位词

**242\. 有效的字母异位词** | [力扣](https://leetcode.cn/problems/valid-anagram/) | [LeetCode](https://leetcode.com/problems/valid-anagram/)

给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。

**注意：** 若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**提示:**

- `1 <= s.length, t.length <= 5 * 10<sup>4</sup>`
- `s` 和 `t` 仅包含小写字母

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

题目来源： [力扣 242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/) 。

#### 基本思路

这题考察字符串的编码，如何找到一种编码方法，使得字母异位词的编码都相同？

一种直接的编码方式就是排序，异位词中字符排序后就会变成相同的字符串，不过排序的复杂度略高。

异位词中字符出现的次数肯定都是一样的，所以可以把 `s, t` 中的字符计数器作为编码，比较每个字符的出现次数即可判断 `s` 和 `t` 是否是异位词。

#### 解法代码

#### 算法可视化

算法可视化

### 49\. 字母异位词分组

**49\. 字母异位词分组** | [力扣](https://leetcode.cn/problems/group-anagrams/) | [LeetCode](https://leetcode.com/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

**提示：**

- `1 <= strs.length <= 10<sup>4</sup>`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母

题目来源： [力扣 49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/) 。

#### 基本思路

异位词这类问题的关键在于，你如何迅速判断两个字符串是异位词，主要考察数据编码和哈希表的使用：

你是否可以找到一种编码方法，使得字母异位词的编码都相同？找到这种编码方式之后，就可以用一个哈希表存储编码相同的所有异位词，得到最终的答案。

[242\. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/) 考察了异位词的编码问题，对字符串排序可以是一种编码方案，如果是异位词，排序后就变成一样的了，但是这样时间复杂度略高，且会修改原始数据。更好的编码方案是利用每个字符的出现次数进行编码，也就是下面的解法代码。

#### 解法代码

#### 算法可视化

算法可视化

### 387\. 字符串中的第一个唯一字符

**387\. 字符串中的第一个唯一字符** | [力扣](https://leetcode.cn/problems/first-unique-character-in-a-string/) | [LeetCode](https://leetcode.com/problems/first-unique-character-in-a-string/)

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

**示例 1：**

```
输入: s = "leetcode"
输出: 0
```

**示例 2:**

```
输入: s = "loveleetcode"
输出: 2
```

**示例 3:**

```
输入: s = "aabb"
输出: -1
```

**提示:**

- `1 <= s.length <= 10<sup>5</sup>`
- `s` 只包含小写字母

题目来源： [力扣 387. 字符串中的第一个唯一字符](https://leetcode.cn/problems/first-unique-character-in-a-string/) 。

#### 基本思路

这题很简单，就是考察哈希映射的使用，你可以用一个 `HashMap` 记录每个字符出现的频率。

不过考虑到题目输入只有小写字母，所以可以用一个数组充当哈希映射的作用，其中索引代表字符的 ASCII 码，对应的值代表出现的频率。

#### 解法代码

#### 算法可视化

算法可视化

Tip

有的题目的常规解法需要用到哈希表，但稍加思考可以得出更精妙的解法，从而避免哈希表的空间消耗，下面列举几道。

### 169\. 多数元素

**169\. 多数元素** | [力扣](https://leetcode.cn/problems/majority-element/) | [LeetCode](https://leetcode.com/problems/majority-element/)

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```
**提示：**
- `n == nums.length`
- `1 <= n <= 5 * 10<sup>4</sup>`
- `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`

**进阶：** 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

题目来源： [力扣 169. 多数元素](https://leetcode.cn/problems/majority-element/) 。

#### 基本思路

这道题的标准解法肯定是用一个哈希表作为计数器记录每个元素出现的次数，然后寻找出现次数最多的那个元素，时间和空间复杂度都是 `O(N)` 。

但是由于题目说了这个目标元素（众数）出现的次数 **过半** ，这就有意思了，其实我们不需要用哈希表来做计数器就能把这个众数找出来。

你想象一下，比方说一群带正电的粒子和一群带负电的粒子，把它们混合起来，得到的这群混合粒子的带电性质是什么？这取决于正电离子多还是负电离子多，如果正负粒子数量恰好相等，则呈电中性。

回到这道题，题目告诉你一定存在一个众数，它出现的次数过半，那么如果你把这个众数元素想象成正电粒子，其他的所有元素都想象成负电粒子，那么它们混合起来会怎样？

**在正负粒子混合的过程中，整体的带电性可能在正负间波动，但最终的结果一定是正电** 。

有了这个类比，你看下解法代码，我们是如何用 `O(1)` 的空间复杂度来计算众数的。

#### 解法代码

#### 算法可视化

算法可视化

### 389\. 找不同

**389\. 找不同** | [力扣](https://leetcode.cn/problems/find-the-difference/) | [LeetCode](https://leetcode.com/problems/find-the-difference/)

给定两个字符串 `s` 和 `t` ，它们只包含小写字母。

字符串 `t`  由字符串 `s` 随机重排，然后在随机位置添加一个字母。

请找出在 `t` 中被添加的字母。

**示例 1：**

```
输入：s = "abcd", t = "abcde"
输出："e"
解释：'e' 是那个被添加的字母。
```

**示例 2：**

```
输入：s = "", t = "y"
输出："y"
```

**提示：**

- `0 <= s.length <= 1000`
- `t.length == s.length + 1`
- `s` 和 `t` 只包含小写字母

题目来源： [力扣 389. 找不同](https://leetcode.cn/problems/find-the-difference/) 。

#### 基本思路

这道题常规的思路是排序，两个字符串排序后，那个多出来的字符自然就很容易找到，但排序算法的时空复杂度都是 `O(NlogN)` ，不是最优解法。

或者用哈希表计数，比较每个字符出现的次数，也很容易找到多出来的那个元素，时空复杂度都是 `O(N)` 。注意由于题目说两个字符串只包含小写字母，所以用大小为 26 的字符数组就可以代替 `HashMap` 的作用，效率更高一些。

当然，最优的方法是用位运算，异或操作 `^` 的运算特点是 `a ^ 0 = a, a ^ a = 0` ，即任何数字和 0 做异或的结果还是它本身，任何数字和它本身异或的结果是 0。

字符其实就是数字，所以我们可以把这两个字符串中所有字符拿出来做异或操作，这样相同的两个数字都抵消为 0 了，最终剩下的就是多出来的那个数字。时间复杂度 `O(N)` ，空间复杂度 `O(1)` 。

更多位运算技巧参见 [常用的位运算技巧](https://labuladong.online/zh/algo/frequency-interview/bitwise-operation/) 。

#### 解法代码

#### 算法可视化

算法可视化

### 442\. 数组中重复的数据

**442\. 数组中重复的数据** | [力扣](https://leetcode.cn/problems/find-all-duplicates-in-an-array/) | [LeetCode](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间的算法解决此问题。

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1,2]
输出：[1]
```

**示例 3：**

```
输入：nums = [1]
输出：[]
```

**提示：**

- `n == nums.length`
- `1 <= n <= 10<sup>5</sup>`
- `1 <= nums[i] <= n`
- `nums` 中的每个元素出现 **一次** 或 **两次**

题目来源： [力扣 442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/) 。

#### 基本思路

这道题就用常规的解法做吧，用哈希集合很容易找到 `nums` 中那些重复的元素。

不用额外的存储空间的解法我也写了，因为题目说 `nums` 中的元素取值都在 `[1, n]` 之间，即元素本身就和索引成映射关系，所以可以用 `nums` 本身模拟哈希集合的效果，详解你可以看下 [如何寻找缺失和重复的元素](https://labuladong.online/zh/algo/frequency-interview/mismatch-set/) 。

> 注意：用乘 -1 的方式给索引做标记的前提是， `nums` 中的元素都为正数，不能包含 0，否则无法区分该索引是否被标记。

#### 解法代码

#### 算法可视化

算法可视化

### 448\. 找到所有数组中消失的数字

**448\. 找到所有数组中消失的数字** | [力扣](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/) | [LeetCode](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[2]
```

**提示：**

- `n == nums.length`
- `1 <= n <= 10<sup>5</sup>`
- `1 <= nums[i] <= n`

**进阶：** 你能在不使用额外空间且时间复杂度为 `O(n)` 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

题目来源： [力扣 448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/) 。

#### 基本思路

这道题的常规的解法很简单，用一个数组模拟哈希集合，很容易找到 `nums` 中那些没有出现的元素。

非要优化空间复杂度也简单，说白了就是用输入数组 `nums` 本身作为哈希集合。只要你做了 [442\. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/) ，不难想到这道题也有不用额外的存储空间的解法。

因为题目说 `nums` 中的元素取值都在 `[1, n]` 之间，所以在 `[0, n-1]` 之间，即元素本身就和索引可以形成一一映射关系，所以可以用 `nums` 本身模拟哈希集合的效果，可以参考这篇文章 [如何寻找缺失和重复的元素](https://labuladong.online/zh/algo/frequency-interview/mismatch-set/) 。

我们给 `nums` 中所有元素对应的索引做标记，那么最终缺失的那些元素对应的索引就不会被标记，我们也就可以把缺失的那些元素找出来。

> 注意：用乘 -1 的方式给索引做标记的前提是， `nums` 中的元素都为正数，不能包含 0，否则无法区分该索引是否被标记。

#### 解法代码

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表