---
title: "优先级队列经典习题"
source: "https://labuladong.online/zh/algo/problem-set/binary-heap/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有二叉堆结构的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [二叉堆基础](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/)
- [二叉堆实现优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-implement/)

二叉堆的主要应用是优先级队列，而优先级队列的特色是 **动态排序** ，插入的元素可以自动维护正确的顺序。当然， [二叉搜索树](https://labuladong.online/zh/algo/data-structure-basic/tree-map-basic/) 也可以做到动态排序，但优先级队列提供的接口更简单，实现也更简单。

一般来说，用到优先级队列的题目主要分两类，一类是把多个有序序列合并成一个，另一类是在多个有序序列中寻找第 `k` 个最大元素这类题，我们分别来看。

## 类型一，合并有序序列

先来看第一类，类似于合并有序链表这样的题目。

### 23\. 合并 K 个升序链表

**23\. 合并 K 个升序链表** | [力扣](https://leetcode.cn/problems/merge-k-sorted-lists/) | [LeetCode](https://leetcode.com/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

题目来源： [力扣 23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) 。

#### 基本思路

[21\. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/) 的延伸，利用 [优先级队列（二叉堆）](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 进行节点排序即可。

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [分治算法解题套路框架](https://labuladong.online/zh/algo/essential-technique/divide-and-conquer/)
- [双指针技巧秒杀七道链表题目](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/)

### 373\. 查找和最小的 K 对数字

**373\. 查找和最小的 K 对数字** | [力扣](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) | [LeetCode](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

给定两个以 **非递减顺序排列** 的整数数组 `nums1` 和 `nums2`, 以及一个整数 `k` 。

定义一对值 `(u,v)` ，其中第一个元素来自 `nums1` ，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u<sub>1</sub>,v<sub>1</sub>)`, ` (u<sub>2</sub>,v<sub>2</sub>)`... `(u<sub>k</sub>,v<sub>k</sub>)` 。

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**示例 2:**

```
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

**提示:**

- `1 <= nums1.length, nums2.length <= 10<sup>5</sup>`
- `-10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup>`
- `nums1` 和 `nums2` 均为 **升序排列**
- `1 <= k <= 10<sup>4</sup>`
- `k <= nums1.length * nums2.length`

题目来源： [力扣 373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) 。

#### 基本思路

这道题其实是前文 [单链表的六大解题套路](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/) 中讲过的 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/) 的变体。

怎么把这道题变成合并多个有序链表呢？就比如说题目输入的用例：

组合出的所有数对儿这就可以抽象成三个有序链表：

这三个链表中每个元素（数对之和）是递增的，所以就可以按照 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/) 的思路来合并，取出前 `k` 个作为答案即可。

#### 解法代码

#### 算法可视化

算法可视化

### 378\. 有序矩阵中第 K 小的元素

**378\. 有序矩阵中第 K 小的元素** | [力扣](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) | [LeetCode](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。  
请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。

你必须找到一个内存复杂度优于 `O(n<sup>2</sup>)` 的解决方案。

**示例 1：**

```
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
```

**示例 2：**

```
输入：matrix = [[-5]], k = 1
输出：-5
```

**提示：**

- `n == matrix.length`
- `n == matrix[i].length`
- `1 <= n <= 300`
- `-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup>`
- 题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列
- `1 <= k <= n<sup>2</sup>`

**进阶：**

- 你能否用一个恒定的内存(即 `O(1)` 内存复杂度)来解决这个问题?
- 你能在 `O(n)` 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) ）很有趣。

题目来源： [力扣 378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 。

#### 基本思路

这道题其实是前文 [单链表的六大解题套路](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/) 中讲过的 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/) 的变体。

矩阵中的每一行都是排好序的，就好比多条有序链表，你用优先级队列施展合并多条有序链表的逻辑就能找到第 `k` 小的元素了。

#### 解法代码

#### 算法可视化

算法可视化

### 313\. 超级丑数

**313\. 超级丑数** | [力扣](https://leetcode.cn/problems/super-ugly-number/) | [LeetCode](https://leetcode.com/problems/super-ugly-number/)

**超级丑数** 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。

给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 **超级丑数** 。

题目数据保证第 `n` 个 **超级丑数** 在 **32-bit** 带符号整数范围内。

**示例 1：**

```
输入：n = 12, primes = [2,7,13,19]
输出：32 
解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
```

**示例 2：**

```
输入：n = 1, primes = [2,3,5]
输出：1
解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
```

**提示：**

- `1 <= n <= 10<sup>5</sup>`
- `1 <= primes.length <= 100`
- `2 <= primes[i] <= 1000`
- 题目数据 **保证** `primes[i]` 是一个质数
- `primes` 中的所有值都 **互不相同** ，且按 **递增顺序** 排列

题目来源： [力扣 313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/) 。

#### 基本思路

这题是 [264\. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/description/) 的进阶版，第 264 题是 [21\. 合并两个有序链表（简单）](https://leetcode.cn/problems/merge-two-sorted-lists/description/) 的变体，而这道题是 [23\. 合并K个升序链表（困难）](https://leetcode.cn/problems/merge-k-sorted-lists/description/) 的变体，我在 [双指针技巧秒杀七道链表题目](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/) 中都讲过。

你一定要先做下 264 题，注意那里我们抽象出了三条链表，需要 `p2, p3, p5` 作为三条有序链表上的指针，同时需要 `product2, product3, product5` 记录指针所指节点的值，用 `min` 函数计算最小头结点。

这道题相当于输入了 `len(primes)` 条有序链表，我们不能用 `min` 函数计算最小头结点了，而是要用 [优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 来计算最小头结点，同时依然要维护链表指针、指针所指节点的值，我们把这些信息用一个三元组来保存。

结合第 23 题的解法逻辑，你应该能够看懂这道题的解法代码了。

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [一文秒杀所有丑数系列问题](https://labuladong.online/zh/algo/frequency-interview/ugly-number-summary/)

**355\. 设计推特** | [力扣](https://leetcode.cn/problems/design-twitter/) | [LeetCode](https://leetcode.com/problems/design-twitter/)

设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 `10` 条推文。

实现 `Twitter` 类：

- `Twitter()` 初始化简易版推特对象
- `void postTweet(int userId, int tweetId)` 根据给定的 `tweetId` 和 `userId` 创建一条新推文。每次调用此函数都会使用一个不同的 `tweetId` 。
- `List<Integer> getNewsFeed(int userId)` 检索当前用户新闻推送中最近 `10` 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 **按照时间顺序由最近到最远排序** 。
- `void follow(int followerId, int followeeId)` ID 为 `followerId` 的用户开始关注 ID 为 `followeeId` 的用户。
- `void unfollow(int followerId, int followeeId)` ID 为 `followerId` 的用户不再关注 ID 为 `followeeId` 的用户。

**示例：**

```
输入
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
输出
[null, null, [5], null, null, [6, 5], null, [5]]

解释
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)
twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文
twitter.follow(1, 2);    // 用户 1 关注了用户 2
twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)
twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -> [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的
twitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2
twitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2
```

**提示：**

- `1 <= userId, followerId, followeeId <= 500`
- `0 <= tweetId <= 10<sup>4</sup>`
- 所有推特的 ID 都互不相同
- `postTweet` 、 `getNewsFeed` 、 `follow` 和 `unfollow` 方法最多调用 `3 * 10<sup>4</sup>` 次

题目来源： [力扣 355. 设计推特](https://leetcode.cn/problems/design-twitter/) 。

#### 基本思路

这道题比较经典，在特定场景下让你设计算法。其难点在于 `getNewsFeed` 方法，要按照时间线顺序展示所有关注用户的推文，这个方法要用到我在 [单链表的六大解题套路](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/) 解决 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/) 的合并多个有序链表的技巧：

你把一个用户发布的所有推文做成一条有序链表（靠近头部的推文是最近发布的），那么只要合并关注用户的推文链表，即可获得按照时间线顺序排序的信息流。

具体看代码吧，我注释比较详细。

#### 解法代码

#### 算法可视化

## 类型二，寻找第 k 大元素

再来看第二类，寻找第 `k` 个最大元素这类题。

### 215\. 数组中的第K个最大元素

**215\. 数组中的第K个最大元素** | [力扣](https://leetcode.cn/problems/kth-largest-element-in-an-array/) | [LeetCode](https://leetcode.com/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k` ，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 10<sup>5</sup>`
- `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`

题目来源： [力扣 215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/) 。

#### 基本思路

二叉堆的解法比较简单，实际写算法题的时候，推荐大家写这种解法。

可以把小顶堆 `pq` 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 `k` 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 `k` 个最大元素嘛。

当 `nums` 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 `k` 个元素，而堆顶元素是堆中最小的元素，也就是「第 `k` 个最大的元素」。

二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 `k` ，所以插入和删除元素的复杂度是 `O(logK)` ，再套一层 for 循环，总的时间复杂度就是 `O(NlogK)` 。

当然，这道题可以有效率更高的解法叫「快速选择算法」，只需要 `O(N)` 的时间复杂度。

快速选择算法不用借助二叉堆结构，而是稍微改造了快速排序的算法思路，有兴趣的读者可以看详细题解。

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [拓展：快速排序详解及应用](https://labuladong.online/zh/algo/practice-in-action/quick-sort/)

### 451\. 根据字符出现频率排序

**451\. 根据字符出现频率排序** | [力扣](https://leetcode.cn/problems/sort-characters-by-frequency/) | [LeetCode](https://leetcode.com/problems/sort-characters-by-frequency/)

给定一个字符串 `s` ，根据字符出现的 **频率** 对其进行 **降序排序** 。一个字符出现的 **频率** 是它出现在字符串中的次数。

返回 *已排序的字符串* 。如果有多个答案，返回其中任何一个。

**示例 1:**

```
输入: s = "tree"
输出: "eert"
解释: 'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入: s = "cccaaa"
输出: "cccaaa"
解释: 'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入: s = "Aabb"
输出: "bbAa"
解释: 此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

**提示:**

- `1 <= s.length <= 5 * 10<sup>5</sup>`
- `s` 由大小写英文字母和数字组成

题目来源： [力扣 451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/) 。

#### 基本思路

做这道题肯定需要计算每个字符出现的频率，然后你可以用很多种其他方法把字符按照频率排序。我这里用 [优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 来实现排序的效果，详细看代码。

#### 解法代码

#### 算法可视化

算法可视化

### 703\. 数据流中的第 K 大元素

**703\. 数据流中的第 K 大元素** | [力扣](https://leetcode.cn/problems/kth-largest-element-in-a-stream/) | [LeetCode](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。

请实现 `KthLargest` 类：

- `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。
- `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

**示例：**

```
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```
**提示：**
- `1 <= k <= 10<sup>4</sup>`
- `0 <= nums.length <= 10<sup>4</sup>`
- `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
- `-10<sup>4</sup> <= val <= 10<sup>4</sup>`
- 最多调用 `add` 方法 `10<sup>4</sup>` 次
- 题目数据保证，在查找第 `k` 大元素时，数组中至少有 `k` 个元素

题目来源： [力扣 703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/) 。

#### 基本思路

这题考察优先级队列的使用，可以先做下这道类似的题目 [215\. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/) 。

优先级队列的实现原理详见 [图文详解二叉堆，实现优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 。

#### 解法代码

#### 算法可视化

算法可视化

### 347\. 前 K 个高频元素

**347\. 前 K 个高频元素** | [力扣](https://leetcode.cn/problems/top-k-frequent-elements/) | [LeetCode](https://leetcode.com/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：** 你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

题目来源： [力扣 347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) 。

#### 基本思路

首先，肯定要用一个 `valToFreq` 哈希表把每个元素出现的频率计算出来。

然后，这道题就变成了 [215\. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/) ，只不过第 215 题让你求数组中元素值 `e` 排在第 `k` 大的那个元素，这道题让你求数组中元素值 `valToFreq[e]` 排在前 `k` 个的元素。

我在 [快速排序详解及运用](https://labuladong.online/zh/algo/practice-in-action/quick-sort/) 中讲过第 215 题，可以用 [优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 或者快速选择算法解决这道题。这里稍微改一下优先级队列的比较函数，或者改一下快速选择算法中的逻辑即可。

这里我再加一种解法，用计数排序的方式找到前 `k` 个高频元素，见代码。

#### 解法代码

#### 算法可视化

算法可视化

### 692\. 前K个高频单词

**692\. 前K个高频单词** | [力扣](https://leetcode.cn/problems/top-k-frequent-words/) | [LeetCode](https://leetcode.com/problems/top-k-frequent-words/)

给定一个单词列表 `words`  和一个整数 `k` ，返回前  `k` 个出现次数最多的单词。

返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， **按字典顺序** 排序。

**示例 1：**

```
输入: words = ["i", "love", "leetcode", "i", "love", "coding"], k = 2
输出: ["i", "love"]
解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 "i" 在 "love" 之前。
```

**示例 2：**

```
输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
输出: ["the", "is", "sunny", "day"]
解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。
```

**注意：**

- `1 <= words.length <= 500`
- `1 <= words[i] <= 10`
- `words[i]` 由小写英文字母组成。
- `k` 的取值范围是 `[1, **不同** words[i] 的数量]`

**进阶：** 尝试以 `O(n log k)` 时间复杂度和 `O(n)` 空间复杂度解决。

题目来源： [力扣 692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/) 。

#### 基本思路

这道题可以认为是 [347\. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/) 的进阶版。整体思路还哈希表计数，然后用 [优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 维护出现频率最高的 `k` 个单词。

只是我们需要注意题目要求，在 `PriorityQueue` 的比较器中正确处理频率相同的单词的字典序。

#### 解法代码

#### 算法可视化

算法可视化

## 其他运用

最后，再看一看优先级队列的其他运用吧。

### 1845\. 座位预约管理系统

**1845\. 座位预约管理系统** | [力扣](https://leetcode.cn/problems/seat-reservation-manager/) | [LeetCode](https://leetcode.com/problems/seat-reservation-manager/)

请你设计一个管理 `n`  个座位预约的系统，座位编号从  `1`  到  `n` 。

请你实现 `SeatManager` 类：

- `SeatManager(int n)` 初始化一个 `SeatManager`  对象，它管理从 `1`  到 `n`  编号的  `n` 个座位。所有座位初始都是可预约的。
- `int reserve()` 返回可以预约座位的 **最小编号** ，此座位变为不可预约。
- `void unreserve(int seatNumber)` 将给定编号 `seatNumber` 对应的座位变成可以预约。

**示例 1：**

```
输入：
["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
[[5], [], [], [2], [], [], [], [], [5]]
输出：
[null, 1, 2, null, 2, 3, 4, 5, null]

解释：
SeatManager seatManager = new SeatManager(5); // 初始化 SeatManager ，有 5 个座位。
seatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。
seatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。
seatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。
seatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。
seatManager.reserve();    // 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。
seatManager.reserve();    // 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。
seatManager.reserve();    // 唯一可以预约的是座位 5 ，所以返回 5 。
seatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5] 。
```

**提示：**

- `1 <= n <= 10<sup>5</sup>`
- `1 <= seatNumber <= n`
- 每一次对 `reserve` 的调用，题目保证至少存在一个可以预约的座位。
- 每一次对 `unreserve`  的调用，题目保证  `seatNumber` 在调用函数前都是被预约状态。
- 对 `reserve` 和  `unreserve` 的调用 **总共** 不超过 `10<sup>5</sup>` 次。

题目来源： [力扣 1845. 座位预约管理系统](https://leetcode.cn/problems/seat-reservation-manager/) 。

#### 基本思路

这题是 [379\. 电话目录管理系统](https://leetcode.cn/problems/design-phone-directory/description/) 的进阶版，那一道题返回的空闲号码可以随意，而这道题要求返回 **最小** 的座位编号。

其实很思路是一样的，只是这里需要用到能够按照元素大小自动排序的数据结构 [优先级队列（二叉堆）](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) ，直接看代码吧。

#### 解法代码

#### 算法可视化

算法可视化

### 295\. 数据流的中位数

**295\. 数据流的中位数** | [力扣](https://leetcode.cn/problems/find-median-from-data-stream/) | [LeetCode](https://leetcode.com/problems/find-median-from-data-stream/)

**中位数** 是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() ` 初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10<sup>-5</sup>` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**提示:**

- `-10<sup>5</sup> <= num <= 10<sup>5</sup>`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 10<sup>4</sup>`  次调用  `addNum`  和  `findMedian`

题目来源： [力扣 295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) 。

#### 基本思路

本题的核心思路是使用两个 [优先级队列](https://labuladong.online/zh/algo/data-structure-basic/binary-heap-basic/) 。

![](https://labuladong.online/images/algo/median/1.jpeg)

小的倒三角就是个大顶堆，梯形就是个小顶堆，中位数可以通过它们的堆顶元素算出来：

![](https://labuladong.online/images/algo/median/2.jpeg)

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [拓展：两个二叉堆实现中位数算法](https://labuladong.online/zh/algo/practice-in-action/find-median-from-data-stream/)

### 870\. 优势洗牌

**870\. 优势洗牌** | [力扣](https://leetcode.cn/problems/advantage-shuffle/) | [LeetCode](https://leetcode.com/problems/advantage-shuffle/)

给定两个长度相等的数组 `nums1`  和  `nums2` ， `nums1`  相对于 `nums2` 的 *优势* 可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述。

返回 nums1 的 **任意** 排列，使其相对于 `nums2` 的优势最大化。

**示例 1：**

```
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]
```

**示例 2：**

```
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]
```

**提示：**

- `1 <= nums1.length <= 10<sup>5</sup>`
- `nums2.length == nums1.length`
- `0 <= nums1[i], nums2[i] <= 10<sup>9</sup>`

题目来源： [力扣 870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/) 。

#### 基本思路

这题就像田忌赛马的情景， `nums1` 就是田忌的马， `nums2` 就是齐王的马，数组中的元素就是马的战斗力，你就是谋士孙膑，请你帮田忌安排赛马顺序，使胜场最多。

最优策略是将齐王和田忌的马按照战斗力排序，然后按照战斗力排名一一对比：

如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。

具体分析见详细题解。

#### 解法代码

#### 算法可视化

算法可视化

**详细题解**:

- [田忌赛马背后的算法决策](https://labuladong.online/zh/algo/practice-in-action/advantage-shuffle/)

### 1834\. 单线程 CPU

给你一个二维数组 `tasks` ，用于表示 `n` 项从 `0` 到 `n - 1` 编号的任务。其中 `tasks[i] = [enqueueTime<sub>i</sub>, processingTime<sub>i</sub>]` 意味着第 `i<sup>​​​​​​</sup>` 项任务将会于 `enqueueTime<sub>i</sub>` 时进入任务队列，需要 `processingTime<sub>i</sub>` 的时长完成执行。

现有一个单线程 CPU ，同一时间只能执行 **最多一项** 任务，该 CPU 将会按照下述方式运行：

- 如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
- 如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 **执行时间最短** 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
- 一旦某项任务开始执行，CPU 在 **执行完整个任务** 前都不会停止。
- CPU 可以在完成一项任务后，立即开始执行一项新任务。

返回CPU处理任务的顺序。

**示例 1：**

```
输入：tasks = [[1,2],[2,4],[3,2],[4,1]]
输出：[0,2,3,1]
解释：事件按下述流程运行： 
- time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}
- 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}
- time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}
- time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}
- 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}
- time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}
- time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}
- time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}
- time = 10 ，CPU 完成任务 1 并进入空闲状态
```

**示例 2：**

```
输入：tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
输出：[4,3,2,0,1]
解释：事件按下述流程运行： 
- time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}
- 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}
- time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}
- time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}
- time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}
- time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}
- time = 40 ，CPU 完成任务 1 并进入空闲状态
```

**提示：**

- `tasks.length == n`
- `1 <= n <= 10<sup>5</sup>`
- `1 <= enqueueTime<sub>i</sub>, processingTime<sub>i</sub> <= 10<sup>9</sup>`

题目来源： [力扣 1834. 单线程 CPU](https://leetcode.cn/problems/single-threaded-cpu/) 。

#### 基本思路

这题的难度不算大，就是有些复杂， **难点在于你要同时控制三个变量（开始时间、处理时间、索引）的有序性，而且这三个变量还有优先级** ：

首先应该考虑开始时间，因为只要到了开始时间，任务才进入可执行状态；

其次应该考虑任务的处理时间，在所有可以执行的任务中优先选择处理时间最短的；

如果存在处理时间相同的任务，那么优先选择索引最小的。

所以这道题的思路是：

**先根据任务「开始时间」排序，维护一个时间线变量 `now` 来判断哪些任务到了可执行状态，然后借助一个优先级队列 `pq` 对「处理时间」和「索引」进行动态排序** 。

利用优先级队列动态排序是有必要的，因为每完成一个任务，时间线 `now` 就要更新，进而产生新的可执行任务。

#### 解法代码

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表