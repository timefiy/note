---
title: "欧拉路径经典习题"
source: "https://labuladong.online/zh/algo/problem-set/eulerian-path/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有欧拉路径算法的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [欧拉路径和一笔画游戏](https://labuladong.online/zh/algo/data-structure-basic/eulerian-graph/)
- [Hierholzer 算法寻找欧拉路径](https://labuladong.online/zh/algo/data-structure/eulerian-graph-hierholzer/)

欧拉路径相关的算法在力扣上都是 Hard 级别的题目，其难点主要在于如何把题目转化为求解欧拉路径的场景。

下面我们来看一些经典且有趣的题目。

## 332\. 重新安排行程

**332\. 重新安排行程** | [力扣](https://leetcode.cn/problems/reconstruct-itinerary/) | [LeetCode](https://leetcode.com/problems/reconstruct-itinerary/)

给你一份航线列表 `tickets` ，其中 `tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK` （肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2021/03/14/itinerary1-graph.jpg)
```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

**示例 2：**

![](https://labuladong.online/images/lc/uploads/2021/03/14/itinerary2-graph.jpg)
```
输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
```

**提示：**

- `1 <= tickets.length <= 300`
- `tickets[i].length == 2`
- `from<sub>i</sub>.length == 3`
- `to<sub>i</sub>.length == 3`
- `from<sub>i</sub>` 和 `to<sub>i</sub>` 由大写英文字母组成
- `from<sub>i</sub> != to<sub>i</sub>`

题目来源： [力扣 332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/) 。

这道题可以按照 [回溯算法框架](https://labuladong.online/zh/algo/essential-technique/backtrack-framework/) 写一个回溯算法暴力穷举所有路径，找到符合条件的行程。参考代码如下：

```
class Solution {

    // 邻接表形式的图，key 是机场名字，value 是从该机场出发能够到达的机场列表

    unordered_map<string, vector<string>> graph;

    // 和 graph 对应，记录每张机票是否被使用过

    // 比如 graph["JFK"][2] = true 说明从机场 JFK 出发的第 3 张机票已经用过了

    unordered_map<string, vector<bool>> used;

    vector<vector<string>> tickets;

    // 回溯算法使用的数据结构

    vector<string> track;

    // 回溯算法记录结果

    vector<string> res;

public:

    vector<string> findItinerary(vector<vector<string>>& tickets) {

        this->tickets = tickets;

        // 1. 用机场的名字构建邻接表

        for (const auto& ticket : tickets) {

            const string& from = ticket[0];

            const string& to = ticket[1];

            if (!graph.count(from)) {

                graph[from] = vector<string>();

            }

            graph[from].push_back(to);

        }

        // 2. 对邻接表的每一行进行排序，保证字典序最小

        for (auto& [from, toList] : graph) {

            sort(toList.begin(), toList.end());

        }

        // 3. 初始化 used 结构，初始值都为 false

        for (const auto& [from, toList] : graph) {

            used[from] = vector<bool>(toList.size(), false);

        }

        // 4. 从起点 "JFK" 开始启动 DFS 算法递归遍历

        track.push_back("JFK");

        backtrack("JFK");

        return res;

    }

    void backtrack(const string& airport) {

        if (!res.empty()) {

            // 已经找到答案了，不用再计算了

            return;

        }

        if (track.size() == tickets.size() + 1) {

            // track 里面包含了所有的机票，即得到了一个合法的结果

            // 注意 tickets.size() 要加一，因为 track 里面额外包含了起点 "JFK"

            res = track;

            return;

        }

        if (!graph.count(airport)) {

            // 没有从 s 出发的边

            return;

        }

        // 遍历当前机场所有能够到达的机场

        const auto& nextAirports = graph[airport];

        for (int nextIndex = 0; nextIndex < nextAirports.size(); ++nextIndex) {

            const string& nextAirport = nextAirports[nextIndex];

            if (used[airport][nextIndex]) {

                // 如果这张机票被使用过，跳过

                continue;

            }

            // 做选择

            used[airport][nextIndex] = true;

            track.push_back(nextAirport);

            // 递归

            backtrack(nextAirport);

            // 撤销选择

            used[airport][nextIndex] = false;

            track.pop_back();

        }

    }

};
```

不过后来力扣似乎增加了一些测试用例，导致回溯算法超时了。

所以，这道题应该是想考察寻找 [欧拉路径](https://labuladong.online/zh/algo/data-structure-basic/eulerian-graph/) 。 [Hierholzer 算法寻找欧拉路径](https://labuladong.online/zh/algo/data-structure/eulerian-graph-hierholzer/) 详细讲解了 Hierholzer 算法的原理和代码，这里直接套用即可。

需要注意的是，题目已经保证必然存在以 "JFK" 为起点的欧拉路径，所以不需要分析节点的度数寻找欧拉路径的起点；另外，题目要求返回字典序最小的行程，所以需要对邻接表中的每一个列表进行排序，确保 DFS 算法先遍历字典序最小的节点，最终得到的欧拉路径就是字典序最小的。

```
class Solution {

public:

    vector<string> findItinerary(vector<vector<string>>& tickets) {

        // 构建邻接表

        unordered_map<string, vector<string>> graph;

        for (const auto& ticket : tickets) {

            graph[ticket[0]].push_back(ticket[1]);

        }

        // 对每个出发点的目的地进行排序，确保字典序

        for (auto& [from, dests] : graph) {

            sort(dests.begin(), dests.end());

        }

        // Hierholzer 算法寻找以 JFK 为起点的欧拉路径

        // 计算以 JFK 为起点的后序遍历结果

        vector<string> postOrder;

        traverse(graph, "JFK", postOrder);

        // 反转后序遍历结果，得到欧拉路径

        reverse(postOrder.begin(), postOrder.end());

        return postOrder;

    }

private:

    void traverse(unordered_map<string, vector<string>>& graph, const string& node, vector<string>& postOrder) {

        if (!graph.count(node)) {

            postOrder.push_back(node);

            return;

        }

        // 复制节点列表，避免在遍历过程中修改原列表

        while (!graph[node].empty()) {

            string v = graph[node][0];

            graph[node].erase(graph[node].begin());

            traverse(graph, v, postOrder);

        }

        // 获取后序遍历结果

        postOrder.push_back(node);

    }

};
```

## 2097\. 合法重新排列数对

**2097\. 合法重新排列数对** | [力扣](https://leetcode.cn/problems/valid-arrangement-of-pairs/) | [LeetCode](https://leetcode.com/problems/valid-arrangement-of-pairs/)

给你一个下标从 **0**  开始的二维整数数组  `pairs`  ，其中  `pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。如果 `pairs`  的一个重新排列，满足对每一个下标 `i` （  `1 <= i < pairs.length`  ）都有  `end<sub>i-1</sub> == start<sub>i</sub>` ，那么我们就认为这个重新排列是 `pairs` 的一个 **合法重新排列** 。

请你返回 **任意一个** `pairs` 的合法重新排列。

**注意：** 数据保证至少存在一个 `pairs` 的合法重新排列。

**示例 1：**

```
输入：pairs = [[5,1],[4,5],[11,9],[9,4]]
输出：[[11,9],[9,4],[4,5],[5,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3
```

**示例 2：**

```
输入：pairs = [[1,3],[3,2],[2,1]]
输出：[[1,3],[3,2],[2,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 3 == 3 = start1
end1 = 2 == 2 = start2
重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。
```

**示例 3：**

```
输入：pairs = [[1,2],[1,3],[2,1]]
输出：[[1,2],[2,1],[1,3]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 2 == 2 = start1
end1 = 1 == 1 = start2
```

**提示：**

- `1 <= pairs.length <= 10<sup>5</sup>`
- `pairs[i].length == 2`
- `0 <= start<sub>i</sub>, end<sub>i</sub> <= 10<sup>9</sup>`
- `start<sub>i</sub> != end<sub>i</sub>`
- `pairs` 中不存在一模一样的数对。
- 至少 **存在** 一个合法的 `pairs` 重新排列。

题目来源： [力扣 2097. 合法重新排列数对](https://leetcode.cn/problems/valid-arrangement-of-pairs/) 。

这道题属于 [Hierholzer 算法寻找欧拉路径](https://labuladong.online/zh/algo/data-structure/eulerian-graph-hierholzer/) 的模板题，直接套用模板即可。

`pairs` 数组中每个数对 `[a, b]` 表示一条 `a->b` 的有向边，题目其实是要我们在图中找到一条欧拉路径。

最后找到的这条欧拉路径中，每两个相邻的节点组成一个数对，就得到了题目想要的答案。

比如说欧拉路径为 `0->1->2->3->1` ，那么题目想要的答案就是 `[[0, 1], [1, 2], [2, 3], [3, 1]]` 。

具体请看解法代码的注释。

```
class Solution {

public:

    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {

        // 建图

        unordered_map<int, vector<int>> graph;

        unordered_map<int, int> inDegree, outDegree;

        for (const auto& pair : pairs) {

            int from = pair[0], to = pair[1];

            graph[from].push_back(to);

            inDegree[to]++;

            outDegree[from]++;

        }

        // 找起点，题目说了必然存在一个起点

        // 所以我们只需要寻找出度比入度大 1 的节点作为起点

        // 如果没有出度比入度大 1 的节点，说明存在欧拉回路

        // 任选一个节点作为起点就可以

        int start = pairs[0][0];

        for (const auto& kv : graph) {

            int node = kv.first;

            if (outDegree[node] - inDegree[node] == 1) {

                start = node;

                break;

            }

        }

        // 从起点开始 DFS 遍历，计算后序遍历结果

        vector<int> postOrder;

        traverse(graph, start, postOrder);

        // 反转后序遍历结果，得到欧拉路径

        reverse(postOrder.begin(), postOrder.end());

        // 将后序遍历结果转换为结果数组

        vector<vector<int>> result;

        for (int i = 0; i < pairs.size(); ++i) {

            result.push_back({postOrder[i], postOrder[i + 1]});

        }

        return result;

    }

private:

    void traverse(unordered_map<int, vector<int>>& graph, int node, vector<int>& postOrder) {

        while (graph.count(node) && !graph[node].empty()) {

            // 弹出最后一个元素，因为数组删除最后元素的复杂度是 O(1)

            int lastIndex = graph[node].size() - 1;

            int to = graph[node][lastIndex];

            graph[node].pop_back();

            traverse(graph, to, postOrder);

        }

        postOrder.push_back(node);

    }

};
```

## 753\. 破解保险箱

**753\. 破解保险箱** | [力扣](https://leetcode.cn/problems/cracking-the-safe/) | [LeetCode](https://leetcode.com/problems/cracking-the-safe/)

有一个需要密码才能打开的保险箱。密码是 `n` 位数, 密码的每一位都是范围 `[0, k - 1]` 中的一个数字。

保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 **最后 `n` 位输入** ，如果匹配，则能够打开保险箱。

- 例如，正确的密码是 `"345"` ，并且你输入的是 `"012345"` ：
	- 输入 `0` 之后，最后 `3` 位输入是 `"0"` ，不正确。
	- 输入 `1` 之后，最后 `3` 位输入是 `"01"` ，不正确。
	- 输入 `2` 之后，最后 `3` 位输入是 `"012"` ，不正确。
	- 输入 `3` 之后，最后 `3` 位输入是 `"123"` ，不正确。
	- 输入 `4` 之后，最后 `3` 位输入是 `"234"` ，不正确。
	- 输入 `5` 之后，最后 `3` 位输入是 `"345"` ，正确，打开保险箱。

在只知道密码位数 `n` 和范围边界 `k` 的前提下，请你找出并返回确保在输入的 **某个时刻** 能够打开保险箱的任一 **最短** 密码序列 。

**示例 1：**

```
输入：n = 1, k = 2
输出："10"
解释：密码只有 1 位，所以输入每一位就可以。"01" 也能够确保打开保险箱。
```

**示例 2：**

```
输入：n = 2, k = 2
输出："01100"
解释：对于每种可能的密码：
- "00" 从第 4 位开始输入。
- "01" 从第 1 位开始输入。
- "10" 从第 3 位开始输入。
- "11" 从第 2 位开始输入。
因此 "01100" 可以确保打开保险箱。"01100"、"10011" 和 "11001" 也可以确保打开保险箱。
```

**提示：**

- `1 <= n <= 4`
- `1 <= k <= 10`
- `1 <= k<sup>n</sup> <= 4096`

题目来源： [力扣 753. 破解保险箱](https://leetcode.cn/problems/cracking-the-safe/) 。

首先要确保你理解了题目，比如说 `n = 2, k = 3` 的例子，所有可能的密码有 $3^2=9$ 种（全排列），分别是 `00, 01, 02, 10, 11, 12, 20, 21, 22` 。

那么如果我把这 9 个排列直接链接成一个字符串，就得到了 `000102101112202122` ，长度为 $2 \times 9 = 18$ 。

如果把这个字符串输入给密码箱，必然能够打开密码箱，因为其中已经包含了所有可能的密码。

不过题目要求我们找到一个最短的密码破解序列，而这个字符串并不是最短的。比方说 `0221120100` 应该是最优解，你看这个字符串中包含了 9 种密码，且长度仅为 10，小于 18。

所以这个题目不是一个简单的排列组合问题，需要更巧妙的解法。

这类「包含所有全排列的最短序列」是经典的欧拉路径问题，没有了解过这类问题的话，几乎没办法想到如何把这个题抽象成寻找欧拉回路的场景。所以我直接说解法，大家把这个破解密码的场景记下来即可。

让我们考虑 `n=3, k=2` 的例子，所有可能的密码有 $2^3=8$ 种，分别是：

```
000 001

010 011

100 101

110 111
```

我们现在想计算一个最短的字符串 `t` ，使得 `t` 中包含上面所有 8 个密码，且 `t` 的长度尽可能小。

首先，列出 `n=2, k=2` 的 $2^2=4$ 种全排列：

```
00 01

10 11
```

把这 4 个排列视为一幅有向图中的 4 个节点：

给这幅图添加若干有向边，就可以推导出 `n=3, k=2` 的最短密码序列了。

我们可以认为每个节点都有 `k` 条出边指向其他节点（也可以指向自己），每一条边都代表着一位新的密码。

比方说节点 `00` 有 2 条出边，分别代表着 `0, 1` 两位数字，也就是说从 `00` 出发，可以生成 `000, 001` 两个新密码。

但是我们的图结构中每个节点都只有两位，并不存在 `000, 001` 这两个节点，应该如何添加 `00->000, 00->001` 这两条边呢？

很简单，我们仅看后缀，也就是说把 `00` 节点连接到 `00, 01` 这两个节点，即添加 `00->00, 00->01` 这两条边。

其他节点同理， `01` 节点连接到 `10, 11` 这两个节点， `10` 节点连接到 `00, 01` 这两个节点， `11` 节点连接到 `10, 11` 这两个节点。

到这里，有向图图结构就建好了：

对于这幅有向图，每个节点都有 `k=2` 条出边，同时也有 `k=2` 条入边，所以这是一幅欧拉图，存在 [欧拉回路](https://labuladong.online/zh/algo/data-structure-basic/eulerian-graph/) ，能够从任意一个节点出发，遍历所有边恰好一次，最终回到起点。

**而这条欧拉回路，就可以推导出我们想要的密码破解序列** 。

比方说一个正确的最短序列是 `t = "0011101000"` ，体现在图中就是以 `00` 作为起点的欧拉回路，推导过程如下。

首先，我们以 `00` 节点作为欧拉路径的起点，初始化 `t = "00"` 。

节点 `00` 经过边 `1` 到达节点 `01` ，此时 `t = "001"` 。

节点 `01` 经过边 `1` 到达节点 `11` ，此时 `t = "0011"` 。

节点 `11` 经过边 `1` 到达节点 `11` ，此时 `t = "00111"` 。

节点 `11` 经过边 `0` 到达节点 `10` ，此时 `t = "001110"` 。

节点 `10` 经过边 `1` 到达节点 `01` ，此时 `t = "0011101"` 。

节点 `01` 经过边 `0` 到达节点 `10` ，此时 `t = "00111010"` 。

节点 `10` 经过边 `0` 到达节点 `00` ，此时 `t = "001110100"` 。

节点 `00` 经过边 `0` 到达节点 `00` ，此时 `t = "0011101000"` 。

这就是一条欧拉回路，我们从 `00` 节点出发，遍历了图中的所有边，最终回到了 `00` 节点，同时得到了密码破解序列 `t = "0011101000"` 。

上述过程就是这道题的核心思路，直接翻译成代码，应该就可以完成这道题。

首先用回溯算法计算出 $k^{n-1}$ 个全排列作为节点构建图结构，然后任选一个节点作为起点，执行 [Hierholzer 算法](https://labuladong.online/zh/algo/data-structure/eulerian-graph-hierholzer/) 计算欧拉回路，最后拼接出最终答案。

题目给的取值范围 $k^n<= 4096$ ，并不算大，所以回溯算法计算全排列也不会很耗时。

但其实有更简单的办法，不需要计算全排列，甚至都不需要用邻接表/邻接矩阵构建图结构，就能完成这道题。

注意观察可以发现以下规律：

1、除了起点，我们并没有用到其他节点的值，主要是通过边上的值拼接出最终答案的。

2、每个节点必然有 `k` 条出边，边上的值是 `0, 1, 2, ..., k-1` 。

3、题目说 $1 <= k <= 10$ ，所以可以通过当前节点的值和边的值推导出下一个节点，即 `(当前节点值 * 10 + 边值) % 10^{n-1}` 。

比方说 `10` 节点经过边 `1` 到达 `01` 节点，即 `(10 * 10 + 1) % 10^2 = 1` 。

综上，我们不需要使用邻接表/邻接矩阵存储图结构，具体看代码吧。

```
class Solution {

    // 记录哪些边被访问过，其中的元素类似 "0->10", "11->1" 这种形式

    HashSet<String> visited = new HashSet<>();

    // 记录后序遍历结果

    List<Integer> postOrder = new ArrayList<>();

    // 计算获取个位数的求余基数

    int base;

    public String crackSafe(int n, int k) {

        if (n == 1) {

            // 如果 n=1，则直接返回 0,1,2,...,k-1 的拼接

            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < k; i++) {

                sb.append(i);

            }

            return sb.toString();

        }

        base = (int) Math.pow(10, n - 1);

        // 图中必然存在欧拉回路

        // 所以可以从任意节点开始 Hierholzer 算法

        traverse(0, k);

        // 把后序遍历结果反转，即可得到欧拉回路

        Collections.reverse(postOrder);

        // 欧拉回路经过的边可以拼接出答案

        StringBuilder sb = new StringBuilder();

        // 开头是起点的值，即长度为 n-1 的 0

        sb.append("0".repeat(n - 1));

        // 从起点开始拼接每条边的值

        for (int i = 0; i < postOrder.size() - 1; i++) {

            int nextNode = postOrder.get(i + 1);

            // nextNode 的个位数的值就是边的值

            sb.append(nextNode % 10);

        }

        return sb.toString();

    }

    void traverse(int node, int k) {

        for (int i = 0; i < k; i++) {

            int nextNode = (node * 10 + i) % base;

            // 由于未使用邻接表，不能直接删边

            // 所以借助 visited 记录已访问边

            String edge = node + "->" + nextNode;

            if (!visited.contains(edge)) {

                visited.add(edge);

                traverse(nextNode, k);

            }

        }

        // 记录后序遍历结果

        postOrder.add(node);

    }

}
```

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表