---
title: "拓扑排序算法"
source: "https://labuladong.online/zh/algo/data-structure/topological-sort/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文讲解拓扑排序算法，用 DFS 的逆后序遍历和 BFS 的入度数组两种方式实现拓扑排序，结合力扣第 210 题「课程表 II」给出 Java/Python/Go/JavaScript/C++ 代码实现。"
tags:
  - "clippings"
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [210\. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) | [210\. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) |  |

前置知识

阅读本文前，你需要先学习：

- [图结构的 DFS/BFS 遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-traverse-basic/)
- [有向图的环检测算法](https://labuladong.online/zh/algo/data-structure/cycle-detection/)

一句话总结

图的 DFS 逆后序遍历顺序，或者 BFS 的入度数组遍历顺序，就是拓扑排序的结果。

拓扑排序是图论中另一个非常经典的算法。进行拓扑排序之前，先要确保图中没有环，关于环检测可以参考前文 [有向图的环检测算法](https://labuladong.online/zh/algo/data-structure/cycle-detection/) 。

**本文就结合具体的算法题，分别用 DFS 和 BFS 两种思路来实现拓扑排序算法** 。

相对而言 BFS 解法从代码实现上看更简洁一些，但 DFS 解法有助于你进一步理解递归遍历数据结构的奥义，所以本文中我先讲 DFS 遍历的思路，再讲 BFS 遍历的思路。

## 拓扑排序算法（DFS 版本）

看下力扣第 210 题「 [课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 」：

现在你总共有 `numCourses` 门课需要选，记为  `0`  到  `numCourses - 1` 。给你一个数组  `prerequisites` ，其中 `prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]` ，表示在选修课程 `a<sub>i</sub>` 前 **必须** 先选修 `b<sub>i</sub>` 。

- 例如，想要学习课程 `0` ，你需要先完成课程  `1` ，我们用一个匹配来表示： `[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2：**

```
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**示例 3：**

```
输入：numCourses = 1, prerequisites = []
输出：[0]
```
**提示：**
- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
- `prerequisites[i].length == 2`
- `0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses`
- `a<sub>i</sub> != b<sub>i</sub>`
- 所有 `[a<sub>i</sub>, b<sub>i</sub>]` **互不相同**

题目来源： [力扣 210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 。

这道题就是前文 [环检测算法](https://labuladong.online/zh/algo/data-structure/cycle-detection/) 中那道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。

函数签名如下：

```
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites);
```

这里我先说一下拓扑排序（Topological Sorting）这个名词，网上搜出来的定义很数学，这里干脆用百度百科的一幅图来让你直观地感受下：

![](https://labuladong.online/images/algo/topological-sort/top.jpg)

**直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的** ，比如上图所有箭头都是朝右的。

很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。

但是我们这道题和拓扑排序有什么关系呢？

**其实也不难看出来，如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序** 。

首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用前文 [环检测算法](https://labuladong.online/zh/algo/data-structure/cycle-detection/) 中的逻辑：

```
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {

    if (!canFinish(numCourses, prerequisites)) {

        // 不可能完成所有课程

        return vector<int>();

    }

    // ...

}
```

那么关键问题来了，如何进行拓扑排序？是不是又要秀什么高大上的技巧了？

**其实特别简单，把图结构后序遍历的结果进行反转，就是拓扑排序的结果** 。

需要反转吗？

有的读者提到，他在网上看到的拓扑排序算法就是后序遍历结果，不用对后序遍历结果进行反转，这是为什么呢？

你确实可以看到这样的解法，原因是他建图的时候对边的定义和我不同。我建的图中箭头方向是「被依赖」关系，比如节点 `1` 指向 `2` ，含义是节点 `1` 被节点 `2` 依赖，即做完 `1` 才能去做 `2` ，因为这样更符合我们的直觉。

如果你反过来，把有向边定义为「依赖」关系，那么整幅图中边全部反转，就可以不对后序遍历结果反转。具体来说，就是把我的解法代码中 `graph[from].add(to);` 改成 `graph[to].add(from);` 就可以不反转了。

直接看解法代码吧，在环检测的代码基础上添加了记录后序遍历结果的逻辑：

```
class Solution {

public:

    // 记录后序遍历结果

    vector<int> postorder;

    // 记录是否存在环

    bool hasCycle = false;

    vector<bool> visited, onPath;

    // 主函数

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {

        vector<int>* graph = buildGraph(numCourses, prerequisites);

        visited = vector<bool>(numCourses);

        onPath = vector<bool>(numCourses);

        // 遍历图

        for (int i = 0; i < numCourses; i++) {

            traverse(graph, i);

        }

        // 有环图无法进行拓扑排序

        if (hasCycle) {

            return vector<int>();

        }

        // 逆后序遍历结果即为拓扑排序结果

        reverse(postorder.begin(), postorder.end());

        return postorder;

    }

    // 图遍历函数

    void traverse(vector<int>* graph, int s) {

        if (onPath[s]) {

            // 发现环

            hasCycle = true;

        }

        if (visited[s] || hasCycle) {

            return;

        }

        // 前序遍历位置

        onPath[s] = true;

        visited[s] = true;

        for (int t : graph[s]) {

            traverse(graph, t);

        }

        // 后序遍历位置

        postorder.push_back(s);

        onPath[s] = false;

    }

    // 建图函数

    vector<int> buildGraph(int numCourses, vector<vector<int>>& prerequisites) {

        // 代码见前文

    }

};
```

`visited` 为 true 的节点为绿色， `onPath` 为 true 的节点为橙色。

你可以打开可视化面板，多次点击 `if (onPath[s])` 这部分代码，即可查看 DFS 遍历图的过程。

算法可视化

代码虽然看起来多，但是逻辑应该是很清楚的，只要图中无环，那么我们就调用 `traverse` 函数对图进行 DFS 遍历，记录后序遍历结果，最后把后序遍历结果反转，作为最终的答案。

**那么为什么后序遍历的反转结果就是拓扑排序呢** ？

我这里也避免数学证明，用一个直观地例子来解释，我们就说二叉树，这是我们说过很多次的二叉树遍历框架：

```
void traverse(TreeNode* root) {

    // 前序遍历代码位置

    traverse(root->left);

    // 中序遍历代码位置

    traverse(root->right);

    // 后序遍历代码位置

}
```

二叉树的后序遍历是什么时候？遍历完左右子树之后才会执行后序遍历位置的代码。换句话说，当左右子树的节点都被装到结果列表里面了，根节点才会被装进去。

**后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行** 。

你把二叉树理解成一幅有向图，边的方向是由父节点指向子节点，那么就是下图这样：

![](https://labuladong.online/images/algo/topological-sort/2.jpeg)

对于标准的后序遍历结果，根节点出现在最后，只要把遍历结果反过来，就是拓扑排序结果：

![](https://labuladong.online/images/algo/topological-sort/3.jpeg)

我知道有读者会问，后序遍历结果反转，和前序遍历结果有什么关系？

对于二叉树来说你看起来好像有关系，实际上二者没有任何关系。你千万不要认为后序遍历反转的结果等同于前序遍历结果。

它俩的关键区别在 [二叉树思想（纲领篇）](https://labuladong.online/zh/algo/essential-technique/binary-tree-summary/) 已经讲过了，后序位置的代码是等到左右子树都遍历完才执行的，只有它才能体现出「依赖」关系，其他遍历顺序都做不到。

## 拓扑排序算法（BFS 版本）

请你务必理解 [环检测算法](https://labuladong.online/zh/algo/data-structure/cycle-detection/) 中讲解的 BFS 算法借助 `indegree` 入度数组来判断有向图是否成环的算法。

**只要你能看懂 BFS 版本的环检测算法，那么 BFS 版本的拓扑排序算法就很容易理解了，因为节点的遍历顺序就是拓扑排序的结果** 。

比如环检测中举的那个例子，下图每个节点中的值即入队的顺序：

![](https://labuladong.online/images/algo/topological-sort/13.jpeg)

显然，这个顺序就是一个可行的拓扑排序结果。

所以，我们稍微修改一下 BFS 版本的环检测算法，记录节点的遍历顺序，就可以得到拓扑排序的结果：

```
class Solution {

public:

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {

        // 建图，和环检测算法相同

        vector<vector<int>> graph = buildGraph(numCourses, prerequisites);

        // 计算入度，和环检测算法相同

        vector<int> indegree(numCourses);

        

        for (vector<int> edge : prerequisites) {

            int from = edge[1], to = edge[0];

            indegree[to]++;

        }

        // 根据入度初始化队列中的节点，和环检测算法相同

        queue<int> q;

        

        for (int i = 0; i < numCourses; i++) {

            if (indegree[i] == 0) {

                q.push(i);

            }

        }

        // 记录拓扑排序结果

        vector<int> res(numCourses);

        

        // 记录遍历节点的顺序（索引）

        int count = 0;

        

        // 开始执行 BFS 算法

        while (!q.empty()) {

            int cur = q.front();

            q.pop();

            

            // 弹出节点的顺序即为拓扑排序结果

            res[count] = cur;

            count++;

            

            for (int next : graph[cur]) {

                indegree[next]--;

                if (indegree[next] == 0) {

                    q.push(next);

                }

            }

        }

        if (count != numCourses) {

            // 存在环，拓扑排序不存在

            return {};

        }

        

        return res;

    }

private:

    vector<vector<int>> buildGraph(int n, vector<vector<int>>& edges) {

        // 见前文

    }

};
```

按道理， [图的遍历](https://labuladong.online/zh/algo/data-structure-basic/graph-basic/) 都需要 `visited` 数组防止走回头路，这里的 BFS 算法其实是通过 `indegree` 数组实现的 `visited` 数组的作用，只有入度为 0 的节点才能入队，从而保证不会出现死循环。

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表