---
title: "优化：实现动态线段树"
source: "https://labuladong.online/zh/algo/data-structure/segment-tree-dynamic/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "滑动窗口是一种快慢指针技巧，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组。本文介绍滑动窗口算法核心框架，总结了力扣/LeetCode 上所有滑动窗口问题的通用解题思路和代码模板。"
tags:
  - "clippings"
---
读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：

| LeetCode | 力扣 | 难度 |
| --- | --- | --- |
| [307\. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) | [307\. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) |  |

前置知识

阅读本文前，你需要先学习：

- [线段树基本实现](https://labuladong.online/zh/algo/data-structure/segment-tree-implement/)

[线段树基本实现](https://labuladong.online/zh/algo/data-structure/segment-tree-implement/) 中用数组和链表分别实现了线段树，文末留了两个优化点，分别是区间更新问题和稀疏数据的内存优化问题。

本文将实现一个动态线段树 `DynamicSegmentTree` ，利用「动态开点技术」，优化稀疏数据的内存占用问题。

这个实现的区别是，不需要你在一开始就输入一个数组，只需要输入线段树的区间范围，并给定一个默认值。

比方说你输入区间范围为 `[0, 1000000]` ，默认值为 `0` ，就相当于输入了一个大小为 `1000001` 的数组，其中每个元素的值都是 `0` 。

`DynamicSegmentTree` 并不会在初始化的时候真的开辟这么大的内存空间来存储 `1000001` 个节点，而是在更新元素的时候，根据需要动态地创建节点，这就是所谓的「动态开点」。

这种动态线段树用链式结构比较容易实现，所以我们可以基于 [线段树基本实现](https://labuladong.online/zh/algo/data-structure/segment-tree-implement/) 中的 `LinkedSegmentTree` 来实现动态线段树。

下面高亮显示了需要修改的代码部分，主要就是在 `update` 逻辑中额外调用一次 `initChildrenIfNeeded` 方法，用于在需要的时候动态地创建子节点，其他的代码都可以保持不变：

```
#include <functional>

#include <stdexcept>

// 线段树节点

class SegmentNode {

public:

    int l, r;

    int mergeVal;

    SegmentNode* left;

    SegmentNode* right;

    // 构造函数

    SegmentNode(int l, int r, int mergeVal)

        : l(l), r(r), mergeVal(mergeVal), left(nullptr), right(nullptr) {}

};

class DynamicSegmentTree {

private:

    SegmentNode* root;

    std::function<int(int, int)> merger;

    int defaultValue;

    // 检查当前节点是否需要创建子节点

    void initChildrenIfNeeded(SegmentNode* node) { // [!code ++:15]

        if (node->l == node->r) {

            // 叶子节点，无需创建子节点

            return;

        }

        int mid = node->l + (node->r - node->l) / 2;

        if (node->left == nullptr) {

            // 左子节点为空，创建左子节点

            node->left = new SegmentNode(node->l, mid, defaultValue);

        }

        if (node->right == nullptr) {

            // 右子节点为空，创建右子节点

            node->right = new SegmentNode(mid + 1, node->r, defaultValue);

        }

    }

    // 单点更新：将下标 index 的值更新为 value

    void update(SegmentNode* node, int index, int value) {

        if (node->l == node->r) {

            node->mergeVal = value;

            return;

        }

        // 动态创建子节点

        initChildrenIfNeeded(node); // [!code ++]

        int mid = node->l + (node->r - node->l) / 2;

        if (index <= mid) {

            update(node->left, index, value);

        } else {

            update(node->right, index, value);

        }

        node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);

    }

    // 区间查询：返回区间 [qL, qR] 的聚合值

    int query(SegmentNode* node, int qL, int qR) {

        if (node->r < qL || node->l > qR) {

            throw std::invalid_argument("Invalid query range");

        }

        if (qL <= node->l && node->r <= qR) {

            return node->mergeVal;

        }

        int mid = node->l + (node->r - node->l) / 2;

        if (qR <= mid) {

            return query(node->left, qL, qR);

        } else if (qL > mid) {

            return query(node->right, qL, qR);

        } else {

            return merger(query(node->left, qL, mid), query(node->right, mid + 1, qR));

        }

    }

    // 辅助函数，递归释放节点内存

    void deleteTree(SegmentNode* node) {

        if (!node) return;

        deleteTree(node->left);

        deleteTree(node->right);

        delete node;

    }

public:

    // 构造函数

    DynamicSegmentTree(int start, int end, std::function<int(int, int)> merger, int defaultValue)

        : merger(merger), defaultValue(defaultValue) {

        // 只创建根节点，初始值均为 defaultValue

        root = new SegmentNode(start, end, defaultValue);

    }

    // 析构函数，释放内存

    ~DynamicSegmentTree() {

        deleteTree(root);

    }

    // 单点更新接口

    void update(int index, int value) {

        update(root, index, value);

    }

    // 区间查询接口：返回区间 [qL, qR] 的聚合值

    int query(int qL, int qR) {

        if(qL > qR) {

            throw std::invalid_argument("Invalid query range");

        }

        return query(root, qL, qR);

    }

};
```

你可以利用力扣第 307 题「 [区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) 」来验证这个实现的正确性。需要注意的是，动态线段树初始化时只有一个根节点，我们需要在代码中手动调用 `update` 方法把 `nums` 数组中的每个元素更新到线段树中：

```
class NumArray {

private:

    DynamicSegmentTree* segmentTree;

public:

    NumArray(vector<int>& nums) {

        // 初始化线段树，区间范围为 [0, nums.length - 1]

        segmentTree = new DynamicSegmentTree(0, nums.size() - 1, 

                                            { return a + b; }, 0);

        // 将 nums 数组中的每个元素更新到线段树中

        for (int i = 0; i < nums.size(); i++) {

            segmentTree->update(i, nums[i]);

        }

    }

    

    ~NumArray() {

        delete segmentTree;

    }

    

    void update(int index, int val) {

        segmentTree->update(index, val);

    }

    

    int sumRange(int left, int right) {

        return segmentTree->query(left, right);

    }

};
```

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表