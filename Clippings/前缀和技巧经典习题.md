---
title: "前缀和技巧经典习题"
source: "https://labuladong.online/zh/algo/problem-set/perfix-sum/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有前缀和算法的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [前缀和技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/)
- [哈希表原理](https://labuladong.online/zh/algo/data-structure-basic/hashmap-basic/)

## 一、前缀和

### 1314\. 矩阵区域和

**1314\. 矩阵区域和** | [力扣](https://leetcode.cn/problems/matrix-block-sum/) | [LeetCode](https://leetcode.com/problems/matrix-block-sum/)

给你一个 `m x n`  的矩阵  `mat`  和一个整数 `k` ，请你返回一个矩阵  `answer`  ，其中每个  `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和：

- `i - k <= r <= i + k, `
- `j - k <= c <= j + k` 且
- `(r, c)` 在矩阵内。

**示例 1：**

```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[12,21,16],[27,45,33],[24,39,28]]
```

**示例 2：**

```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
输出：[[45,45,45],[45,45,45],[45,45,45]]
```

**提示：**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n, k <= 100`
- `1 <= mat[i][j] <= 100`

题目来源： [力扣 1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/) 。

#### 基本思路

这道题可以直接套用前文 [前缀和数组技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 中讲 [304\. 二维区域和检索](https://leetcode.cn/problems/range-sum-query-2d-immutable/description/) 时实现的 `NumMatrix` 类，没什么难度。主要注意下通过 `min, max` 函数优雅避免索引越界的技巧，这个还是蛮常用的。

#### 解法代码

#### 算法可视化

算法可视化

### 724\. 寻找数组的中心下标

**724\. 寻找数组的中心下标** | [力扣](https://leetcode.cn/problems/find-pivot-index/) | [LeetCode](https://leetcode.com/problems/find-pivot-index/)

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

**示例 1：**

```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

**示例 2：**

```
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

**示例 3：**

```
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

**提示：**

- `1 <= nums.length <= 10<sup>4</sup>`
- `-1000 <= nums[i] <= 1000`

**注意：** 本题与主站 1991 题相同： [https://leetcode-cn.com/problems/find-the-middle-index-in-array/](https://leetcode-cn.com/problems/find-the-middle-index-in-array/)

题目来源： [力扣 724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/) 。

#### 基本思路

这道题考察前文讲的 [前缀和技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) ，有了前缀和数组 `preSum` ，就可以根据 `preSum` 快速计算 `nums` 中任意位置的左侧元素和右侧元素之和了。

#### 解法代码

#### 算法可视化

算法可视化

---

## 二、前缀积

除了前缀和，也可以构建前缀积数组，两个元素相除的结果是子数组的乘积，但唯一需要注意的是，要防止 0 作为除数。

### 238\. 除自身以外数组的乘积

**238\. 除自身以外数组的乘积** | [力扣](https://leetcode.cn/problems/product-of-array-except-self/) | [LeetCode](https://leetcode.com/problems/product-of-array-except-self/)

给你一个整数数组 `nums` ，返回 数组  `answer`  ，其中  `answer[i]` 等于 `nums`  中除  `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，** 且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**

- `2 <= nums.length <= 10<sup>5</sup>`
- `-30 <= nums[i] <= 30`
- **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内

**进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

题目来源： [力扣 238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/) 。

#### 基本思路

这道题和 [前缀和数组技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 有些类似，前缀和数组中两个元素之差是子数组元素之和，那么如果构造「前缀积」数组，两个元素相除就是子数组元素之积。

所以我们构造一个 `prefix` 数组记录「前缀积」，再用一个 `suffix` 记录「后缀积」，根据前缀和后缀积就能计算除了当前元素之外其他元素的积。

#### 解法代码

#### 算法可视化

算法可视化

### 1352\. 最后 K 个数的乘积

**1352\. 最后 K 个数的乘积** | [力扣](https://leetcode.cn/problems/product-of-the-last-k-numbers/) | [LeetCode](https://leetcode.com/problems/product-of-the-last-k-numbers/)

请你实现一个「数字乘积类」 `ProductOfNumbers` ，要求支持下述两种方法：

1.` add(int num)`

- 将数字 `num` 添加到当前数字列表的最后面。

2.` getProduct(int k)`

- 返回当前数字列表中，最后 `k` 个数字的乘积。
- 你可以假设当前列表中始终 **至少** 包含 `k` 个数字。

题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。

**示例：**

```
输入：
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

输出：
[null,null,null,null,null,null,20,40,0,null,32]

解释：
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20
productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32
```

**提示：**

- `add` 和 `getProduct`  两种操作加起来总共不会超过  `40000` 次。
- `0 <= num <= 100`
- `1 <= k <= 40000`

题目来源： [力扣 1352. 最后 K 个数的乘积](https://leetcode.cn/problems/product-of-the-last-k-numbers/) 。

#### 基本思路

如果你看过前文 [小而美的算法技巧：前缀和数组](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 这道题就不难，前缀和和前缀积很类似，只不过乘积中如果有 0 需要特殊处理。

#### 解法代码

#### 算法可视化

算法可视化

## 三、前缀和 + 哈希表

前缀和数组帮你快速计算子数组的元素之和，但如果让你寻找某个符合条件的子数组，怎么办？

比方说，让你在 `nums` 中寻找和为 `target` 的子数组，就算有前缀和数组的帮助，你也要写个嵌套 for 循环：

但我们可以借助哈希表记录每个前缀和对应的索引，这样就能快速计算目标和为 `target` 的子数组了：

这样，时间复杂度就从平方级降到了线性。以下是几道例题。

---

### 525\. 连续数组

**525\. 连续数组** | [力扣](https://leetcode.cn/problems/contiguous-array/) | [LeetCode](https://leetcode.com/problems/contiguous-array/)

给定一个二进制数组 `nums`, 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1:**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2:**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `nums[i]` 不是 `0` 就是 `1`

题目来源： [力扣 525. 连续数组](https://leetcode.cn/problems/contiguous-array/) 。

#### 基本思路

首先，我们做一个等价，题目让你找 `0` 和 `1` 数量相同的最长子数组， **如果我们把 `0` 视作 `-1` ，就把题目转变成了：寻找和为 0 的最长子数组** 。

涉及到和为 `xxx` 的子数组，就是要考察 [前缀和技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 和哈希表的结合使用了。

求和为 0 的最长子数组，相当于让你去 `preSum` 数组中找 `i, j` ，使得 `preSum[i] - preSum[j] == 0` ，其中 `i > j` 且 `i - j` 要尽可能大。

那么我们用一个哈希表 `valToIndex` 存储前缀和到索引的映射，给定任意 `preSum[i]` ，我们都能通过 `valToIndex` 快速判断是否存在 `j` ，使得 `preSum[i] - preSum[j] == 0` 。

值得一提的是，我给的解法中 `preSum` 数组可以进一步简化成变量，这个优化可以留给你来做。

#### 解法代码

#### 算法可视化

算法可视化

### 523\. 连续的子数组和

**523\. 连续的子数组和** | [力扣](https://leetcode.cn/problems/continuous-subarray-sum/) | [LeetCode](https://leetcode.com/problems/continuous-subarray-sum/)

给你一个整数数组 `nums` 和一个整数  `k` ，如果  `nums` 有一个 **好的子数组** 返回 `true`  ，否则返回 `false` ：

一个 **好的子数组** 是：

- 长度 **至少为 2** ，且
- 子数组元素总和为 `k` 的倍数。

**注意** ：

- **子数组** 是数组中 **连续** 的部分。
- 如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。 `0` **始终** 视为 `k` 的一个倍数。

**示例 1：**

```
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
```

**示例 2：**

```
输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
```

**示例 3：**

```
输入：nums = [23,2,6,4,7], k = 13
输出：false
```

**提示：**

- `1 <= nums.length <= 10<sup>5</sup>`
- `0 <= nums[i] <= 10<sup>9</sup>`
- `0 <= sum(nums[i]) <= 2<sup>31</sup> - 1`
- `1 <= k <= 2<sup>31</sup> - 1`

题目来源： [力扣 523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/) 。

#### 基本思路

这道题和 [525\. 连续数组](https://leetcode.cn/problems/contiguous-array/description/) 非常相似，都是考察 [前缀和技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 和哈希表的结合使用。

本题让你寻找长度至少为 2 且和为 `k` 的倍数的子数组，翻译一下就是：

**寻找 `i, j` 使得 `(preSum[i] - preSum[j]) % k == 0` 且 `i - j >= 2`** 。

另外， `(preSum[i] - preSum[j]) % k == 0` 其实就是 `preSum[i] % k == preSum[j] % k` 。

所以我们使用一个哈希表，记录 `preSum[j] % k` 的值以及对应的索引，就可以迅速判断 `preSum[i]` 是否符合条件了。

具体思路看代码注释吧，和 [525\. 连续数组](https://leetcode.cn/problems/contiguous-array/description/) 的代码基本相同，可以对照着看。

#### 解法代码

#### 算法可视化

算法可视化

### 560\. 和为 K 的子数组

**560\. 和为 K 的子数组** | [力扣](https://leetcode.cn/problems/subarray-sum-equals-k/) | [LeetCode](https://leetcode.com/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数  `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**

- `1 <= nums.length <= 2 * 10<sup>4</sup>`
- `-1000 <= nums[i] <= 1000`
- `-10<sup>7</sup> <= k <= 10<sup>7</sup>`

题目来源： [力扣 560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) 。

#### 基本思路

很多读者看到这个题，忍不住就想用 [滑动窗口框架模板](https://labuladong.online/zh/algo/essential-technique/sliding-window-framework/) 对吧？

这很好，说明你对滑动窗口算法已经有感觉了。我在框架模板总结中说过，用滑动窗口算要问自己三个问题：

1、什么时候扩大窗口？当窗口内的元素和小于 k 时，就扩大窗口。

2、什么时候缩小窗口？当窗口内的元素和大于 k 时，就缩小窗口。

3、什么时候找到答案？当窗口内的元素和等于 k 时，就找到了答案。

看起来很合理，结合这个思路和滑动窗口代码模板，你应该五分钟之内就能写出解法。

但是我想说，这道题不能用滑动窗口，因为你忽略了一个隐含前提：

当窗口内的元素和小于 k 时，你为什么想扩大窗口？因为你默认扩大窗口能让窗口内的元素和变大。

同理，当窗口内的元素和大于 k 时，你为什么想缩小窗口？因为你默认缩小窗口能让窗口内的元素和变小。

但是上述前提在这道题并不成立，因为数组中包含负数。

所以，这道题其实在考察 [前缀和技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 和哈希表的结合使用，请你先解决 [523\. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/description/) 和 [525\. 连续数组](https://leetcode.cn/problems/contiguous-array/description/) ，然后这道题就很容易解决了。

本题和前两题的最大区别在于，需要在维护 `preSum` 前缀和数组的同时动态维护 `count` 映射，而不能等到 `preSum` 计算完成后再处理 `count` ，因为 `count[need]` 应该维护 `preSum[0..i]` 中值为 `need` 的元素个数。

结合前两题的思路，本题思路看代码注释吧。

> PS：我给出的代码是保留 `preSum` 数组的，实际上你发现我们一直在访问最新的 `preSum[i]` ，根本不需要 `i` 之前的前缀和，所以实际上我们根本不需要一整个 `preSum` 数组，只要维护一个变量记录最新的前缀和就行了，这个优化就留给你去做吧。

#### 解法代码

#### 算法可视化

算法可视化

### 1124\. 表现良好的最长时间段

**1124\. 表现良好的最长时间段** | [力扣](https://leetcode.cn/problems/longest-well-performing-interval/) | [LeetCode](https://leetcode.com/problems/longest-well-performing-interval/)

给你一份工作时间表 `hours` ，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「 **劳累的一天** 」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于** 「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

**示例 1：**

```
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```

**示例 2：**

```
输入：hours = [6,6,6]
输出：0
```

**提示：**

- `1 <= hours.length <= 10<sup>4</sup>`
- `0 <= hours[i] <= 16`

题目来源： [力扣 1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/) 。

#### 基本思路

题目说 `hours[i]` 以 8 作为分界线， **那么我们就要条件反射地想到对数据进行「归一化」处理** ，比如把所有大于 8 的元素视为 +1，把所有小于 8 的元素视为 -1，这样一来，这道题就改造成了：计算数组中元素和大于 0 的子数组的最大长度。

然后回想之前子数组相关的题目，第 [525\. 连续数组](https://leetcode.cn/problems/contiguous-array/description/) 是问和为 0 的子数组， [974\. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/) 是问和能被 `k` 整除的子数组，这道题和它们很类似，都是考察前缀和 + 哈希表的组合场景。

我们借助哈希表存储前缀和到索引的映射，这样就能快速寻找一个 `j` 使得 `preSum[i] - preSum[j] > 0` 了，具体看代码注释吧。值得一提的是，我给的解法中 `preSum` 数组可以进一步简化成变量，这个优化可以留给你来做。

#### 解法代码

#### 算法可视化

算法可视化

### 974\. 和可被 K 整除的子数组

**974\. 和可被 K 整除的子数组** | [力扣](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) | [LeetCode](https://leetcode.com/problems/subarray-sums-divisible-by-k/)

给定一个整数数组 `nums`  和一个整数 `k` ，返回其中元素之和可被 `k` 整除的非空 **子数组** 的数目。

**子数组** 是数组中 **连续** 的部分。

**示例 1：**

```
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

**示例 2:**

```
输入: nums = [5], k = 9
输出: 0
```

**提示:**

- `1 <= nums.length <= 3 * 10<sup>4</sup>`
- `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
- `2 <= k <= 10<sup>4</sup>`

题目来源： [力扣 974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) 。

#### 基本思路

这道题是前文 [前缀和数组技巧](https://labuladong.online/zh/algo/data-structure/prefix-sum/) 加上 [前缀和与哈希表结合](https://labuladong.online/zh/algo/problem-set/perfix-sum/) 后的进一步扩展，本题的哈希表中不是记录前缀和到索引的映射，而是记录前缀和的余数到频率的映射。

具体来讲，子数组 `nums[i..j]` 中的元素之和能被 `k` 整除，是啥意思？就是说 `sum(nums[i..j]) % k == 0` ，但如果按照这个思路，就算有前缀和数组的辅助，想计算所有能够整除 `k` 的子数组也必须得嵌套 for 循环来穷举 `i` 和 `j` ：

这样不是不可以，但显得效率不是很高，是否能避免嵌套 for 循环，用空间换时间的方式解决这个问题呢？

可以的。子数组 `nums[i..j]` 中的元素之和能被 `k` 整除，也可以理解为：

而 `sum(nums[0..i])` 是我们可以用前缀和数组快速计算的，在配合哈希表对子数组的数量进行计数，即可一次遍历解决这个问题，具体实现看代码吧。值得一提的是，我给的解法中 `preSum` 数组可以进一步简化成变量，这个优化可以留给你来做。

#### 解法代码

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表