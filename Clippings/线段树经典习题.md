---
title: "线段树经典习题"
source: "https://labuladong.online/zh/algo/problem-set/segment-tree/"
author:
  - "[[labuladong]]"
published:
created: 2026-02-17
description: "本文汇总了 力扣/LeetCode 上所有线段树结构相关的经典习题，包含 labuladong 思路讲解和算法可视化，支持 Java/C++/Python/Golang/JavaScript。"
tags:
  - "clippings"
---
前置知识

阅读本文前，你需要先学习：

- [线段树核心原理](https://labuladong.online/zh/algo/data-structure-basic/segment-tree-basic/)
- [优化：实现懒更新线段树](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/)

线段树作为高级数据结构，对应的题目一般都是困难级别。但是只要了解的线段树结构的使用场景，加上 [优化：实现懒更新线段树](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) 中提供的线段树通用模板，我们只需要简单地调用 API，就可以轻松解决这些问题。

### 729\. 我的日程安排表 I

实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的日程安排不会造成 **重复预订** ，则可以存储这个新的日程安排。

当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 **重复预订** 。

日程可以用一对整数 `start` 和 `end` 表示，这里的时间是半开区间，即 `[start, end)`, 实数 `x` 的范围为，   `start <= x < end` 。

实现 `MyCalendar` 类：

- `MyCalendar()` 初始化日历对象。
- `boolean book(int start, int end)` 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 `true` 。否则，返回 `false` 并且不要将该日程安排添加到日历中。

**示例：**

```
输入：
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
输出：
[null, true, false, true]

解释：
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。
myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。
```

**提示：**

- `0 <= start < end <= 10<sup>9</sup>`
- 每个测试用例，调用 `book` 方法的次数最多不超过 `1000` 次。

题目来源： [力扣 729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/) 。

#### 基本思路

这道题可以有两种思路，第一种思路是利用 [线段树结构](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) ，第二种思路是利用 [二叉搜索树（TreeMap）](https://labuladong.online/zh/algo/data-structure-basic/tree-map-basic/) 。

线段树的思路比较简单，可以创建一个计算区间最大值的线段树，每次 `book(start, end)` 之前先对区间 `[start, end)` 进行查询，如果这个区间内的元素最大值大于 0，说明这个区间内已经存在会议，返回 false，否则返回 true，然后对区间 `[start, end)` 的所有元素加一。

线段树结构对区间更新和查询的复杂度都是 `logN` ，所以 `book` 方法的复杂度就是 `logN` 。

可以直接使用 [懒更新线段树代码实现](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) 最后给出的 `AllInOneSegmentTree` 创建一个最大值线段树，完成这道题：

这道题也可以用基本的二叉搜索树结构（TreeMap）解决。什么情况下一个日程会有冲突？有两种情况：

1、之前的那个日程还没结束，这个日程就开始了。

2、这个日程还没结束的时候，下个日程就开始了。

在这里，我们用一个 [TreeMap](https://labuladong.online/zh/algo/data-structure-basic/tree-map-basic/) 存储每个日程，TreeMap 的键是日程的开始时间，值是日程的结束时间，这样就可以通过 `floorKey` 和 `ceilingKey` 方法判断上述两种情况是否发生了，具体看解法吧。

#### 解法代码

#### 算法可视化

算法可视化

### 731\. 我的日程安排表 II

实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。

`MyCalendar` 有一个 `book(int start, int end)` 方法。它意味着在 `start` 到 `end` 时间内增加一个日程安排，注意，这里的时间是半开区间，即 `[start, end)`, 实数 `x` 的范围为，   `start <= x < end` 。

当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。

每次调用 `MyCalendar.book` 方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 `true` 。否则，返回 `false` 并且不要将该日程安排添加到日历中。

请按照以下步骤调用 `MyCalendar` 类: `MyCalendar cal = new MyCalendar();``MyCalendar.book(start, end)`

**示例：**

```
MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(50, 60); // returns true
MyCalendar.book(10, 40); // returns true
MyCalendar.book(5, 15); // returns false
MyCalendar.book(5, 10); // returns true
MyCalendar.book(25, 55); // returns true
解释： 
前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。
第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。
第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。
第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；
时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。
```

**提示：**

- 每个测试用例，调用 `MyCalendar.book`  函数最多不超过  `1000` 次。
- 调用函数 `MyCalendar.book(start, end)` 时， `start` 和  `end` 的取值范围为 `[0, 10^9]` 。

题目来源： [力扣 731. 我的日程安排表 II](https://leetcode.cn/problems/my-calendar-ii/) 。

#### 基本思路

这道题属于线段树的模板题，可以直接使用 [线段树通用实现](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) 实现的 `AllInOneSegmentTree` 类创建一个计算最大值的线段树，区间最大值就是重叠的会议数量，如果能成功注册会议，则给区间加一。

#### 解法代码

#### 算法可视化

算法可视化

### 732\. 我的日程安排表 III

当 `k` 个日程存在一些非空交集时（即, `k` 个日程包含了一些相同时间），就会产生 `k` 次预订。

给你一些日程安排 `[startTime, endTime)` ，请你在每个日程安排添加后，返回一个整数 `k` ，表示所有先前日程安排会产生的最大 `k` 次预订。

实现一个 `MyCalendarThree` 类来存放你的日程安排，你可以一直添加新的日程安排。

- `MyCalendarThree()` 初始化对象。
- `int book(int startTime, int endTime)` 返回一个整数 `k` ，表示日历中存在的 `k` 次预订的最大值。

**示例：**

```
输入：
["MyCalendarThree", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
输出：
[null, 1, 1, 2, 3, 3, 3]

解释：
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。
myCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。
myCalendarThree.book(5, 10); // 返回 3
myCalendarThree.book(25, 55); // 返回 3
```

**提示：**

- `0 <= startTime < endTime <= 10<sup>9</sup>`
- 每个测试用例，调用 `book`  函数最多不超过  `400` 次

题目来源： [力扣 732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/) 。

#### 基本思路

在这道题中，每次调用 `book` 时，需要返回最大的重叠区间数，属于线段树的模板题，可以直接使用 [线段树通用实现](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) 实现的 `AllInOneSegmentTree` 类。

我们创建一个计算最大值的线段树，每次 `book` 就相当于在区间 `[startTime, endTime)` 上加一；最大的重叠区间数就是整个区间中的最大值。直接看代码吧，比较简单。

#### 解法代码

#### 算法可视化

算法可视化

### 699\. 掉落的方块

**699\. 掉落的方块** | [力扣](https://leetcode.cn/problems/falling-squares/) | [LeetCode](https://leetcode.com/problems/falling-squares/)

在二维平面上的 x 轴上，放置着一些方块。

给你一个二维整数数组 `positions` ，其中 `positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]` 表示：第 `i` 个方块边长为 `sideLength<sub>i</sub>` ，其左侧边与 x 轴上坐标点  `left<sub>i</sub>` 对齐。

每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 **另一个正方形的顶边** 或者是 **x 轴上** 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。

在每个方块掉落后，你必须记录目前所有已经落稳的 **方块堆叠的最高高度** 。

返回一个整数数组 `ans` ，其中 `ans[i]` 表示在第 `i` 块方块掉落后堆叠的最高高度。

**示例 1：**

![](https://labuladong.online/images/lc/uploads/2021/04/28/fallingsq1-plane.jpg)
```
输入：positions = [[1,2],[2,3],[6,1]]
输出：[2,5,5]
解释：
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。
第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。
第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。
因此，返回 [2, 5, 5] 作为答案。
```

**示例 2：**

```
输入：positions = [[100,100],[200,100]]
输出：[100,100]
解释：
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。
第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。
因此，返回 [100, 100] 作为答案。
注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。
```

**提示：**

- `1 <= positions.length <= 1000`
- `1 <= left<sub>i</sub> <= 10<sup>8</sup>`
- `1 <= sideLength<sub>i</sub> <= 10<sup>6</sup>`

题目来源： [力扣 699. 掉落的方块](https://leetcode.cn/problems/falling-squares/) 。

#### 基本思路

这道题属于线段树的模板题，可以直接使用 [线段树通用实现](https://labuladong.online/zh/algo/data-structure/segment-tree-lazy-update/) 实现的 `AllInOneSegmentTree` 类。

每个方块其实就是 `[left_i, left_i + sideLength_i)` 这样一个左闭右开区间（因为题目说正方形的边界接触不算着陆，左闭右开符合这种情况）；每次正方形下落稳定后的高度，就相当于给这个区间中的最大值加上 `sideLength_i` 的高度；题目要的答案就是每次完成下落之后，整个区间的最大高度。

所以我们可以创建一个求最大值的线段树，每次下落的时候，使用 `query` 查询区间最大值，加上当前正方形的高度后再用 `updateRange` 更新区间的最大值，同时用一个 `maxHeight` 变量维护整个区间的最大值即可。

看题目的数据规模， `left_i` 的最大值为 `10^8` ， `sideLength_i` 的最大值为 `10^6` ，最大情况下，所有正方形的最右侧边界坐标不会超过 `10^8 + 10^6` ，我们干脆直接开 `2 * 10^8` 的区间，肯定够用。

具体看代码吧。

#### 解法代码

#### 算法可视化

算法可视化

更新时间：2026/02/17 14:24

## 评论

Markdown

Ctrl+Enter 发表