# 二叉树算法核心思维

  

## 目录

  

- [二叉树解题思维模式总结](#二叉树解题思维模式总结)

- [二叉树的重要性](#二叉树的重要性)

- [深入理解前中后序](#深入理解前中后序)

- [两种解题思路](#两种解题思路)

- [后序位置的特殊之处](#后序位置的特殊之处)

- [以树的视角看动归/回溯/DFS算法](#以树的视角看动归回溯dfs算法的区别和联系)

- [层序遍历](#层序遍历)

  

---

  

## 二叉树解题思维模式总结

  

二叉树解题的思维模式分两类：

  

### 1. 遍历思维模式

**是否可以通过遍历一遍二叉树得到答案？**

- 如果可以，用一个 `traverse` 函数配合外部变量来实现

- 这叫「遍历」的思维模式

  

### 2. 分解问题思维模式

**是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？**

- 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值

- 这叫「分解问题」的思维模式

  

### 核心思考

无论使用哪种思维模式，你都需要思考：

  

> **如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？**


> 其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

  

---

  

## 二叉树的重要性

  

### 经典排序算法与二叉树的关系

  

#### 快速排序 = 二叉树前序遍历

  

```cpp

void sort(int nums[], int lo, int hi) {

    if (lo >= hi) {

        return;

    }

    // ****** 前序位置 ******

    // 对 nums[lo..hi] 进行切分，将 nums[p] 排好序

    // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]

    int p = partition(nums, lo, hi);

  

    // 去左右子数组进行切分

    sort(nums, lo, p - 1);

    sort(nums, p + 1, hi);

}

```

  

**核心思想**：先构造分界点，然后去左右子数组构造分界点，这就是二叉树的前序遍历。

  

#### 归并排序 = 二叉树后序遍历

  

```cpp

// 定义：排序 nums[lo..hi]

void sort(int[] nums, int lo, int hi) {

    if (lo == hi) {

        return;

    }

    int mid = (lo + hi) / 2;

    // 利用定义，排序 nums[lo..mid]

    sort(nums, lo, mid);

    // 利用定义，排序 nums[mid+1..hi]

    sort(nums, mid + 1, hi);

  

    // ****** 后序位置 ******

    // 此时两部分子数组已经被排好序

    // 合并两个有序数组，使 nums[lo..hi] 有序

    merge(nums, lo, mid, hi);

}

```

  

**核心思想**：先对左右子数组排序，然后合并，这就是二叉树的后序遍历框架。

  

### 关键洞察

> 只要涉及递归，都可以抽象成二叉树的问题。

  

---

  

## 深入理解前中后序

  

### 二叉树递归遍历框架

  

```cpp

// 二叉树的遍历框架

void traverse(TreeNode* root) {

    if (root == nullptr) {

        return;

    }

    // 前序位置

    traverse(root->left);

    // 中序位置

    traverse(root->right);

    // 后序位置

}

```

  

### 前中后序位置的本质

  

与数组和链表的递归遍历对比：

  

```cpp

// 递归遍历数组

void traverse(vector<int>& arr, int i) {

    if (i == arr.size()) {

        return;

    }

    // 前序位置

    traverse(arr, i + 1);

    // 后序位置

}

  

// 递归遍历单链表

void traverse(ListNode* head) {

    if (head == nullptr) {

        return;

    }

    // 前序位置

    traverse(head->next);

    // 后序位置

}

```

  

### 三个位置的特殊含义

  

- **前序位置**：刚进入一个节点（元素）的时候

- **中序位置**：一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候

- **后序位置**：即将离开一个节点（元素）的时候

  

### 位置的执行时机

  

```

前序位置 → 遍历左子树 → 中序位置 → 遍历右子树 → 后序位置

```

  

### 倒序打印链表示例

  

```cpp

// 递归遍历单链表，倒序打印链表元素

void traverse(ListNode* head) {

    if (head == nullptr) {

        return;

    }

    traverse(head->next);

    // 后序位置

    cout << head->val << endl;

}

```

  

### 每个节点的唯一位置

  

```

       节点A

     /       \

   前序      后序

  /   \     /   \

中序   右   左   中序

```

  

每个节点都有「唯一」属于自己的前中后序位置。

  

### 多叉树没有中序位置的原因

  

二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

  

---

  

## 两种解题思路

  

### 函数命名习惯

  

- **遍历思路**：函数签名一般是 `void traverse(...)`，没有返回值，靠更新外部变量来计算结果

- **分解问题思路**：函数名根据具体功能而定，一般会有返回值，返回值是子问题的计算结果

  

### 示例：二叉树的最大深度（LeetCode 104）

  

#### 思路一：遍历思维

  

```cpp

// 遍历的思路

class Solution {

    // 记录最大深度

    int res = 0;

    // 记录遍历到的节点的深度

    int depth = 0;

  

public:

    int maxDepth(TreeNode* root) {

        traverse(root);

        return res;

    }

  

    // 遍历二叉树

    void traverse(TreeNode* root) {

        if (root == nullptr) {

            return;

        }

  

        // 前序遍历位置（进入节点）增加深度

        depth++;

        // 遍历到叶子节点时记录最大深度

        if (root->left == nullptr && root->right == nullptr) {

            res = std::max(res, depth);

        }

        traverse(root->left);

        traverse(root->right);

  

        // 后序遍历位置（离开节点）减少深度

        depth--;

    }

};

```

  

#### 思路二：分解问题

  

```cpp

// 分解问题的思路

class Solution {

public:

    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度

    int maxDepth(TreeNode* root) {

        if (root == nullptr) {

            return 0;

        }

        // 利用定义，计算左右子树的最大深度

        int leftMax = maxDepth(root->left);

        int rightMax = maxDepth(root->right);

  

        // 根据左右子树的最大深度推出原二叉树的最大深度

        // 整棵树的最大深度等于左右子树的最大深度取最大值，

        // 然后再加上根节点自己

        return 1 + std::max(leftMax, rightMax);

    }

};

```

  

### 前序遍历的两种实现

  

#### 遍历思路实现

  

```cpp

// 用遍历的思路计算前序遍历结果

class Solution {

public:

    // 存放前序遍历结果

    vector<int> res;

  

    vector<int> preorderTraversal(TreeNode* root) {

        traverse(root);

        return res;

    }

  

    // 二叉树遍历函数

    void traverse(TreeNode* root) {

        if (root == nullptr) {

            return;

        }

        // 前序位置

        res.push_back(root->val);

        traverse(root->left);

        traverse(root->right);

    }

};

```

  

#### 分解问题思路实现

  

```cpp

class Solution {

public:

    // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果

    vector<int> preorderTraversal(TreeNode* root) {

        vector<int> res;

        if (root == nullptr) {

            return res;

        }

        // 前序遍历的结果，root->val 在第一个

        res.push_back(root->val);

        // 利用函数定义，后面接着左子树的前序遍历结果

        vector<int> left = preorderTraversal(root->left);

        res.insert(res.end(), left.begin(), left.end());

        // 利用函数定义，最后接着右子树的前序遍历结果

        vector<int> right = preorderTraversal(root->right);

        res.insert(res.end(), right.begin(), right.end());

  

        return res;

    }

};

```

  

### 通用思考过程

  

遇到一道二叉树的题目时：

  

1. **是否可以通过遍历一遍二叉树得到答案？** 如果可以，用一个 `traverse` 函数配合外部变量来实现。

  

2. **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？** 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

  

3. **无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。**

  

---

  

## 后序位置的特殊之处

  

### 前中后序位置的能力对比

  

> **仔细观察，前中后序位置的代码，能力依次增强。**

  

- **前序位置**：只能从函数参数中获取父节点传递来的数据

- **中序位置**：不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据

- **后序位置**：最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据

  

### 两个问题的对比

  

#### 问题1：打印每个节点所在的层数

  

```cpp

// 二叉树遍历函数

void traverse(TreeNode root, int level) {

    if (root == null) {

        return;

    }

    // 前序位置

    printf("节点 %s 在第 %d 层", root.val, level);

    traverse(root.left, level + 1);

    traverse(root.right, level + 1);

}

  

// 这样调用

traverse(root, 1);

```

  

#### 问题2：打印每个节点的左右子树节点数

  

```cpp

// 定义：输入一棵二叉树，返回这棵二叉树的节点总数

int count(TreeNode root) {

    if (root == null) {

        return 0;

    }

    int leftCount = count(root.left);

    int rightCount = count(root.right);

    // 后序位置

    printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",

            root, leftCount, rightCount);

  

    return leftCount + rightCount + 1;

}

```

  

### 关键洞察

  

> **一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你必须遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。**

  

**结论**：一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

  

### 实战案例：二叉树的直径（LeetCode 543）

  

#### 问题描述

二叉树的「直径」长度，就是任意两个结点之间的路径长度。

  

#### 低效解法（O(N²)）

  

```cpp

class Solution {

public:

    // 记录最大直径的长度

    int maxDiameter = 0;

  

    int diameterOfBinaryTree(TreeNode* root) {

        // 对每个节点计算直径，求最大直径

        traverse(root);

        return maxDiameter;

    }

  

private:

    // 遍历二叉树

    void traverse(TreeNode* root) {

        if (root == nullptr) {

            return;

        }

        // 对每个节点计算直径

        int leftMax = maxDepth(root->left);

        int rightMax = maxDepth(root->right);

        int myDiameter = leftMax + rightMax;

        // 更新全局最大直径

        maxDiameter = max(maxDiameter, myDiameter);

  

        traverse(root->left);

        traverse(root->right);

    }

  

    // 计算二叉树的最大深度

    int maxDepth(TreeNode* root) {

        if (root == nullptr) {

            return 0;

        }

        int leftMax = maxDepth(root->left);

        int rightMax = maxDepth(root->right);

        return 1 + max(leftMax, rightMax);

    }

};

```

  

#### 高效解法（O(N)）

  

```cpp

class Solution {

    // 记录最大直径的长度

    int maxDiameter = 0;

  

public:

    int diameterOfBinaryTree(TreeNode* root) {

        maxDepth(root);

        return maxDiameter;

    }

  

    int maxDepth(TreeNode* root) {

        if (root == nullptr) {

            return 0;

        }

        int leftMax = maxDepth(root->left);

        int rightMax = maxDepth(root->right);

        // 后序位置，顺便计算最大直径

        int myDiameter = leftMax + rightMax;

        maxDiameter = max(maxDiameter, myDiameter);

  

        return 1 + max(leftMax, rightMax);

    }

};

```

  

### 优化思路

  

> **遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。**

  

---

  

## 以树的视角看动归/回溯/DFS算法的区别和联系

  

### 三种算法的本质

  

> **动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：**

>

> - **动态规划算法**属于分解问题（分治）的思路，它的关注点在整棵「子树」

> - **回溯算法**属于遍历的思路，它的关注点在节点间的「树枝」  

> - **DFS 算法**属于遍历的思路，它的关注点在单个「节点」

  

### 例子一：分解问题思想（动态规划）

  

```cpp

// 定义：输入一棵二叉树，返回这棵二叉树的节点总数

int count(TreeNode* root) {

    if (root == nullptr) {

        return 0;

    }

    // 当前节点关心的是两个子树的节点总数分别是多少

    // 因为用子问题的结果可以推导出原问题的结果

    int leftCount = count(root->left);

    int rightCount = count(root->right);

    // 后序位置，左右子树节点数加上自己就是整棵树的节点数

    return leftCount + rightCount + 1;

}

```

  

对应的斐波那契数列：

  

```cpp

// f(n) 计算第 n 个斐波那契数

int fib(int n) {

    // base case

    if (n == 0 || n == 1){

        return n;

    }

    return fib(n - 1) + fib(n - 2);

}

```

  

### 例子二：回溯算法思想

  

二叉树遍历：

  

```cpp

void traverse(TreeNode root) {

    if (root == null) return;

    printf("从节点 %s 进入节点 %s", root, root.left);

    traverse(root.left);

    printf("从节点 %s 回到节点 %s", root.left, root);

  

    printf("从节点 %s 进入节点 %s", root, root.right);

    traverse(root.right);

    printf("从节点 %s 回到节点 %s", root.right, root);

}

```

  

多叉树遍历：

  

```cpp

// 多叉树节点

class Node {

    int val;

    Node[] children;

}

  

void traverse(Node root) {

    if (root == null) return;

    for (Node child : root.children) {

        printf("从节点 %s 进入节点 %s", root, child);

        traverse(child);

        printf("从节点 %s 回到节点 %s", child, root);

    }

}

```

  

对应的回溯算法框架：

  

```cpp

// 回溯算法框架

void backtrack(...) {

    // base case

    if (...) return;

  

    for (int i = 0; i < ...; i++) {

        // 做选择

        ...

  

        // 进入下一层决策树

        backtrack(...);

  

        // 撤销刚才做的选择

        ...

    }

}

```

  

### 例子三：DFS算法思想

  

```cpp

void traverse(TreeNode* root) {

    if (root == nullptr) return;

    // 遍历过的每个节点的值加一

    root->val++;

    traverse(root->left);

    traverse(root->right);

}

```

  

对应的DFS算法（岛屿问题）：

  

```cpp

// DFS 算法核心逻辑

void dfs(int[][] grid, int i, int j) {

    int m = grid.length, n = grid[0].length;

    if (i < 0 || j < 0 || i >= m || j >= n) {

        return;

    }

    if (grid[i][j] == 0) {

        return;

    }

    // 遍历过的每个格子标记为 0

    grid[i][j] = 0;

    dfs(grid, i + 1, j);

    dfs(grid, i, j + 1);

    dfs(grid, i - 1, j);

    dfs(grid, i, j - 1);

}

```

  

### DFS vs 回溯：「做选择」位置的区别

  

```cpp

// DFS 算法把「做选择」「撤销选择」的逻辑放在 for 循环外面

void dfs(Node* root) {

    if (!root) return;

    // 做选择

    printf("enter node %s\n", root->val.c_str());

    for (Node* child : root->children) {

        dfs(child);

    }

    // 撤销选择

    printf("leave node %s\n", root->val.c_str());

}

  

// 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面

void backtrack(Node* root) {

    if (!root) return;

    for (Node* child : root->children) {

        // 做选择

        printf("I'm on the branch from %s to %s\n", root->val.c_str(), child->val.c_str());

        backtrack(child);

        // 撤销选择

        printf("I'll leave the branch from %s to %s\n", child->val.c_str(), root->val.c_str());

    }

}

```

  

**原因**：回溯算法必须把「做选择」和「撤销选择」的逻辑放在 for 循环里面，否则怎么拿到「树枝」的两个端点？

  

---

  

## 层序遍历

  

层序遍历属于迭代遍历，也比较简单，主要用来培养 BFS 思维。

  

### 基本框架

  

```cpp

// 输入一棵二叉树的根节点，层序遍历这棵二叉树

int levelTraverse(TreeNode* root) {

    if (root == nullptr) return;

    queue<TreeNode*> q;

    q.push(root);

  

    int depth = 0;

    // 从上到下遍历二叉树的每一层

    while (!q.empty()) {

        int sz = q.size();

        // 从左到右遍历每一层的每个节点

        for (int i = 0; i < sz; i++) {

            TreeNode* cur = q.front();

            q.pop();

  

            // 将下一层节点放入队列

            if (cur->left != nullptr) {

                q.push(cur->left);

            }

            if (cur->right != nullptr) {

                q.push(cur->right);

            }

        }

        depth++;

    }

    return depth;

}

```

  

### 框架说明

  

- `while` 循环控制从上到下的遍历

- `for` 循环控制从左到右的遍历

  

```

第1层: [root]

第2层: [left, right]  

第3层: [left.left, left.right, right.left, right.right]

...

```

  

### 扩展应用

  

这个框架可以灵活修改：

  

- **BFS 最短路径**：去掉 for 循环，用于求无权图的最短路径

- **Dijkstra 算法**：用于计算加权图的最短路径

  

### 递归实现层序遍历

  

#### 方法一：依赖前序遍历顺序

  

```cpp

class Solution {

public:

    vector<vector<int>> res;

  

    vector<vector<int>> levelTraverse(TreeNode* root) {

        if (root == nullptr) {

            return res;

        }

        // root 视为第 0 层

        traverse(root, 0);

        return res;

    }

  

    void traverse(TreeNode* root, int depth) {

        if (root == nullptr) {

            return;

        }

        // 前序位置，看看是否已经存储 depth 层的节点了

        if (res.size() <= depth) {

            // 第一次进入 depth 层

            res.push_back(vector<int> {});

        }

        // 前序位置，在 depth 层添加 root 节点的值

        res[depth].push_back(root->val);

        traverse(root->left, depth + 1);

        traverse(root->right, depth + 1);

    }

};

```

  

**注意**：这种解法本质还是前序遍历，不是真正的层序遍历，更像是「列序遍历」。

  

#### 方法二：真正的递归层序遍历

  

```cpp

class Solution {

private:

    vector<vector<int>> res;

public:

    vector<vector<int>> levelTraverse(TreeNode* root) {

        if (root == NULL) {

            return res;

        }

        vector<TreeNode*> nodes;

        nodes.push_back(root);

        traverse(nodes);

        return res;

    }

  

    void traverse(vector<TreeNode*>& curLevelNodes) {

        // base case

        if (curLevelNodes.empty()) {

            return;

        }

  

        // 前序位置，计算当前层的值和下一层的节点列表

        vector<int> nodeValues;

        vector<TreeNode*> nextLevelNodes;

        for (TreeNode* node : curLevelNodes) {

            nodeValues.push_back(node->val);

            if (node->left != NULL) {

                nextLevelNodes.push_back(node->left);

            }

            if (node->right != NULL) {

                nextLevelNodes.push_back(node->right);

            }

        }

  

        // 前序位置添加结果，可以得到自顶向下的层序遍历

        res.push_back(nodeValues);

  

        traverse(nextLevelNodes);

  

        // 后序位置添加结果，可以得到自底向上的层序遍历结果

        // res.push_back(nodeValues);

    }

};

```

  

这个解法把二叉树的每一层抽象理解成单链表的一个节点进行遍历，更接近 BFS 的本质。

  

---

  

## 总结

  

### 核心思维框架

  

1. **明确当前节点该做什么**

2. **明确什么时候做（前/中/后序位置）**

3. **选择合适的思维模式（遍历 vs 分解问题）**

  

### 解题步骤

  

1. **是否可以通过遍历一遍二叉树得到答案？**

   - 如果可以，用 `traverse` 函数配合外部变量

  

2. **是否可以定义递归函数，通过子问题推导原问题？**

   - 如果可以，写出递归函数定义，利用返回值

  

3. **明确每个节点需要做什么，在什么时候做**

  

### 位置选择指南

  

- **前序位置**：需要从上到下传递信息给子节点

- **中序位置**：BST 相关问题

- **后序位置**：需要从下到上获取子树信息，能力最强

  

### 算法思维对应关系

  

| 算法类型 | 思维模式 | 关注点 | 对应位置 |

|---------|---------|-------|---------|

| 动态规划 | 分解问题 | 子树整体 | 后序位置 |

| 回溯算法 | 遍历 | 树枝 | for循环内 |

| DFS算法 | 遍历 | 单个节点 | for循环外 |

  

这个框架可以推广到：

- 动态规划问题

- 回溯算法问题  

- 分治算法问题

- 图论算法问题

  

掌握了二叉树的思维，就掌握了递归的本质！